<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用spring Initializer快速创建Spring Boot项目]]></title>
    <url>%2F2018%2F12%2F17%2FBoot%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[IDE都支持使用Spring的项目创建向导快速创建一个Spring Bott项目]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java面试题]]></title>
    <url>%2F2018%2F12%2F14%2FJava%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、多线程的实现方法分别是什么?同步的实现方法分别是什么?答：多线程有两种实现方法，分别是继承Thread类与实现Runnable。接口同步的实现方面有两种，分别是synchronized、wait与notify。2、public,private,protected的作用域，以及不写时的区别?public的作用域：当前类，同包，子孙类，其他protected的作用域：当前类，同包，子孙类default的作用域：当前类，同包private的作用域：当前类不写时默认为default3、外连接分为内连接、左连接、右连接内连接是根据某个条件连接两个表共有的数据；左连接是根据某个条件以及左边的表连接数据，右边的表没数据的话则填null；右连接是根据某个条件以及右边的表连接数据，左边的表没数据的话则填null；4、数据库范式第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值。第二范式确保每个表值描述一件事第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。5、什么是JavaScript？JavaScript是客户端和服务器端脚本语言，可以插入到HTML页面中，并且是目前较热门的Web开 发语言。同时，JavaScript也是面向对象编程语言。6、索引的目的是什么？1.快速访问数据表中的特定信息，提高检索速度2.创建唯一性索引，保证数据库表中每一行数据的唯一性。3.加速表和表之间的连接4.使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间7、数据库中的事务是什么?事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。​ACID 四大特性,原子性、隔离性、一致性、持久性。8、Collection 和 Collections 的区别。Collection 是集合类的上级接口，继承与他的接口主要有Set 和List.Collections 是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。9、什么是值传递和引用传递？对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。10、null和undefind的区别null是表示一个空的对象，转为数值为0，undefind表示一个空的原始值，转为数值为NAN undefind指本该有一个值，但却并有定义，null表示没有对象，不应该有值11、什么是 Spring Framework？Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。它是轻量级、松散耦合的。它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚 力的框架。它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。12、 Spring 应用程序有哪些不同组件？Spring 应用一般有以下组件：接口 - 定义功能。Bean 类 - 它包含属性，setter 和 getter 方法，函数等。Spring 面向切面编程（AOP） - 提供面向切面编程的功能。Bean 配置文件 - 包含类的信息以及如何配置它们。用户程序 - 它使用接口。13、 什么是 Spring IOC 容器？Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。14、 什么是依赖注入？在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。15、 可以通过多少种方式完成依赖注入？通常，依赖注入可以通过三种方式完成，即：构造函数注入setter 注入接口注入在 Spring Framework 中，仅使用构造函数和 setter 注入。16、 列举 IoC 的一些好处。IoC 的一些好处是：它将最小化应用程序中的代码量。它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。它以最小的影响和最少的侵入机制促进松耦合。它支持即时的实例化和延迟加载服务。17、 spring 中有多少种 IOC 容器？BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。18、 什么是 spring bean？它们是构成用户应用程序主干的对象。Bean 由 Spring IoC 容器管理。它们由 Spring IoC 容器实例化，配置，装配和管理。Bean 是基于用户提供给容器的配置元数据创建。19、 Spring Framework 有哪些不同的功能？轻量级 - Spring 在代码量和透明度方面都很轻便。IOC - 控制反转AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。20、 列举 Spring Framework 的优点。由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。由于依赖注入和控制反转，JDBC 得以简化。它是开源免费的。21、@Component, @Controller, @Repository, @Service 有何区别？@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。22、@RequestMapping 注解有什么用？@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：类级别：映射请求的 URL方法级别：映射 URL 以及 HTTP 请求方法23、列举 spring 支持的事务管理类型Spring 支持两种类型的事务管理：1、程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。2、声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。24、什么是 AOP？AOP(Aspect-Oriented Programming), 即 面向切面编程, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 Aspect(切面)25、@Autowired 注解有什么用？@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。26、spring 支持集中 bean scope？Spring bean 支持 5 种 scope：Singleton - 每个 Spring IoC 容器仅有一个单实例。Prototype - 每次请求都会产生一个新的实例。Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。27、什么是 spring 装配当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。28、自动装配有哪些方式？Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。自动装配的不同模式：no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。29、自动装配有什么局限？覆盖的可能性 - 您始终可以使用 和 设置指定依赖项，这将覆盖自动装配。基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。30、如何在 spring 中启动注解装配？默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置&lt;context：annotation-config /&gt; 元素在 Spring 配置文件中启用它。31、@Qualifier 注解有什么用？当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。32、spring DAO 有什么用？Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。33、spring JDBC API 中存在哪些类？JdbcTemplateSimpleJdbcTemplateNamedParameterJdbcTemplateSimpleJdbcInsertSimpleJdbcCall34、使用 Spring 访问 Hibernate 的方法有哪些？我们可以通过两种方式使用 Spring 访问 Hibernate：使用 Hibernate 模板和回调进行控制反转扩展 HibernateDAOSupport 并应用 AOP 拦截器节点35、spring 支持哪些 ORM 框架HibernateiBatisJPAJDOOJB36、什么是 Aspect？aspect 由 pointcount 和 advice 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:1.如何通过 pointcut 和 advice 定位到特定的 joinpoint 上2.如何在 advice 中编写切面代码.可以简单地认为, 使用 @Aspect 注解的类就是切面.37、什么是切点（JoinPoint）程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理.在 Spring AOP 中, join point 总是方法的执行点。38、什么是通知（Advice）？特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。39、有哪些类型的通知（Advice）？Before - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用 @AfterReturning 注解标记进行配置。After Throwing - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。After (finally) - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。40、指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。41、AOP 有哪些实现方式？实现 AOP 的技术，主要分为两大类：静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；编译时编织（特殊编译器实现）类加载时编织（特殊的类加载器实现）。动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。JDK 动态代理CGLIB42、Spring AOP and AspectJ AOP 有什么区别？Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。43、如何理解 Spring 中的代理？将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。44、Spring MVC 框架有什么用？Spring Web MVC 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。 MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。45、介绍一下 WebApplicationContextWebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。46、Spring Framework 中有多少个模块，它们分别是什么？Spring 核心容器 – 该层基本上是 Spring Framework 的核心。它包含以下模块： Spring Core Spring Bean SpEL (Spring Expression Language) Spring Context 数据访问/集成 – 该层提供与数据库交互的支持。它包含以下模块： JDBC (Java DataBase Connectivity) ORM (Object Relational Mapping) OXM (Object XML Mappers) JMS (Java Messaging Service) TransactionWeb – 该层提供了创建 Web 应用程序的支持。它包含以下模块： Web Web – Servlet Web – Socket Web – Portlet AOP – 该层支持面向切面编程 Instrumentation – 该层为类检测和类加载器实现提供支持。 Test – 该层为使用 JUnit 和 TestNG 进行测试提供支持。几个杂项模块: Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。 Aspects – 该模块为与 AspectJ 的集成提供支持。​​47、区分构造函数注入和 setter 注入。构造函数注入 setter 注入 没有部分注入 有部分注入 不会覆盖 setter 属性 会覆盖 setter 属性 任意修改都会创建一个新实例 任意修改不会创建一个新实例 适用于设置很多属性 适用于设置少量属性48、区分 BeanFactory 和 ApplicationContext。BeanFactory ApplicationContext 它使用懒加载 它使用即时加载 它使用语法显式提供资源对象 它自己创建和管理资源对象 不支持国际化 支持国际化 不支持基于依赖的注解 支持基于依赖的注解49、什么是编织（Weaving）？为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）50、使用 Spring 访问 Hibernate 的方法有哪些？我们可以通过两种方式使用 Spring 访问 Hibernate： 使用 Hibernate 模板和回调进行控制反转 扩展 HibernateDAOSupport 并应用 AOP 拦截器节点51.索引的优缺点，什么时候使用索引，什么时候不能使用索引（1）索引最大的好处是提高查询速度，（2）缺点是更新数据时效率低，因为要同时更新索引（3）对数据进行频繁查询进建立索引，如果要频繁更改数据不建议使用索引。52..InnoDB索引和MyISAM索引的区别：（1）一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。（2）二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。53.innodb引擎的4大特性插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)54.事物的4种隔离级别隔离级别 ①读未提交(RU) ②读已提交(RC) ③可重复读(RR) ④串行55.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景MYISAM 不支持事务，不支持外键，表锁，插入数据时，锁定整个表，查表总行数时，不需要全表扫描INNODB 支持事务，支持外键，行锁，查表总行数时，全表扫描56.多线程的实现方法分别是什么?同步的实现方法分别是什么?答：多线程有两种实现方法，分别是继承Thread类与实现Runnable。接口同步的实现方面有两种，分别是synchronized、wait与notify。57、数组有没有length()方法？String有没有length()方法？答：数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。58、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？答：接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。59、抽象类（abstract class）和接口（interface）的区别？答：抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。60.int和Integer有什么区别？答：Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。Java 为每个原始类型提供了包装类型：- 原始类型: boolean，char，byte，short，int，long，float，double- 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F14%2Fresult%E7%B1%BB%E5%9E%8B%E4%B8%BAredirectAction%E6%97%B6%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[layout: struts2title: result类型为redirectAction时的参数传递date: 2018-12-14 11:20:11tags: 分享 12345&lt;result name="success" type="redirectAction"&gt; &lt;param name="actionName"&gt;findDetailAll&lt;/param&gt; &lt;!-- 第一个bizClaimVoucher.id为findDetailAll Action中的属性,第二个bizClaimVoucher.id为当前Action的属性 --&gt; &lt;param name="bizClaimVoucher.id"&gt;$&#123;bizClaimVoucher.id&#125;&lt;/param&gt;&lt;/result&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot基本原理以及认识]]></title>
    <url>%2F2018%2F12%2F13%2FSpringBoot%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[简介 Spring Boot来简化Spring应用开发，去繁从简，基本上都是使用的Spring的技术栈，它就像maven配置了整合了所有的jar包，spring boot整合了所有的框架 j2EE笨重的开发，繁多的配置，低下的开发效率，复杂的部署流程，第三方技术集成难度大 解决 Spring全家桶时代Spring Boot &gt; J2EE一站式解决方案Spring Cloud &gt; 分布式整体解决方案 优点 快速创建独立运行的Spring项目以及主流框架的集成 使用嵌入式的servlet容器，应用不需要打成war包 starters自动依赖与版本控制 大量的自动配置，简化开发，也可修改默认值 无需配置xml，无代码生成，开箱即用 准生产环境的运行时应用监控 与云计算的天然集成 微服务 微服务是一种架构风格一个应用应该是一组小型服务，可以通过HTTP的方式来进行互通 单体应用：ALL IN ONE,所有东西写在一个里面,传统的web架构模式它也有它的优点，比如开发，测试简单，因为都是一个应用，不牵扯到多个应用的互联，部署也是easy，整个项目打成war包，直接扔在服务器中，不会给运维带来太大的困难但是他所带来的问题呢，也是能清楚的感觉到，牵一发而动全身，有可能因为我们的小小的修改，整个应用需要重新部署或运行，当然，更大的挑战是我们日益增长的软件需求 一个单体应用程序把它所有功能放在一个单一进程中，并且通过多个服务器上复制这个单体进行扩展 微服务架构提倡把每个功能元素放入一个独立的服务中，并且通过跨服务器分发这些服务进行扩展，只在需要时才复制,节省了调用资源，而且每个服务都是一个可替换，可独立升级的独立单元，微服务使用，部署和运维是相当不容易的 怎样面对一个大型分布式的应用Spring boot：可以快速构建一个应用Spring cloud：进行网状互联互调，应用分布式 环境准备 JDK 1.7：1.7及以上 Maven 3.6：3.3及以上 IDEA 2017 Spring Boot 1.5.9.RELEASE Spring框架使用经验，熟练使用Maven进行项目构建和依赖管理，熟练使用Eclipse或IDEA 配置Maven conf的settings.xml文件添加,这段告诉Maven，项目使用jdk1.8来编译可以使用 mvn -v 来查看自己jdk所对应的版本 12345678910111213&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 配置IDEA 进入setting设置，找到maven，设置本地maven仓库 创建Maven项目导入Spring boot相关依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建一个主程序(用来启动Spring-Boot应用)12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 编写相关的Controller,Service12345678910@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello()&#123; return "你好，樊可"; &#125;&#125; 然后直接运行主程序123456 . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ 不需要做过多的配置，什么包扫描，视图解析器，前端控制器。。。 探究 POM文件父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;/parent&gt; 它的父项目是 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt; &lt;/parent&gt; 他来真正管理Spring Boot应用里面的所有依赖版本 启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web:&nbsp;spring-boot-starter:spring-boot场景启动器;帮我们导入了web模块正常运行所依赖的组建Spring boot将所有功能场景都抽取出来，做成一个个的starters(启动器),只需要在项目中引入这些starter相关场景的所有依赖都会导入进来 主程序类1234567891011/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication：Spring Boot 应用标注在某个类上说明这个类是SpringBoot的主配置类,SpringBoot就应该运行这个类的Main方法来启动SpringBoot应用 12345678910111213141516@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; @Configuration：配置类上类标注这个注解 @EnableAutoConfiguration：开启自动配置功能,以前我们需要配置的东西，Spring Boot帮我们自动配置 @AutoConfigurationPackage：自动配置包 @Import({Registrar.class})：Spring的底层注解，给容器中导入一个组建，导入的组件由Registrar.class 将主配置(@SpringBootApplication所标注的类)的所在包以及所在下面的子包里面的所有组件扫描到Spring容器中]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[勿忘国耻吾辈自强]]></title>
    <url>%2F2018%2F12%2F13%2F%E5%8B%BF%E5%BF%98%E5%9B%BD%E8%80%BB%E5%90%BE%E8%BE%88%E8%87%AA%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现邮件发送]]></title>
    <url>%2F2018%2F12%2F13%2FJava%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%2F</url>
    <content type="text"><![CDATA[发送的邮箱的POP3/SMTP服务或IMAP/SMTP服务开启记住授权码 得到javax.mail.jar链接：https://github.com/javaee/javamail/releases jar包导入项目中（我的只是普通的Java项目） 测试方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package cn.mail.util;import java.util.Date;import java.util.Properties;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;public class Mail&#123; // 发件人的 邮箱 和 密码 //PS: 某些邮箱服务器为了增加邮箱本身密码的安全性，给 SMTP 客户端设置了独立密码（有的邮箱称为“授权码”）, 对于开启了独立密码的邮箱, 这里的邮箱密码必需使用这个独立密码（授权码）。 private static String myEmailAccount = "2911572013@qq.com"; private static String myEmailPsw = "bylvzvmhhsmedgaf";//yonyivmzpseddeae //QQSMTP服务器地址为:smtp.qq.com private static String myEmailSMTPHost = "smtp.qq.com"; //收件人邮箱 private static String receiveMailAccount = "1258846421@qq.com"; public static void main(String[] args) throws Exception&#123; // 1. 创建参数配置, 用于连接邮件服务器的参数配置(一般写在一个Properties文件里来读取，此处为了方便) Properties props = new Properties(); props.setProperty("mail.transport.protocol", "smtp");//使用协议(javaMail规范要求) props.setProperty("mail.smtp.host", myEmailSMTPHost);//发件人的邮箱的SMTP服务器地址 props.setProperty("mail.smtp.auth", "true");//需要请求认证 //2. 根据配置创建会话对象，用于和邮件服务器交互 Session session = Session.getInstance(props); session.setDebug(true);//设置为debug模式，可以查看详细的发送Log //3.创建一封邮件 MimeMessage message = createMimeMessage(session, myEmailAccount, receiveMailAccount); //4.根据Session获取邮件传输对象 Transport transport = session.getTransport(); // 5. 使用 邮箱账号 和 密码 连接邮件服务器, 这里认证的邮箱必须与 message 中的发件人邮箱一致, 否则报错 transport.connect(myEmailAccount, myEmailPsw); // 6. 发送邮件, 发到所有的收件地址, message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人 transport.sendMessage(message, message.getAllRecipients()); // 7. 关闭连接 transport.close(); &#125; /** * 创建一封只包含文本的简单邮件 * * @param session 和服务器交互的会话 * @param sendMail 发件人邮箱 * @param receiveMail 收件人邮箱 * @return * @throws Exception */ public static MimeMessage createMimeMessage(Session session, String sendMail, String receiveMail) throws Exception &#123; // 1. 创建一封邮件 MimeMessage message = new MimeMessage(session); // 2. From: 发件人（昵称有广告嫌疑，避免被邮件服务器误认为是滥发广告以至返回失败，请修改昵称） // InternetAddress(String address, String personal, String charset) 根据地址和名称来构建InternetAddress message.setFrom(new InternetAddress(sendMail, "嘻嘻嘻", "UTF-8")); // 3. To: 收件人（可以增加多个收件人、抄送、密送） message.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress(receiveMail, "(｡･∀･)ﾉﾞ嗨SIRI", "UTF-8")); // 4. Subject: 邮件主题（标题有广告嫌疑，避免被邮件服务器误认为是滥发广告以至返回失败，请修改标题） message.setSubject("恭喜", "UTF-8"); // 5. Content: 邮件正文（可以使用html标签）（内容有广告嫌疑，避免被邮件服务器误认为是滥发广告以至返回失败，请修改发送内容） message.setContent("尊敬的悲伤的橘子树:&lt;br/&gt; 当您看到这封邮箱时,现在时间为:"+new Date()+"，首先恭喜您已经做好了邮箱发送的功能，再接再厉!", "text/html;charset=utf-8"); // 6. 设置发件时间 message.setSentDate(new Date()); // 7. 保存设置 message.saveChanges(); return message;&#125;&#125; myEmailPsw并不是qq密码，POP3/SMTP服务或IMAP/SMTP服务开启的授权码]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2实现Ajax]]></title>
    <url>%2F2018%2F12%2F08%2FStruts2%E5%AE%9E%E7%8E%B0Ajax%2F</url>
    <content type="text"><![CDATA[Struts2框架下实现Ajax有两种方法，第一种是原生的方式，另外一种是使用Struts2自带的插件 其中js部分调用方式一致 1234567891011121314function testAjax() &#123; var $userNameInput = $("#ajax_username"); var userName = $userNameInput.val(); $.ajax(&#123; url : "originAjax.action", //请求地址 type : "GET", //请求方式 data : "ajaxField=" + userName, //传递的参数 success : function(data, textStatus) &#123; //返回成功函数 alert(data); &#125; &#125;);&#125; 使用stream类型的Result实现Ajax编写Action 定义一个InputStream类型的成员变量 给该变量添加getter和setter方法 执行业务操作，将响应数据赋给该成员变量 123456789101112131415161718192021private InputStream inputStream;public InputStream getInputStream() &#123; return inputStream; &#125;public void setInputStream(InputStream inputStream) &#123; this.inputStream = inputStream; &#125; /** * stream类型的result实现Ajax*/public String execute()&#123; try &#123; inputStream=new ByteArrayInputStream(likeName.getBytes("utf-8")); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return SUCCESS; &#125; 配置struts.xml 定于stream类型的result 使用&lt;param&gt;标签指定响应数据类型以及输出结果 123456&lt;action name="getStreamResult" class="cusAction"&gt; &lt;result name="success" type="stream"&gt; &lt;param name="contentType"&gt;text/html&lt;/param&gt; &lt;param name="inputName"&gt;inputStream&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; 使用JSON类型的Result实现Ajax 导入struts2-json-plugin-.jar struts.xml中定义package并继承json-default 指定result元素的type属性为json 12345678&lt;action name="getJsonResult" class="cusAction"&gt; &lt;result type="json"&gt; &lt;param name="root"&gt;likeName&lt;/param&gt; //基本设置 &lt;param name="includeProperties"&gt;user.name&lt;/param&gt; //设置包含的字段 &lt;param name="exclideProperties"&gt;user.password&lt;/param&gt; //设置不包含的字段 &lt;param name="excludeNullProperties"&gt;true&lt;/param&gt; //是否添加null、 &lt;/result&gt;&lt;/action&gt;]]></content>
      <categories>
        <category>SSH</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[没有光明的人,最是向往光明]]></title>
    <url>%2F2018%2F11%2F27%2F%E6%B2%A1%E6%9C%89%E5%85%89%E6%98%8E%E7%9A%84%E4%BA%BA-%E6%9C%80%E6%98%AF%E5%90%91%E5%BE%80%E5%85%89%E6%98%8E%2F</url>
    <content type="text"><![CDATA[这里死了太多的人，他们的痛苦使我成长。无知愚昧的孩童也只有知道痛苦后才能长大成人 你们应该证明你们是个大国,然而你们时恃是世界的主角 远离杀戮，其实只不过是追求和平的庸者 杀了人就会被人杀。憎恨会将这两者紧紧联系在一起。战争就是伴随着死亡伤痕痛苦 你和我有着相同的梦想，都希望实现和平。你和我没有任何区别，都是为了正义而活 我对你的村子实行的正义，和你试图击倒我的想法没有任何的区别。 失去真正重要的东西所带来的痛楚，对谁 来说都是一样，你和我都对这样的痛楚感同身受 感受痛苦吧，体验痛苦吧，接受痛苦吧，了解痛苦吧。不知道痛苦的人是不会知道什么是和平 – 佩恩]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天也是美好的一天]]></title>
    <url>%2F2018%2F11%2F27%2F%E4%BB%8A%E5%A4%A9%E4%B9%9F%E6%98%AF%E7%BE%8E%E5%A5%BD%E7%9A%84%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[独木舟 《我亦飘零久》 当我懂得了去爱太阳的光芒，爱麦子和稻谷的香味，爱任何一株路边的野草小花，爱炊烟袅袅升起的烟囱，以及不惧怕未来的时光中，岁月不经意涂抹在我面孔上的每一条皱纹时，我才真正懂得了如何爱这个世界。]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拦截器]]></title>
    <url>%2F2018%2F11%2F25%2F%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[为什么需要拦截器 早期mvc框架将一些通用操作硬编码在核心控制器中，使框架灵活性不足，可扩展性低 Struts2将核心功能放到多个拦截器中实现，拦截器可自由选择和组合，增强了灵活性，有利于系统的解耦 什么是拦截器 Struts2大多数核心功能是通过拦截器实现的，每个拦截器完成某项功能 拦截器方法在Action执行之前和之后执行 拦截器栈 从结构上看，拦截器相当于多个拦截器的组成 从功能上看，拦截器栈也是拦截器 拦截器与过滤器原理相似 拦截器工作原理三阶段执行周期 做一些Action执行前的预处理 将控制交给后续拦截器或返回字符串 做一些Action执行后的处理 拦截器简单应用 创建拦截器类继承AbstractInterceptor类，重写intercept()12345678910111213@Override public String intercept(ActionInvocation invocation) throws Exception &#123; //预处理工作 long startTime=System.currentTimeMillis(); System.out.println("当前时间"+startTime); //执行后续拦截器或action String tesult=invocation.invoke(); //后续处理工作 long endTime=System.currentTimeMillis(); System.out.println("耗时："+(endTime-startTime)); return tesult; &#125; struts.xml配置1234567891011121314151617181920&lt;interceptors&gt; &lt;!-- 定义单个拦截器 --&gt; &lt;interceptor name="myAuthorization" class="cn.ssh.interceptor.AuthorizationInterceptor"&gt;&lt;/interceptor&gt; &lt;!-- 定义拦截器栈 --&gt; &lt;interceptor-stack name="myStack"&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name="myAuthorization"&gt;&lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt; &lt;action name="indexs"&gt; &lt;result&gt;index.jsp&lt;/result&gt; &lt;!-- 引用拦截器栈--&gt; &lt;interceptor-ref name="myTimeStack"&gt;&lt;/interceptor-ref&gt; &lt;!-- 引用单个拦截器--&gt; &lt;interceptor-ref name="myTime"&gt;&lt;/interceptor-ref&gt; &lt;!-- 默认拦截器栈，必须--&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt;&lt;/action&gt; 设置默认拦截器12&lt;!-- 在这个包里所有action都会有myTimeStack --&gt;&lt;default-interceptor-ref name="myTimeStack"&gt;&lt;/default-interceptor-ref&gt; 自定义拦截器 实现Intercepror接口 void init()：初始化拦截器所需资源 void destroy()：释放在init()中分配的资源 String intercept(ActionInvocation ai) throws Exception 实现拦截器功能 利用ActionInvocation参数获取Action状态 返回结果码字符串 继承AbstractInterceptor类 提供了init()和destroy()方法的空实现 只需要实现intercept方法既可 权限验证拦截器 创建权限验证拦截器12345678910111213public class AuthorizationInterceptor extends AbstractInterceptor &#123; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; Object loginUser=invocation.getInvocationContext().getSession().get("loginUser"); if(loginUser==null)&#123; return "input"; &#125;else&#123; return invocation.invoke(); &#125; &#125;&#125; struts.xml123456789101112131415161718192021222324&lt;package name="renthouse" extends="struts-default" namespace="/mm"&gt; &lt;interceptors&gt; &lt;!-- 定义权限验证拦截器 --&gt; &lt;interceptor name="myAuthorization" class="cn.ssh.interceptor.AuthorizationInterceptor"&gt;&lt;/interceptor&gt; &lt;!-- 定义拦截器栈 --&gt; &lt;interceptor-stack name="myStack"&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name="myAuthorization"&gt;&lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;default-interceptor-ref name="myStack"&gt;&lt;/default-interceptor-ref&gt; &lt;action name="Logins" class="cn.ssh.action.LoginAction"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;result name="fail"&gt;/fail.jsp&lt;/result&gt; &lt;result name="input"&gt;/login.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="success"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;result name="input"&gt;/login.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 文件上传 Commons-FileUpload组件 使用简单：可以方便的嵌入到jsp文件，编写少量代码既可完成文件上传 能全程控制文件上传 能对上传文件的大小，类型进行控制 添加jar包 commons-collections-3.1.jarcommons-fileupload-1.3.1.jarcommons-io-2.2.jarcommons-lang3-3.1.jarcommons-logging-1.1.3.jar 设置表单提交属性12345上传文件&lt;br/&gt;&lt;s:form enctype="multipart/form-data" method="post" action="uploads.action"&gt; &lt;s:file name="upload"&gt;&lt;/s:file&gt; &lt;s:submit value="上传"&gt;&lt;/s:submit&gt;&lt;/s:form&gt; 编写处理上传的Action文件 private File upload;private String uploadContentType;private String uploadFileName; upload是提交属性name，绝对要一致 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private File upload; public File getUpload() &#123; return upload; &#125; public void setUpload(File upload) &#123; this.upload = upload; &#125; public String getUploadContentType() &#123; return uploadContentType; &#125; public void setUploadContentType(String uploadContentType) &#123; this.uploadContentType = uploadContentType; &#125; public String getUploadFileName() &#123; return uploadFileName; &#125; public void setUploadFileName(String uploadFileName) &#123; this.uploadFileName = uploadFileName; &#125; public String getSavePath() &#123; return savePath; &#125; public void setSavePath(String savePath) &#123; this.savePath = savePath; &#125; private String uploadContentType; private String uploadFileName; private String savePath; public String execute()&#123; try &#123; File destFile=new File(ServletActionContext.getRequest().getRealPath(savePath)+"\\"+this.getUploadFileName());; FileUtils.copyFile(upload, destFile); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return "success"; &#125; struts.xml处理1234567891011121314&lt;!-- 文件上传 --&gt; &lt;action name="upload" class="cn.ssh.action.UploadAction"&gt; &lt;!-- 给savePath手动赋值 --&gt; &lt;param name="savePath"&gt;/upload&lt;/param&gt; &lt;result name="success"&gt;/upload.jsp&lt;/result&gt; &lt;result name="input"&gt;/upload.jsp&lt;/result&gt; &lt;interceptor-ref name="fileUpload"&gt; &lt;!-- 设置文件大小 --&gt; &lt;param name="maximumSize"&gt;1024000&lt;/param&gt; &lt;!-- 设置文件类型 --&gt; &lt;param name="allowedTypes"&gt;image/jpeg,image/gif,image/png&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;/action&gt; 进行显示1&lt;img alt="" src="upload/&lt;s:property value='uploadFileName'/&gt;"&gt; 多文件上传 多个file控件，name属性相同 Action的修改，将三个属性的类型修改成数组 创建多文件上传Action1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class ManyUploadAction extends ActionSupport &#123; private File[] upload; private String[] uploadContentType; private String[] uploadFileName; private String savePath; public File[] getUpload() &#123; return upload; &#125; public void setUpload(File[] upload) &#123; this.upload = upload; &#125; public String[] getUploadContentType() &#123; return uploadContentType; &#125; public void setUploadContentType(String[] uploadContentType) &#123; this.uploadContentType = uploadContentType; &#125; public String[] getUploadFileName() &#123; return uploadFileName; &#125; public void setUploadFileName(String[] uploadFileName) &#123; this.uploadFileName = uploadFileName; &#125; public String getSavePath() &#123; return savePath; &#125; public void setSavePath(String savePath) &#123; this.savePath = savePath; &#125; public String execute()&#123; int i; for(i=0;i&lt;3;i++)&#123; File file=upload[i]; File destFile=new File(ServletActionContext.getRequest().getRealPath(savePath)+"\\"+uploadFileName[i]); try &#123; FileUtils.copyFile(file, destFile); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return "success"; &#125; struts.xml配置123456789101112&lt;!-- 多文件上传 --&gt; &lt;action name="uploads" class="cn.ssh.action.ManyUploadAction"&gt; &lt;!-- 给savePath手动赋值 --&gt; &lt;param name="savePath"&gt;/upload&lt;/param&gt; &lt;result name="success"&gt;/upload.jsp&lt;/result&gt; &lt;result name="input"&gt;/upload.jsp&lt;/result&gt; &lt;interceptor-ref name="fileUpload"&gt; &lt;param name="maximumSize"&gt;1024000&lt;/param&gt; &lt;param name="allowedTypes"&gt;image/jpeg,image/gif,image/png&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;/action&gt; 显示文件1234&lt;s:iterator value="uploadFileName"&gt; &lt;s:property/&gt; &lt;img alt="" src="upload/&lt;s:property/&gt;"&gt; &lt;/s:iterator&gt; 文件下载 Action 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class FileDownAction extends ActionSupport &#123; //读取下载文件的目录 private String inputPath; //下载文件的文件名 private String fileName; //读取下载文件的输入流 private InputStream inputStream; //下载文件的类型 private String conetntType; public String getInputPath() &#123; return inputPath; &#125; public void setInputPath(String inputPath) &#123; this.inputPath = inputPath; &#125; public String getFileName() &#123; return fileName; &#125; public void setFileName(String fileName) &#123; this.fileName = fileName; &#125; public InputStream getInputStream() throws FileNotFoundException &#123; String path=ServletActionContext.getServletContext().getRealPath(inputPath); InputStream in=ServletActionContext.getServletContext().getResourceAsStream(inputPath); System.out.println("--------"+in); return new BufferedInputStream(new FileInputStream(path+"\\"+fileName)); &#125; public void setInputStream(InputStream inputStream) &#123; this.inputStream = inputStream; &#125; public String getConetntType() &#123; return conetntType; &#125; public void setConetntType(String conetntType) &#123; this.conetntType = conetntType; &#125; public String execute()&#123; return "success"; &#125;&#125; struts.xml 1234567891011&lt;!-- 文件下载 --&gt; &lt;action name="downFile" class="cn.ssh.action.FileDownAction" method="execute"&gt; &lt;param name="inputPath"&gt;/upload&lt;/param&gt; &lt;result name="success" type="stream"&gt; &lt;param name="inputName"&gt;inputStream&lt;/param&gt; &lt;param name="contentType"&gt;application/octet-stream&lt;/param&gt; &lt;param name="contentDisposition"&gt;attachment;filename="$&#123;fileName&#125;&lt;/param&gt; &lt;param name="bufferSize"&gt;4096&lt;/param&gt; &lt;/result&gt; &lt;result name="input"&gt;/downld.jsp&lt;/result&gt; &lt;/action&gt; 下载页面 前提项目目录下必须拥有&lt;param name=”inputPath”&gt;/upload&lt;/param&gt;设置的路径以及相应的文件名1&lt;a href="downFile.action?fileName=obt.jpg"&gt;下载&lt;/a&gt;]]></content>
      <categories>
        <category>SSH</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OGNL]]></title>
    <url>%2F2018%2F11%2F24%2FOGNL%2F</url>
    <content type="text"><![CDATA[OGNL介绍开源项目，取代Java脚本，简化数据访问，和EL同属于表达式语言，但功能更强大 表达式语言：将表单或Struts2标签与特定的Java数据绑定起来，用来将数据移入，移除框架类型转换：数据进入和流出框架，在页面数据的字符转类型和Java数据类型之间进行转换 值栈：由struts2框架创建的存储区域，Action的实例会被存放在值栈中 OGNL访问值栈：按照从上到下的顺序，靠近栈顶的同名属性会被读取 类型转换数组 Action创建123456789101112private Double[] number;public Double[] getNumber() &#123; return number; &#125;public void setNumber(Double[] number) &#123; this.number = number; &#125; public String execute()&#123; return "success"; &#125; struts.xml配置1234&lt;action name="showArray" class="cn.ssh.action.ArrayDateTransferAction" method="execute"&gt; &lt;result&gt;/show.jsp&lt;/result&gt; &lt;result name="input"&gt;/show.jsp&lt;/result&gt;&lt;/action&gt; JSP页面（提交数组）1234567&lt;s:form action="/ognl/showArray.action" method="post"&gt; &lt;s:textfield name="number" label="number1"&gt;&lt;/s:textfield&gt; &lt;s:textfield name="number" label="number2"&gt;&lt;/s:textfield&gt; &lt;s:textfield name="number" label="number3"&gt;&lt;/s:textfield&gt; &lt;s:submit value="提交"&gt;&lt;/s:submit&gt; &lt;/s:form&gt; JSP页面（显示数组）123456显示数组 &lt;s:iterator value="number"&gt; &lt;s:property/&gt; &lt;/s:iterator&gt; &lt;s:property value="number[0]"/&gt; //按下标显示 &lt;s:property value="number.length"/&gt; //获取长度 集合 Action创建123456789101112private List&lt;String&gt; hobbies;public List&lt;String&gt; getHobbies() &#123; return hobbies; &#125;public void setHobbies(List&lt;String&gt; hobbies) &#123; this.hobbies = hobbies; &#125; public String execute()&#123; return "success"; &#125; struts.xml配置1234&lt;action name="showArray" class="cn.ssh.action.ArrayDateTransferAction" method="execute"&gt; &lt;result&gt;/show.jsp&lt;/result&gt; &lt;result name="input"&gt;/show.jsp&lt;/result&gt;&lt;/action&gt; JSP页面（提交集合）1234567&lt;s:form action="/ognl/showArray.action" method="post"&gt; &lt;s:textfield name="hobbies" label="爱好"&gt;&lt;/s:textfield&gt; &lt;s:textfield name="hobbies" label="爱好"&gt;&lt;/s:textfield&gt; &lt;s:textfield name="hobbies" label="爱好"&gt;&lt;/s:textfield&gt; &lt;s:submit value="提交"&gt;&lt;/s:submit&gt; &lt;/s:form&gt; JSP页面（显示集合）1234显示集合 &lt;s:iterator value="hobbies"&gt; &lt;s:property/&gt; &lt;/s:iterator&gt; 集合包装类型 Action创建123456789101112private List&lt;User&gt; users;public List&lt;User&gt; getUsers() &#123; return users; &#125;public void setUsers(List&lt;User&gt; users) &#123; this.users = users; &#125; public String execute()&#123; return "success"; &#125; struts.xml配置1234&lt;action name="showArray" class="cn.ssh.action.ArrayDateTransferAction" method="execute"&gt; &lt;result&gt;/show.jsp&lt;/result&gt; &lt;result name="input"&gt;/show.jsp&lt;/result&gt;&lt;/action&gt; JSP页面（提交集合包装类型）1234567&lt;s:form action="/ognl/showArray.action" method="post"&gt; &lt;s:textfield name="users[0].name" label="用户名1"&gt;&lt;/s:textfield&gt; &lt;s:textfield name="users[1].name" label="用户名2"&gt;&lt;/s:textfield&gt; &lt;s:textfield name="users[2].name" label="用户名3"&gt;&lt;/s:textfield&gt;&lt;/s:textfield&gt; &lt;s:submit value="提交"&gt;&lt;/s:submit&gt; &lt;/s:form&gt; JSP页面（显示集合包装类型）1234显示list User &lt;%-- 值栈的user对象 &lt;s:property value="#user.name"/&gt; --%&gt; &lt;s:iterator value="users" id="user"&gt; &lt;s:property value="name"/&gt; &lt;/s:iterator&gt; 日期类型 Action创建123456789101112private Date timeDate;public Date getTimeDate() &#123; return timeDate; &#125;public void setTimeDate(Date timeDate) &#123; this.timeDate = timeDate; &#125; public String execute()&#123; return "success"; &#125; struts.xml配置1234&lt;action name="showArray" class="cn.ssh.action.ArrayDateTransferAction" method="execute"&gt; &lt;result&gt;/show.jsp&lt;/result&gt; &lt;result name="input"&gt;/show.jsp&lt;/result&gt;&lt;/action&gt; JSP页面（提交日期类型）12345&lt;s:form action="/ognl/showArray.action" method="post"&gt; s:textfield name="timeDate" label="时间"&gt;&lt;/s:textfield&gt; &lt;s:submit value="提交"&gt;&lt;/s:submit&gt; &lt;/s:form&gt; JSP页面（显示日期类型）123显示时间 &lt;s:date name="timeDate" format="yyyy/MM/dd"/&gt; &lt;s:property value="timeDate"/&gt; 创建自定义类型转换器（时间类型） 创建 自定义转换类，继承StrutsTypeConverter类1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.ssh.converter;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Map;import org.apache.struts2.util.StrutsTypeConverter;import com.opensymphony.xwork2.conversion.TypeConversionException;public class DateConverter extends StrutsTypeConverter &#123; private final DateFormat[] dfs=&#123; new SimpleDateFormat("yyyy年MM月dd日"), new SimpleDateFormat("yyyy-MM-dd"), new SimpleDateFormat("MM/dd/yy"), new SimpleDateFormat("yyyy.MM.dd"), new SimpleDateFormat("yyyyMMdd"), new SimpleDateFormat("yyyy/MM/dd") &#125;; @Override public Object convertFromString(Map context, String[] values, Class toType) &#123; String dateStr=values[0]; for(DateFormat df: dfs)&#123; try &#123; return df.parse(dateStr); &#125; catch (ParseException e) &#123; continue; &#125; &#125; throw new TypeConversionException();//异常处理实现输出 &#125; //输出时按照yyyy-MM-dd格式 @Override public String convertToString(Map context, Object object) &#123; Date date=(Date)object; return new SimpleDateFormat("yyyy-MM-dd").format(date); &#125;&#125; 全局类型转换器 在src目录下创建 xwork-conversion.properties ，添加转换类全名=类型转换器类全名1java.util.Date=cn.ssh.converter.DateConverter 应用于特定类的类型转换器 在特定类的相同目录下创建一个className-conversion.properties的属性文件特定类的属性名=类型转换器类全名1timeDate=cn.ssh.converter.DateConverter 处理类型转换错误 向用户输出类型转换错误的前提条件 启动StrutsConversionErrorInterCeptor拦截器（拦截器已经包含在defaultStack拦截器栈中） Action要继承ActionSupport类 配置input结果映射 页面使用struts2表单标签或&it;s:fielderror标签 实现在struts.xml中指定资源文件的基名1&lt;constant name="struts.custom.i18n.resources" value="message"&gt;&lt;/constant&gt; 在src目录下创建资源文件message.properties并修改键值1234xwork.error.action.execution=Error during Action invocationxwork.exception.missing-action=There is no Action mapped for action name &#123;0&#125;.xwork.exception.missing-package-action=There is no Action mapped for namespace &#123;0&#125; and action name &#123;1&#125;.xwork.default.invalid.fieldvalue=\u5B57\u6BB5 "&#123;0&#125;"\u65E0\u6548. 制定特定字段的类型转换错误 在Action范围的资源文件中添加i18n消息键invalid.fieldvalue.字段名在Action包下创建Action名.properties,并指定键值1invalid.fieldvalue.timeDate=\u65E5\u671F\u8F6C\u6362\u9519\u88EF 需要把全局消息关闭 常用的OGNL访问操作访问JavaBean Bean的类型必须遵循JavaBean规范，必须具有无参构造setter/getter方法符合JavaBean规范 POJO(User类)1234567891011121314151617181920212223242526272829&gt;public class User &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public User()&#123;&#125; private Address address; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125;&#125;&gt; POJO(Address类)1234567891011121314151617181920212223242526272829303132333435public class Address &#123; private String country; private String city; private String street; public String getCountry() &#123; return country; &#125; public void setCountry(String country) &#123; this.country = country; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getStreet() &#123; return street; &#125; public void setStreet(String street) &#123; this.street = street; &#125; public Address()&#123;&#125;&#125; Action123456789101112131415161718192021222324252627282930313233private User user; private String message; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public String execute()&#123; user=new User(); user.setName("樊可"); user.setAge(18); Address address=new Address(); address.setCountry("中国"); address.setCity("永济"); address.setStreet("城西"); user.setAddress(address); this.message="展示原始类型和包装类型"; //解耦方式获取session Map&lt;String, Object&gt;session=null; session=ActionContext.getContext().getSession(); session.put("loginUser", "樊可"); return "success"; &#125; struts.xml123&lt;action name="showOAJ" class="cn.ssh.action.ShowOriginalAndJavaBeanAction" method="execute"&gt; &lt;result&gt;/show.jsp&lt;/result&gt;&lt;/action&gt; JSP页面显示123456789信息:&lt;s:property value="message"/&gt; 用户名:&lt;s:property value="user.name"/&gt; &lt;hr/&gt; 国家:&lt;s:property value="user.address.country"/&gt; &lt;hr/&gt; 城市:&lt;s:property value="user.address.city"/&gt; &lt;hr/&gt; 街道:&lt;s:property value="user.address.street"/&gt; &lt;hr/&gt; 访问集合对象 可以使用属性名[index]的方式访问，列表，数组 可以使用属性名[key]的方式访问,map对象 使用size或length获取集合长度 定义列表1234&lt;s:set name="userList" value="&#123;'樊可','李钰洋','憨八龟'&#125;"&gt;&lt;/s:set&gt;&lt;s:property value="#userList[1]"/&gt;&lt;s:property value="#userList.size"/&gt;&lt;hr/&gt; 定义map对象1234&lt;s:set name="maps" value="#&#123;'cn':'China','us':'United States'&#125;"/&gt;&lt;s:property value="#maps.cn"/&gt;&lt;s:property value="#maps['cn']"/&gt;&lt;hr/&gt; 使用struts标签取session1234//使用struts标签取session&lt;s:property value="#session.loginUser"/&gt;//普通方法$&#123;sessionScope.loginUser&#125; 使用OGNL访问ActionContext 值栈中内容可以直接访问，访问非值栈对象需要添加#前缀 非值栈对象 访问方式 等价访问方式 application #application.username#application[‘username’] application.getAttrbute(“username”) session #session.username#session[‘username’] session.getAttrbute(“username”) request #request.username#request[‘username’] request.getAttrbute(“username”) parameters #parameters.username#parameters[‘username’] request.getParameterValues(“username”) attr #attr.username#attr[‘username’] 按此顺序查找pageContext-&gt;request-&gt;session-&gt;application 栗子12345678910111213访问非值栈对象 &lt;s:set name="age" value="10" scope="request"/&gt; &lt;s:set name="username" value="'李钰洋'" scope="session"/&gt; &lt;s:set name="count" value="5" scope="application"/&gt; #request.age:&lt;s:property value="#request.age"/&gt;&lt;br/&gt; #session.username:&lt;s:property value="#session.username"/&gt;&lt;br/&gt; #application.count:&lt;s:property value="#application.count"/&gt;&lt;br/&gt; #arrt.count:&lt;s:property value="#attr.count"/&gt;&lt;br/&gt; &lt;s:set name="country1" value="China" /&gt; &lt;s:set name="country2" value="'China'" /&gt; #country1:&lt;s:property value="#country1"/&gt;&lt;br/&gt; #country2:&lt;s:property value="#country2"/&gt;&lt;br/&gt; #request.country2:&lt;s:property value="#request.country2"/&gt;&lt;br/&gt; 结果12345678访问非值栈对象 #request.age:10#session.username:李钰洋#application.count:5#arrt.count:5#country1:#country2:China#request.country2:China &lt;s:debug&gt;查看数据 ActionContext的组成 值栈 -ValueStack 非值栈-Stack Context 究竟是在访问值栈还是非值栈 iterator迭代规则 默认是迭代元素被压入值栈 使用id后元素成为非值栈对象 struts2标签的属性类型 对象类型属性值作为OGNL表达式进行计算123&lt;s:set name="myurl" value="'http://fankekeke.club'"/&gt;&lt;s:property value="#myurl"/&gt;//显示http://fankekeke.club 字符串类型属性值将直接输出，应使用%{…}再次计算，如url标签12345&lt;s:set name="myurl" value="'http://fankekeke.club'"/&gt;&lt;s:url value="#myurl"/&gt;//显示#myurl&lt;s:url value="%&#123;#myurl&#125;"/&gt;//显示http://fankekeke.club URL标签123&lt;s:url value="url"/&gt; &lt;s:param name="parname" value="parvalue"/&gt;&lt;/s:url&gt; value属性：表示生成url的地址 &lt;s:param/&gt;：表示需要传递的参数信息 name属性：表示传递的参数名称 value：表示传递参数的值]]></content>
      <categories>
        <category>SSH</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SSH框架搭建]]></title>
    <url>%2F2018%2F11%2F24%2FSSH%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[SSH架构 Struts2 + Spring + Hibernate以Spring作为框架核心，数据持久化使用Hibernate完成，表现层使用Struts2 Spring提供对象管理，面向切面等使用功能 通过Spring提供的服务简化编码，降低开发难度，提高开发效率 ssh框架搭建 添加所需的jar文件 在Spring中配置数据源和会话工厂 实现并配置dao 实现并配置service 为业务层添加事务管理 实现并配置action 创建jsp测试页面 pojo持久化类的映射 略 一个普通的log4j文件1234567891011121314151617181920212223242526272829303132333435363738## Log4J Settings for log4j 1.2.x (via jakarta-commons-logging)## The five logging levels used by Log are (in order):## 1. DEBUG (the least serious)# 2. INFO# 3. WARN# 4. ERROR# 5. FATAL (the most serious)# Set root logger level to WARN and append to stdoutlog4j.rootLogger=DEBUG, stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout# Pattern to output the caller's file name and line number.log4j.appender.stdout.layout.ConversionPattern=%d %5p (%c:%L) - %m%n# Print only messages of level ERROR or above in the package noModule.log4j.logger.noModule=FATALlog4j.logger.com.opensymphony.xwork2=ERRORlog4j.logger.org.apache.struts2=ERRORlog4j.logger.freemarker=ERROR### log HQL query parser activity#log4j.logger.org.hibernate.hql.ast.AST=debug### log just the SQL#log4j.logger.org.hibernate.SQL=debug### log JDBC bind parameters ####log4j.logger.org.hibernate.type=info#log4j.logger.org.hibernate.type=debuglog4j.logger.org.hibernate.type.descriptor.sql.BasicBinder=TRACE hibernate.cfg.xml 此文件可以在Spring文件中集中配置 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 数据库连接 --&gt; &lt;property name="connection.driver_class"&gt; oracle.jdbc.OracleDriver &lt;/property&gt; &lt;property name="connection.url"&gt; jdbc:oracle:thin:@localhost:1521:orcl &lt;/property&gt; &lt;property name="connection.username"&gt;martin&lt;/property&gt; &lt;property name="connection.password"&gt;mpwd&lt;/property&gt; &lt;!-- 辅助参数 --&gt; &lt;!-- &lt;property name="show_sql"&gt;true&lt;/property&gt; --&gt; &lt;property name="format_sql"&gt;true&lt;/property&gt; &lt;property name="dialect"&gt; org.hibernate.dialect.Oracle10gDialect &lt;/property&gt; &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt; &lt;!-- 映射信息 --&gt; &lt;mapping resource="cn/hate/pojo/CusCustomer.hbm.xml" /&gt; &lt;mapping resource="cn/hate/pojo/SaleOrderLine.hbm.xml" /&gt; &lt;mapping resource="cn/hate/pojo/SaleOrder.hbm.xml" /&gt; &lt;mapping resource="cn/hate/pojo/SaleProduct.hbm.xml" /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; Dao层 通过继承HibernateDaoSupport类来继续setter注入sessionFactory 使用Spring模板能简化编码过程，并不在依赖hibernate session，直接使用hibernate session 需要使用HibernateCallback接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package cn.hate.dao.impl;import java.io.Serializable;import java.sql.SQLException;import java.util.List;import org.hibernate.HibernateException;import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.Transaction;import org.springframework.orm.hibernate3.HibernateCallback;import org.springframework.orm.hibernate3.support.HibernateDaoSupport;import cn.hate.dao.commonDao;import cn.hate.pojo.SaleOrder;import cn.hate.pojo.SaleOrderLine;public class commonDaoImpl extends HibernateDaoSupport implements commonDao &#123; @Override /** * 根据主键获取一条数据 */ public Object get(Class clazz, Serializable id) &#123; Object ret=super.getHibernateTemplate().get(clazz, id); return ret; &#125; @Override /** * 添加数据 */ public Serializable add(Object o) &#123; Serializable ret = super.getHibernateTemplate().save(o); return ret; &#125; @Override /** * 删除数据 */ public void delete(Class clazz, Serializable id) &#123; super.getHibernateTemplate().delete(this.get(clazz, id)); &#125; @Override /** * 更新数据 */ public void update(Object o) &#123; super.getHibernateTemplate().update(o); &#125; @Override /** * 查找数据 */ public List find(String hql) &#123; List ret = super.getHibernateTemplate().find(hql); return ret; &#125; @Override /** * 分页查询 */ public List findFenYe(final int pageNo, final int pageSize) &#123; return this.getHibernateTemplate().execute(new HibernateCallback&lt;List&gt;() &#123; @Override public List doInHibernate(Session session) throws HibernateException, SQLException &#123; Query query=session.createQuery("select o from SaleOrder o"); query.setFirstResult((pageNo-1)*pageSize); query.setMaxResults(pageSize); return query.list(); &#125; &#125;); &#125; @Override public void addOrderLine(int id, SaleOrderLine saleOrderLine) &#123; SaleOrder saleOrder=(SaleOrder) this.get(SaleOrder.class, id); saleOrder.getSaleOrderLines().add(saleOrderLine); saleOrderLine.setSaleOrder(saleOrder); &#125;&#125; applicationContext.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt; &lt;!-- 扫描注解 --&gt; &lt;!-- &lt;context:component-scan base-package="cn.hate"&gt;&lt;/context:component-scan&gt; --&gt; &lt;!-- 由spring配置文件进行集中配置 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;!-- 数据库连接 --&gt; &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:oracle:thin:@localhost:1521:orcl"&gt;&lt;/property&gt; &lt;property name="username" value="martin"&gt;&lt;/property&gt; &lt;property name="password" value="mpwd"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义独立的hibernate配置文件，由Spring导入并创建会话工厂Bean --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt; &lt;!-- spring集中配置 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.Oracle10gDialect&lt;/prop&gt; &lt;prop key="show_sql"&gt;true&lt;/prop&gt; &lt;prop key="format_sql"&gt;true&lt;/prop&gt; &lt;prop key="javax.persistence.validation.mode"&gt;none&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name="mappingResources"&gt; &lt;list&gt; &lt;value&gt;cn/hate/pojo/CusCustomer.hbm.xml&lt;/value&gt; &lt;value&gt;cn/hate/pojo/SaleOrder.hbm.xml&lt;/value&gt; &lt;value&gt;cn/hate/pojo/SaleOrderLine.hbm.xml&lt;/value&gt; &lt;value&gt;cn/hate/pojo/SaleProduct.hbm.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 创建hibernate配置文件 --&gt; &lt;!-- &lt;property name="configLocation"&gt; &lt;value&gt; classpath:hibernate.cfg.xml &lt;/value&gt; &lt;/property&gt; --&gt; &lt;/bean&gt; &lt;!-- 注解 --&gt; &lt;!-- &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt; spring集中配置 &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.Oracle10gDialect&lt;/prop&gt; &lt;prop key="show_sql"&gt;true&lt;/prop&gt; &lt;prop key="format_sql"&gt;true&lt;/prop&gt; &lt;prop key="javax.persistence.validation.mode"&gt;none&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name="packagesToScan" value="cn.hate.pojo"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- commonDao --&gt; &lt;bean id="commonDao" class="cn.hate.dao.impl.commonDaoImpl"&gt; &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- orderService --&gt; &lt;bean id="orderService" class="cn.hate.service.impl.orderServiceImpl"&gt; &lt;property name="comDao" ref="commonDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- Action --&gt; &lt;bean id="cusAction" class="cn.hate.action.CusCustomerAction"&gt; &lt;property name="oService" ref="orderService"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务增强 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true" /&gt; &lt;tx:method name="add*" /&gt; &lt;tx:method name="update*" /&gt; &lt;tx:method name="delete*" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 定义切面 --&gt; &lt;aop:config&gt; &lt;!-- 定义切入点 --&gt; &lt;aop:pointcut expression="execution(* cn.hate.service..*.*(..))" id="serviceeMethod"/&gt; &lt;!-- 织入 --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="serviceeMethod"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; struts.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;!-- 设置action动态方法调用 --&gt; &lt;constant name="struts.enable.DynamicMethodInvocation" value="true" /&gt; &lt;!-- 启动开发模式 --&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;!-- 处理中文乱码 --&gt; &lt;constant name="struts.i18n.encoding" value="utf-8" /&gt; &lt;!-- 处理所有文件大小 --&gt; &lt;constant name="struts.multipart.maxSize" value="5000000" /&gt; &lt;package name="default" namespace="/" extends="struts-default"&gt; &lt;global-results&gt; &lt;result name="input"&gt;/error.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name="defaultAction"&gt; &lt;result&gt;/error.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 分页查询 --&gt; &lt;action name="orderList" class="cusAction" method="orderList"&gt; &lt;result name="success"&gt;/index.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 添加订单 --&gt; &lt;action name="addOrder" class="cusAction" method="addOrder"&gt; &lt;result name="success" type="redirectAction"&gt;orderList&lt;/result&gt; &lt;result name="input"&gt;/addOrder.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 添加订单明细 --&gt; &lt;action name="addOrderLines" class="cusAction" method="addOrderLines"&gt; &lt;result name="success" type="redirectAction"&gt;findOrderById&lt;/result&gt; &lt;result name="input"&gt;/addOrderLine.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 根据id查询订单 --&gt; &lt;action name="findOrderById" class="cusAction" method="findOrderById"&gt; &lt;result name="success"&gt;/addOrderLine.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 删除订单明细--&gt; &lt;action name="deleteOrderLine" class="cusAction" method="deleteOrderLine"&gt; &lt;result name="success" type="redirectAction"&gt;findOrderById&lt;/result&gt; &lt;/action&gt; &lt;!-- 模糊查询订单--&gt; &lt;action name="findOrderByLike" class="cusAction" method="findOrderByLike"&gt; &lt;result name="success"&gt;/index.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 查询所有用户--&gt; &lt;action name="findAllCust" class="cusAction" method="findAllCust"&gt; &lt;result name="success"&gt;/addOrder.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 查询所有商品--&gt; &lt;!-- &lt;action name="findAllPro" class="cusAction" method="findAllPro"&gt; &lt;result name="success"&gt;/addOrderLine.jsp&lt;/result&gt; &lt;/action&gt; --&gt; &lt;!-- Ajax --&gt; &lt;action name="getStreamResult" class="cusAction"&gt; &lt;result name="success" type="stream"&gt; &lt;param name="contentType"&gt;text/html&lt;/param&gt; &lt;param name="inputName"&gt;inputStream&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt;]]></content>
      <categories>
        <category>SSH</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Struts2配置详解]]></title>
    <url>%2F2018%2F11%2F22%2FStruts2%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[回忆用户登录过程 JSP页面请求👇核心控制器👇Action👇Result👇JSP页面显示 核心控制器 在web.xml中配置，对框架进行初始化，以及处理所有的请求 Action 业务控制器 创建Action,实现Action接口，继承ActionSupport类name属性不能重名，class属性为Action的路径 12345&lt;action name="Login" class="cn.ssh.LoginAction"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;result name="fail"&gt;/fail.jsp&lt;/result&gt; &lt;result name="input"&gt;/login.jsp&lt;/result&gt;&lt;/action&gt; Result 实现对结果的处理 实现对结果的调用result元素的值指定对应的实际资源位置name属性表示result的逻辑名，Action返回的字符串 Struts.xml constant元素，可以改变struts2框架的一些行为name表示常量名称，value表示常量值 12345&lt;!-- 处理中文乱码 --&gt;&lt;constant name="struts.i18n.encoding" value="UTF-8"&gt;&lt;/constant&gt; &lt;!-- 设置action动态方法调用 --&gt;&lt;constant name="struts.enable.DynamicMethodInvocation" value="true"&gt;&lt;/constant&gt; package元素 –简化维护工作，提高重用性包可以继承已定义的包name属性必须且唯一，用于指定包的名称extends属性指定要扩展的包，总是扩展struts-default包namespace属性定义该包action的命名空间，可选 配置Action Action,封装工作单元，数据转移的场所，返回结果字符串 method属性 属于action属性，默认值：execute，可以更改属性值实现Action中不同方法的调用 123456789101112131415161718192021 //登录 public String login()&#123; //return "success"; return "dologin"; &#125; //注册 public String register()&#123; //return "success"; return "doregister"; &#125; &lt;action name="login" class="cn.ssh.UserAction" method="login"&gt; &lt;result&gt;/login.jsp&lt;/result&gt; &lt;/action&gt;&lt;action name="register" class="cn.ssh.UserAction" method="register"&gt; &lt;result&gt;/register.jsp&lt;/result&gt; &lt;/action 配置默认action 没有Action匹配请求时，默认Action将被执行 1234567891011&lt;!-- 指定默认的action ，/user/a.action会跳转error --&gt;&lt;default-action-ref name="defaultAction"&gt;&lt;/default-action-ref&gt;&lt;!-- 全局结果 --&gt;&lt;global-results&gt; &lt;result name="error"&gt;/error.jsp&lt;/result&gt;&lt;/global-results&gt;&lt;!-- 省略class，直接使用ActionSupport类 --&gt;&lt;action name="defaultAction"&gt; &lt;result&gt;/error.jsp&lt;/result&gt;&lt;/action&gt; 简化Action的配置，调用方式 对于用一个action类的每一个方法都陪着了一次，造成action元素数量太多 动态方法调用 使用：actionName!methodName.action禁用：将属性Struts.enable.DynmicMethodInvocation设置为false 123456789&lt;!-- 设置action动态方法调用 --&gt;&lt;constant name="struts.enable.DynamicMethodInvocation" value="true"&gt;&lt;/constant&gt;&lt;!-- 简化action 动态方法调用 struts2-core-2.3.16.3.jar的default.properties设置 struts.enable.DynamicMethodInvocation = true --&gt; &lt;action name="user" class="cn.ssh.UserAction"&gt; &lt;result name="dologin"&gt;/login.jsp&lt;/result&gt; &lt;result name="doregister"&gt;/register.jsp&lt;/result&gt; &lt;!-- 调用 action name ! action方法name.action --&gt; &lt;/action&gt; 使用通配符 简化相同方法 123456789101112131415161718192021222324//添加用户 public String add()&#123; return "input"; &#125; //删除用户 public String delete()&#123; if(id.length()==0)&#123; this.message="删除失败"; return "input"; &#125;else&#123; this.message="删除成功"; System.out.println("删除-----"); return "success"; &#125; &#125;&lt;action name="*User" class="cn.ssh.UserAction" method="&#123;1&#125;"&gt; &lt;result name="input"&gt;/page/&#123;1&#125;.jsp&lt;/result&gt; &lt;result name="success" type="redirect"&gt;/page/&#123;1&#125;_success.jsp&lt;/result&gt; &lt;/action&gt; 调用：[你要输入的字符]User.action Result常用结果类型 dispatcher：默认结果类型，后台使用RequestDispatcher转发请求redirect：后台使用sendRedirect()将请求重定向至指定的urlredirectAction：主要用于重定向到action 动态结果 配置时不知道执行后结果是哪一个，运行时才知道哪个结果作为视图显示给用户 1234567891011121314151617181920212223private String nextDispose="";public String doLogin()&#123; System.out.println("判断-----"); if(isManager())&#123; nextDispose="manager"; &#125;else&#123; nextDispose="common"; &#125; return "success"; &#125; &lt;action name="doLogins" class="cn.ssh.UserAction" method="doLogin"&gt; &lt;result type="redirectAction"&gt;$&#123;nextDispose&#125;&lt;/result&gt; &lt;result name="error"&gt;.page/error.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="manager"&gt; &lt;result&gt;/page/manager.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="common"&gt; &lt;result&gt;/page/common.jsp&lt;/result&gt; &lt;/action&gt; 全局结果 实现同一个包中多个action共享一个结果如果返回error，但是action并没有配置，会去找global-results 1234&lt;!-- 全局结果 --&gt; &lt;global-results&gt; &lt;result name="error"&gt;/error.jsp&lt;/result&gt; &lt;/global-results&gt;]]></content>
      <categories>
        <category>SSH</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Struts2入门]]></title>
    <url>%2F2018%2F11%2F21%2FStruts2%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Struts2的前身是Opensymphony的Webwork2，实际上Strut和Webwork2合并后形成Struts2 Struts2的优势 1.实现mvc模式，层次结构清晰，是开发者专注业务逻辑实现2.丰富的标签库提高开发效率3.基于aop思想的拦截器机制降低业务见的耦合4.通过配置文件既可掌握系统间各部分的关系5.更方便的异常处理机制6.高扩展性 配置Struts2环境jar包 asm-3.3.jarasm-commons-3.3.jarasm-tree-3.3.jarcommons-fileupload-1.3.1.jarcommons-io-2.2.jarcommons-lang3-3.1.jarcommons-logging-1.1.3.jarfreemarker-2.3.19.jarjavassist-3.11.0.GA.jarlog4j-1.2.17.jarognl-3.0.6.jarstruts2-core-2.3.16.3.jarxwork-core-2.3.16.3.jar web.xml配置 这个文件为每个web应用程序提供接入点。在部署描述符（web.xml）中，Struts2 应用程序的接入点将会定义为一个过滤器。因此我们将在web.xml里定义一个FilterDispatcher类的接入点 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app id="WebApp_9" version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt; &lt;display-name&gt;Struts Blank&lt;/display-name&gt; &lt;!-- 过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;!-- 将全部请求定位到指定的Struts2过滤器中--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 我们将Struts2 过滤器映射到 / ，而不是 /.action ，这意味着所有的url都会被Struts过滤器解析 在src目录下创建Struts2核心文件(struts.xml) struts.xml文件包含有随着Actions的开发你将要修改的配置信息。它可用于覆盖应用程序的默认设置这个文件可在WEB-INF/classes文件夹下创建1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;!-- 处理中文乱码 --&gt; &lt;constant name="struts.i18n.encoding" value="UTF-8"&gt;&lt;/constant&gt; &lt;!-- 创建一个default包，继承struts2的struts-default namespace为 action指定了一个访问路径的前缀--&gt; &lt;package name="default" namespace="/" extends="struts-default"&gt; &lt;!-- 接收HelloWorldAction的请求,helloWorld对应form表单--&gt; &lt;action name="helloWorld" class="cn.ssh.HelloWorldAction"&gt; &lt;result name="success"&gt;/helloWorld.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- result的name对应action返回的字符串，可以有多个result 对应视图--&gt; &lt;action name="Login" class="cn.ssh.LoginAction"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; //成功返回 &lt;result name="fail"&gt;/fail.jsp&lt;/result&gt; //失败返回 &lt;result name="input"&gt;/login.jsp&lt;/result&gt; //其他返回 &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 属性 描述 name（必需） 为package的唯一标识 extends 指定package继承另一package的所有配置。通常情况下，我们使用struts-default作为package的基础。 abstract 定义package为抽象的。如果标记为true，则package不能被最终用户使用。 namespace Actions的唯一命名空间 创建Action文件1234567891011121314package cn.ssh;import com.opensymphony.xwork2.ActionSupport;public class HelloWorld extends ActionSupport &#123; private String message; private String name; @Override public String execute() throws Exception &#123; message = "Hello World,Struts2"; return SUCCESS; &#125; public String getMessage()&#123; return message; &#125;&#125; 创建.jsp文件1234567891011121314151617&lt;%@ page contentType="text/html;charset=UTF-8" %&gt;&lt;!-- 引用Struts2的标签库--&gt;&lt;%@ taglib prefix="s" uri="/struts-tags" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;s:property value="message"/&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 输出显示语句：&lt;s:property value="message"/&gt; 来自action的属性 helloWorld为 &lt;package&gt; namespace="/" action为helloWorld，.action默认，name=“name”来自action的属性 &lt;form action="helloWorld.action" method="post"&gt; 请输入您的名字:&lt;input type="text" name="name"&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; Struts2的执行流程 1.P helloWorld.action发送请求2.web.xml进行过滤3.在srruts.xml 中找到相对的action4.找到helloWorldAction5.helloWorldAction返回字符串到struts.xml 进行Result跳转 Struts2登录过程分析创建 LoginAction12345678....public String execute() throws Exception &#123; if(name.equals("憨八龟")&amp;&amp;password.equals("123456"))&#123; return "success"; &#125;else&#123; return "fail"; &#125; &#125; struts.xml 进行Result返回视图 1234567891011&lt;package name="default" namespace="/" extends="struts-default"&gt; &lt;action name="helloWorld" class="cn.ssh.HelloWorldAction"&gt; &lt;result name="success"&gt;/helloWorld.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="Login" class="cn.ssh.LoginAction"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;result name="fail"&gt;/fail.jsp&lt;/result&gt; &lt;result name="input"&gt;/login.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; JSP login.jsp12345&lt;form action="Login.action" method="post"&gt; 请输入您的名字:&lt;input type="text" name="name"&gt; 请输入您的密码:&lt;input type="password" name="password"&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; Struts2访问Servlet API解耦方式访问 提供了三个map对象访问，request，session和application在通过ActionContext类获取这三个map对象 object get(“request”)map getSession()map getApplication() 1234//解耦方式获取session,key/value方式存储Map&lt;String, Object&gt;session=null;session=ActionContext.getContext().getSession();session.put("current_user", name); JSP显示session信息 1$&#123;sessionScope.current_user &#125; //获取key值 与Servlet耦合的访问 通过ServletActionContext类获取Servlet API对象 1234//耦合方式获取sessionHttpSession ssion=null;session=ServletActionContext.getRequest().getSession();session.setAttribute("current_user", name); 建议使用ActionContext类解耦和的方式，因为所有一次请求的数据都包括在ActionContext类 Struts数据校验 通过在服务器端校验可防止用户绕过客户端脚本验证 ctionSupport类,不仅对Action接口进行了简单实现，同时增加了数据校验，本地化等支持 12345678910@Override public void validate() &#123; if(name.length()==0)&#123; this.addFieldError("name", "姓名不能为空"); &#125; if(password.length()==0)&#123; this.addFieldError("password", "密码不能为空"); &#125; //如果发现错误,会返回”input“，否则继续执行后续方法 &#125; 将校验错误信息输出在页面 使用Struts2提供的标签fielderror只针对字段actionerror针对当前的action12&lt;s:fielderror fieldName="name"/&gt;&lt;s:fielderror fieldName="password"/&gt; Struts2 UI标签表单标签 与ognl表达式结合使用发挥最大实力 标签 说明 &lt;s:form&gt;…&lt;/s:form&gt; 表单标签 &lt;s:textfield&gt;…&lt;/s: textfield&gt; 输入框 &lt;s:password&gt;…&lt;/s: password &gt; 密码输入框 &lt;s:textarea&gt;…&lt;/s: textarea &gt; 文本域输入框 &lt;s:radio&gt;…&lt;/s: radio &gt; 单选按钮 &lt;s:checkbox&gt;…&lt;/s: checkbox &gt; 多选框 &lt;s:submit/&gt; 提交标签 &lt;s:reset/&gt; 重置标签 &lt;s:hidden/&gt; 隐藏域标签 12345&lt;s:form action="Login.action" method="post"&gt; &lt;s:textfield name="name" value="" label="用户名"&gt;&lt;/s:textfield&gt; &lt;s:password name="password" value="" label="密码"&gt;&lt;/s:password&gt; &lt;s:submit value="登录"&gt;&lt;/s:submit&gt; &lt;/s:form&gt; label属性更简洁，方便 非表单标签 标签 说明 &lt;s:actionerror/s:actionerror&gt; 显示action错误 &lt;s:actionmessage&gt;…&lt;/s: actionmessage&gt; 显示error消息 &lt;s:fielderror&gt;…&lt;/s: fielderror &gt; 显示字段错误 Struts2通用标签 控制标签 名称 标签 说明 条件标签 &lt;s:if&gt;&lt;/s:if&gt; 根据表达式的值判断执行的内容 条件标签 &lt;s:elseif&gt;&lt;/s:elseif&gt; 根据表达式的值判断执行的内容 条件标签 &lt;s:else&gt;&lt;/s:else&gt; 根据表达式的值判断执行的内容 循环标签 &lt;s:iterator&gt;&lt;/s:iterator&gt; 用于便利集合 123456&lt;input type="radio" name="sex" value="1"&gt;男&lt;input type="radio" name="sex" value="0"&gt;女&lt;s:if test="sex==1"&gt;男人&lt;/s:if&gt;&lt;s:elseif test="sex==0"&gt;女人&lt;/s:elseif&gt;&lt;s:else&gt;!&lt;/s:else&gt; 1234567891011121314151617181920private List&lt;String&gt;users=new ArrayList&lt;String&gt;();users.add("樊可");users.add("李钰洋");users.add("fankekeke");//value属性：进行遍历的集合对象//status属性：当前循环元素的IteratorStatus实例//id属性：当前循环元素的id，可直接访问元素&lt;s:iterator value="users" status="st" id="user"&gt;&lt;s:property value="user"/&gt;&lt;br/&gt;&lt;/s:iterator&gt;&lt;s:iterator value="users" status="st"&gt;&lt;s:property/&gt;&lt;br/&gt;&lt;/s:iterator&gt;&lt;s:iterator value="userList" status="user"&gt;姓名：&lt;s:property value="user.userName" /&gt;年龄：&lt;s:property value="user.age" /&gt;&lt;/s:iterator&gt; 用的数据标签 标签 说明 action标签： 于在视图页面跳转到一个Action bean标签： 用于创建一个Javabean实例，按需保存到context中 date标签： 用于格式化输出一个日期 debug标签： 用于调试查看ognl上下文中内容 include标签： 用于包含其他的jsp或者servlet页面资源 param标签： 主要配合别的标签作为子标签使用 push标签： 用于将某个值放入到root栈顶 set标签： 设置一个新变量，放入指定范围 url标签： 用于生成一个URL地址]]></content>
      <categories>
        <category>SSH</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HQL连接查询和注解]]></title>
    <url>%2F2018%2F11%2F19%2FHQL%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[HQL连接查询类型内连接 INNER JOIN 关键字表示内连接, 也可以省略 INNER 关键字 list() 方法的集合中存放的每个元素对应查询结果的一条记录, 每个元素都是对象数组类型， 如果希望 list() 方法的返回的集合仅包含 Department 对象, 可以在 HQL 查询语句中使用 SELECT 关键字 123456789101112131415161718public void testInnerJoin()&#123; Transaction tx = null; try &#123; Session session=HibernateUtil.currentSession(); tx=session.beginTransaction(); String hql = "from Depts d join d.emps"; //d.emps为Depts表中的emps属性 List&lt;Object[]&gt; result=session.createQuery(hql).list(); for (Object[] object : result) &#123; System.out.println(((Depts)object[0]).getDeptName()); System.out.println("\t"+((Emps)object[1]).getUserName()); &#125; tx.commit(); &#125; catch (Exception e) &#123; if(tx!=null)&#123; tx.rollback(); &#125; &#125; &#125; 左外连接123456789101112131415161718public void testLeftJoin()&#123; Transaction tx = null; try &#123; Session session=HibernateUtil.currentSession(); tx=session.beginTransaction(); String hql = "from Depts d left join d.emps"; //from Emps e left join e.depts List&lt;Object[]&gt; result=session.createQuery(hql).list(); for (Object[] object : result) &#123; System.out.println(((Depts)object[0]).getDeptName()); System.out.println("\t"+((Emps)object[1]).getUserName()); &#125; tx.commit(); &#125; catch (Exception e) &#123; if(tx!=null)&#123; tx.rollback(); &#125; &#125; &#125; 迫切连接迫切连接必须用属性接受 INNER JOIN FETCH 关键字表示迫切内连接, 也可以省略 INNER 关键字list() 方法返回的集合中存放Department对象的引用, 每个Department对象的 Employee 集合都被初始化, 存放所有关联的 Employee 对象LEFT JOIN FETCH 关键字表示迫切左外连接检索策略. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 迫切左连接和迫切内连接，封装为最左边的属性，已经建立了关系 * 普通连接和迫切连接的区别：关联属性的初始化状态 */ @Test public void testLeftJoinFetch()&#123; Transaction tx = null; try &#123; Session session=HibernateUtil.currentSession(); tx=session.beginTransaction(); String hql = "from Depts d left join fetch d.emps"; List&lt;Depts&gt; result=session.createQuery(hql).list(); for (Depts depts : result) &#123; System.out.println(depts.getDeptName()); for (Emps emps : depts.getEmps()) &#123; System.out.println("\t"+emps.getUserName()); &#125; &#125; tx.commit(); &#125; catch (Exception e) &#123; if(tx!=null)&#123; tx.rollback(); &#125; &#125; &#125; @Test public void testLeftJoinFetch1()&#123; Transaction tx = null; try &#123; Session session=HibernateUtil.currentSession(); tx=session.beginTransaction(); String hql = "from Emps e left join fetch e.depts"; List&lt;Emps&gt; result=session.createQuery(hql).list(); for (Emps emps : result) &#123; System.out.println(emps.getUserName()); System.out.println("\t"+emps.getDepts().getDeptName()); &#125; tx.commit(); &#125; catch (Exception e) &#123; if(tx!=null)&#123; tx.rollback(); &#125; &#125; &#125; 等值连接(和普通内连接差不多)12345678910111213141516171819@Test public void testLeftJoinFetch2()&#123; Transaction tx = null; try &#123; Session session=HibernateUtil.currentSession(); tx=session.beginTransaction(); String hql = "from Depts d,Emps e where d=e.depts"; List&lt;Object[]&gt; result=session.createQuery(hql).list(); for (Object[] object : result) &#123; System.out.println(((Depts)object[0]).getDeptName()); System.out.println("\t"+((Emps)object[1]).getUserName()); &#125; tx.commit(); &#125; catch (Exception e) &#123; if(tx!=null)&#123; tx.rollback(); &#125; &#125; &#125; 隐式内连接12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 隐式内连接 * from Emp e where e.depts.deptName='' --用于where子句 * select empNo,empName,depts.deptName from Emps --用于select子句 * 根据关联关系自动使用等值连接，直接已对象的方式考虑条件 */ @Test public void testLeftJoinFetch3()&#123; Transaction tx = null; try &#123; Session session=HibernateUtil.currentSession(); tx=session.beginTransaction(); String hql = "from Emps e where e.depts.deptNo=1"; List result=session.createQuery(hql).list(); for (Object object : result) &#123; System.out.println(((Emps)object).getUserName()+"\t"+((Emps)object).getDepts().getDeptName()); &#125; tx.commit(); &#125; catch (Exception e) &#123; if(tx!=null)&#123; tx.rollback(); &#125; &#125; &#125; /** * 隐式内链接 select */ @Test public void testLeftJoinFetch4()&#123; Transaction tx = null; try &#123; Session session=HibernateUtil.currentSession(); tx=session.beginTransaction(); String hql = "select userId,userName,depts.deptName from Emps"; List&lt;Object[]&gt; result=session.createQuery(hql).list(); for (Object[] object : result) &#123; System.out.println(object[0]+"\t"+object[1]+"\t"+object[2]); &#125; tx.commit(); &#125; catch (Exception e) &#123; if(tx!=null)&#123; tx.rollback(); &#125; &#125; &#125; 聚合函数 count(),avg(),max(),min()1234567891011121314151617181920212223242526/** * hql聚合函数 count(),avg(),max(),min() */ @Test public void testLeftJoinFetch5()&#123; Transaction tx = null; try &#123; Session session=HibernateUtil.currentSession(); tx=session.beginTransaction(); /*String hql = "select count(userId),e.deptId from Emps e group by e.deptId";*/ /*String hql = "select max(userId),min(userId) from Emps"; */ /*String hql = "select max(userId),min(userId),e.deptNo from Emps e group by e.deptNo"; */ /*String hql = "select max(e.userId),d.deptName from Emps e,Depts d where e.depts=d group by d.deptName";*/ /*String hql = "select max(e.userId),depts.deptName from Emps e group by depts.deptName";*/ String hql = "select max(e.userId),depts.deptName from Emps e group by depts.deptName having depts.deptName='暗-部'"; List&lt;Object[]&gt; list=session.createQuery(hql).list(); for (Object[] objects : list) &#123; System.out.println(objects[0]+"\t"+objects[1]); &#125; tx.commit(); &#125; catch (Exception e) &#123; if(tx!=null)&#123; tx.rollback(); &#125; &#125; &#125; 子查询 如果子查询返回多条记录，则可以使用下面关键字： all:表示子查询语句返回的所有记录 any:表示子查询语句返回的任意一条结果 some:与”any”等价 in:与”=any”等价 exists:表示子查询语句至少返回一条记录 123456789101112131415161718192021222324252627282930/** * 子查询 */ @Test public void testLeftJoinFetch6()&#123; Transaction tx = null; try &#123; Session session=HibernateUtil.currentSession(); tx=session.beginTransaction(); /*String hql = "select userId,userName,depts.deptName from Emps where userId &lt; (select max(userId) from Emps)"; */ //any 任意一条 /*String hql = "select d.deptNo,d.deptName from Depts d where 5 &gt; any(select userId from Emps e where e.depts=d)";*/ //all 全部 /*String hql = "select d.deptNo,d.deptName from Depts d where 5 &gt; all(select userId from Emps e where e.depts=d)";*/ //in /*String hql = "select d.deptNo,d.deptName from Depts d where 5 in(select userId from Emps e where e.depts=d)";*/ //size() 或.size String hql = "select d.deptNo,d.deptName from Depts d where 5 &gt; all(select userId from Emps e where e.depts=d) and size(d.emps)&gt;0"; List&lt;Object[]&gt; result=session.createQuery(hql).list(); for (Object[] object : result) &#123; System.out.println(object[0]+"\t"+object[1]+"\t"); &#125; tx.commit(); &#125; catch (Exception e) &#123; if(tx!=null)&#123; tx.rollback(); &#125; &#125; &#125; 操作集合的函数属性或属性 size()或size:获取集合中的元素数目。minIndex()或minIndex:对于建立索引的集合，获取最小的索引maxIndex()或maxIndex:对于建立索引的集合，获取最大的索引。minElement()或minElement:对于包含基本类型的元素集合，获得集合中取值最小的元素。maxElement()或maxElement: 对于包含基本类型的元素集合，获得集合中取值最大的元素。Elements();获取集合中的所有元素。1String hql = "select d.deptNo,d.deptName from Depts d where 5 &gt; all(select userId from Emps e where e.depts=d) and size(d.emps)&gt;0"; 查询性能优化 hibernate查询优化策略（1.）使用迫切左外连接，或迫切连接查询策略，配置二级缓存和查询等方式，减少select语句数目，降低访问数据库的频率。（2.）使用延迟加载等方式避免加载多余不需要访问的数据。（3.）使用Query接口的iterate（）方法减少select语句的字段，降低访问数据库的数据量，并结合缓存等机制减少数据库的访问次数，提高查询效率。 HQL优化（1.）避免使用or操作的不当。（2.）避免使用not。（3.）避免使用like的特殊形式。（4.）避免使用having子句。（5.）避免使用distinct。（6.）索引在以下情况下失效，使用时注意。 对字段使用函数，该字段的索引将不起作用。如：substring（aa,1,2）=’xxx’ 对字段进行计算，该字段的索引将不起作用。如：price+10。 hibernate注解单对象操作 1234567891011121314151617181920212223242526272829303132@Entity ---&gt; 如果我们当前这个bean要设置成实体对象，就需要加上Entity这个注解@Table(name="t_user") ----&gt; 设置数据库的表名public class User&#123; private int id; private String username; private String password; private Date born; private Date registerDate; @Column(name="register_date") ---&gt; Column中的name属性对应了数据库的该字段名字，里面还有其他属性，例如length，nullable等等 public Date getRegisterDate() &#123; return registerDate; &#125; public void setRegisterDate(Date registerDate) &#123; this.registerDate = registerDate; &#125; @Id ---&gt; 定义为数据库的主键ID (建议不要在属性上引入注解，因为属性是private的，如果引入注解会破坏其封装特性，所以建议在getter方法上加入注解) @GeneratedValue ----&gt; ID的生成策略为自动生成 public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; ............&#125; 一对多的映射(one-to-many) ClassRoom类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Entity@Table(name="t_classroom")public class ClassRoom&#123; private int id; private String className; private Set&lt;Student&gt; students; public ClassRoom() &#123; students = new HashSet&lt;Student&gt;(); &#125; public void addStudent(Student student) &#123; students.add(student); &#125; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getClassName() &#123; return className; &#125; public void setClassName(String className) &#123; this.className = className; &#125; @OneToMany(mappedBy="room") ---&gt; OneToMany指定了一对多的关系，mappedBy="room"指定了由多的那一方来维护关联关系，mappedBy指的是多的一方对1的这一方的依赖的属性，(注意：如果没有指定由谁来维护关联关系，则系统会给我们创建一张中间表) @LazyCollection(LazyCollectionOption.EXTRA) ---&gt; LazyCollection属性设置成EXTRA指定了当如果查询数据的个数时候，只会发出一条 count(*)的语句，提高性能 public Set&lt;Student&gt; getStudents() &#123; return students; &#125; public void setStudents(Set&lt;Student&gt; students) &#123; this.students = students; &#125; &#125; Student类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Entity@Table(name="t_student")public class Student&#123; private int id; private String name; private int age; private ClassRoom room; @ManyToOne(fetch=FetchType.LAZY) ---&gt; ManyToOne指定了多对一的关系，fetch=FetchType.LAZY属性表示在多的那一方通过延迟加载的方式加载对象(默认不是延迟加载) @JoinColumn(name="rid") ---&gt; 通过 JoinColumn 的name属性指定了外键的名称 rid (注意：如果我们不通过JoinColum来指定外键的名称，系统会给我们声明一个名称) public ClassRoom getRoom() &#123; return room; &#125; public void setRoom(ClassRoom room) &#123; this.room = room; &#125; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 一对一映射(One-to-One)一对一关系这里定义了一个Person对象以及一个IDCard对象 Person类 12345678910111213141516171819202122232425262728293031323334353637@Entity@Table(name="t_person")public class Person&#123; private int id; private String name; private IDCard card; @OneToOne(mappedBy="person") ---&gt; 指定了OneToOne的关联关系，mappedBy同样指定由对方来进行维护关联关系 public IDCard getCard() &#123; return card; &#125; public void setCard(IDCard card) &#123; this.card = card; &#125; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; IDCard类 12345678910111213141516171819202122232425262728293031323334353637@Entity@Table(name="t_id_card")public class IDCard&#123; private int id; private String no; private Person person; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getNo() &#123; return no; &#125; public void setNo(String no) &#123; this.no = no; &#125; @OneToOne ---&gt; OnetoOne指定了一对一的关联关系，一对一中随便指定一方来维护映射关系，这里选择IDCard来进行维护 @JoinColumn(name="pid") ---&gt; 指定外键的名字 pid public Person getPerson() &#123; return person; &#125; public void setPerson(Person person) &#123; this.person = person; &#125;&#125; 在判断到底是谁维护关联关系时，可以通过查看外键，哪个实体类定义了外键，哪个类就负责维护关联关系。 Many-to-Many映射(多对多映射关系)通过中间表由任一一个多的一方来维护关联关系 Teacher 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Entity@Table(name="t_teacher")public class Teacher&#123; private int id; private String name; private Set&lt;Course&gt; courses; public Teacher() &#123; courses = new HashSet&lt;Course&gt;(); &#125; public void addCourse(Course course) &#123; courses.add(course); &#125; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @ManyToMany(mappedBy="teachers") ---&gt; 表示由Course那一方来进行维护 public Set&lt;Course&gt; getCourses() &#123; return courses; &#125; public void setCourses(Set&lt;Course&gt; courses) &#123; this.courses = courses; &#125; &#125; Course类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Entity@Table(name="t_course")public class Course&#123; private int id; private String name; private Set&lt;Teacher&gt; teachers; public Course() &#123; teachers = new HashSet&lt;Teacher&gt;(); &#125; public void addTeacher(Teacher teacher) &#123; teachers.add(teacher); &#125; @ManyToMany ---&gt; ManyToMany指定多对多的关联关系 @JoinTable(name="t_teacher_course", joinColumns=&#123; @JoinColumn(name="cid")&#125;, inverseJoinColumns=&#123; @JoinColumn(name = "tid") &#125;) ---&gt; 因为多对多之间会通过一张中间表来维护两表直接的关系，所以通过 JoinTable 这个注解来声明，name就是指定了中间表的名字，JoinColumns是一个 @JoinColumn类型的数组，表示的是我这方在对方中的外键名称，我方是Course，所以在对方外键的名称就是 rid，inverseJoinColumns也是一个 @JoinColumn类型的数组，表示的是对方在我这放中的外键名称，对方是Teacher，所以在我方外键的名称就是 tid public Set&lt;Teacher&gt; getTeachers() &#123; return teachers; &#125; public void setTeachers(Set&lt;Teacher&gt; teachers) &#123; this.teachers = teachers; &#125; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 通过hibernate来进行插入操作的时候，不管是一对多、一对一还是多对多，都只需要记住一点，在哪个实体类声明了外键，就由哪个类来维护关系，在保存数据时，总是先保存的是没有维护关联关系的那一方的数据，后保存维护了关联关系的那一方的数据]]></content>
      <categories>
        <category>SSH</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Oracle主键自增实现]]></title>
    <url>%2F2018%2F11%2F16%2FOracle%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Oracle没有这个”auto_increment”属性，所以它没法像MySQL般在表内定义自增主键。但是，Oracle里的序列（SEQUENCE），可间接实现自增主键的作用。 序列（Sequence），又叫序列生成器，用于提供一系列的数字，开发人员使用序列生成唯一键。每次访问序列，序列按照一定的规律增加或者减少。序列的定义存储在SYSTEM表空间中，序列不像表，它不会占用磁盘空间。序列独立于事务，每次事务的提交和回滚都不会影响序列。 创建用户数据表1234567-- 创建用户数据表DROP TABLE DECTUSER;CREATE TABLE DECTUSER( USERID INTEGER PRIMARY KEY, NAME VARCHAR2(20), SEX VARCHAR2(2)); 创建自动增长序列12345-- 创建自动增长序列DROP SEQUENCE DECTUSER_tb_seq;CREATE SEQUENCE DECTUSER_tb_seq MINVALUE 1 MAXVALUE 99999999INCREMENT BY 1START WITH 1; 创建触发器1234567-- 创建触发器CREATE OR REPLACE TRIGGER DECTUSER_tb_triBEFORE INSERT ON DECTUSER FOR EACH ROWBEGINSELECT DECTUSER_tb_seq.nextval INTO :NEW.USERID FROM DUAL;END; 尝试添加数据12345-- 尝试添加数据INSERT INTO DECTUSER(NAME,SEX) VALUES('憨八龟','男')INSERT INTO DECTUSER(NAME,SEX) VALUES('小火龙','男')INSERT INTO DECTUSER(NAME,SEX) VALUES('杰尼龟','女')commit 结果12345 USERID NAME SEX---------- ---------------------------------------- ---------- 1 憨八龟 男 2 小火龙 男 3 杰尼龟 女]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[镜花水月]]></title>
    <url>%2F2018%2F11%2F14%2F%E9%95%9C%E8%8A%B1%E6%B0%B4%E6%9C%88%2F</url>
    <content type="text"><![CDATA[只要是人都是依靠自己的知识与认知并且被之束缚生活着的，那就叫做现实。但是知识与认知是模糊不清的东西，现实也许只是镜中花水中月，人都是活在自己的执念中的。]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM基础案例文件]]></title>
    <url>%2F2018%2F11%2F11%2FSSM%E5%9F%BA%E7%A1%80%E6%A1%88%E4%BE%8B%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[BaseController.java(这个基类用来设置继承他的子类的持久化类的date属性)12345@InitBinder public void initBinder(WebDataBinder dataBinder)&#123; System.out.println("initBinder======================="); dataBinder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), true)); &#125; dao层接口与xml接口1234567891011121314151617181920212223242526272829303132333435// 增加public int insertUser(User user);// 修改public int updateUser(User user);// 删除public int deleteUser(@Param("uid") int uid);//删除地址public int deleteAddress(@Param("uid") int uid);// 根据用户id查询地址信息public List&lt;User&gt; selectUser(@Param("uid") int uid);// 根据地址id查询用户信息public List&lt;Address&gt; selectAddress(@Param("addressid") int addressid);// 根据多个用户查询public List&lt;User&gt; selectUsers(UserVo vo);//动态trim模糊查询public List&lt;User&gt;seleteUserByUser(User user);//登录public User login(User user);//模糊查询public List&lt;User&gt;getUserList(User user);//根据id获取用户信息public User getUserById(@Param("uid") int uid);//获取所有用户public List&lt;User&gt;getUsers(); xml(mapper映射)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.dao.UserMapper"&gt; &lt;!-- 增加 --&gt; &lt;insert id="insertUser" parameterType="User"&gt; INSERT INTO user_info(user_name,user_pwd,user_birthday)VALUES(#&#123;userName&#125;,#&#123;userPwd&#125;,#&#123;userBirthday&#125;) &lt;/insert&gt; &lt;!-- 动态trim修改 --&gt; &lt;update id="updateUser" parameterType="User"&gt; UPDATE user_info &lt;trim prefix="set" suffixOverrides=","&gt; &lt;if test="userName!=null and userName!=''"&gt; user_name=#&#123;userName&#125;, &lt;/if&gt; &lt;if test="userPwd!=null and userPwd!=''"&gt; user_pwd=#&#123;userPwd&#125;, &lt;/if&gt; &lt;if test="userBirthday!=null and userBirthday!=''"&gt; user_birthday=#&#123;userBirthday&#125;, &lt;/if&gt; &lt;/trim&gt; where id=#&#123;id&#125; &lt;/update&gt; &lt;!-- 删除 --&gt; &lt;delete id="deleteUser" parameterType="int"&gt; DELETE from user_info WHERE id=#&#123;uid&#125; &lt;/delete&gt; &lt;!-- 删除地址 --&gt; &lt;delete id="deleteAddress" parameterType="int"&gt; DELETE from address_info WHERE user_id=#&#123;uid&#125; &lt;/delete&gt; &lt;!-- trim查询user --&gt; &lt;select id="seleteUserByUser" resultMap="UserList" parameterType="User"&gt; SELECT *FROM user_info WHERE user_name=#&#123;userName&#125; and user_pwd=#&#123;userPwd&#125; &lt;/select&gt; &lt;resultMap type="User" id="UserList"&gt; &lt;result property="id" column="id" /&gt; &lt;result property="userName" column="user_name" /&gt; &lt;result property="userPwd" column="user_pwd" /&gt; &lt;result property="userBirthday" column="user_birthday" /&gt; &lt;/resultMap&gt; &lt;!-- 根据用户id查询地址信息 --&gt; &lt;select id="selectUser" parameterType="User" resultMap="getAddress"&gt; SELECT * FROM user_info u,address_info a WHERE a.user_id=u.id AND u.id=#&#123;uid&#125; &lt;/select&gt; &lt;resultMap type="User" id="getAddress"&gt; &lt;result property="id" column="id" /&gt; &lt;result property="userName" column="user_name" /&gt; &lt;result property="userPwd" column="user_pwd" /&gt; &lt;result property="userBirthday" column="user_birthday" /&gt; &lt;collection property="addresses" ofType="Address"&gt; &lt;result property="id" column="id" /&gt; &lt;result property="addressName" column="address_name" /&gt; &lt;result property="userId" column="user_id" /&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 根据地址id查询用户信息 --&gt; &lt;select id="selectAddress" resultMap="getUser"&gt; SELECT * FROM user_info u,address_info a WHERE a.user_id=u.id AND a.id=#&#123;addressid&#125; &lt;/select&gt; &lt;resultMap type="Address" id="getUser"&gt; &lt;result property="id" column="id" /&gt; &lt;result property="addressName" column="address_name" /&gt; &lt;result property="userId" column="user_id" /&gt; &lt;association property="user" javaType="User"&gt; &lt;result property="id" column="id" /&gt; &lt;result property="userName" column="user_name" /&gt; &lt;result property="userPwd" column="user_pwd" /&gt; &lt;result property="userBirthday" column="user_birthday" /&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 根据多个用户查询 --&gt; &lt;select id="selectUsers" parameterType="UserVo" resultMap="UserList"&gt; SELECT * FROM user_info &lt;where&gt; &lt;foreach collection="list" item="id" open="and (" close=")" separator="or"&gt; id=#&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- 登录 --&gt; &lt;select id="login" resultMap="UserList" parameterType="User"&gt; SELECT * FROM user_info WHERE user_name=#&#123;userName&#125; and user_pwd=#&#123;userPwd&#125; &lt;/select&gt; &lt;!-- 模糊查询 --&gt; &lt;select id="getUserList" resultMap="UserList" parameterType="User"&gt; SELECT * FROM user_info &lt;trim prefix="where" prefixOverrides="and | or"&gt; &lt;if test="userName!=null and userName!=''"&gt; and user_name like CONCAT('%',#&#123;userName&#125;,'%') &lt;/if&gt; &lt;if test="id!=null and id!=''"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; &lt;!-- 根据id获取用户信息 --&gt; &lt;select id="getUserById" resultMap="UserList"&gt; select * from user_info where id=#&#123;uid&#125; &lt;/select&gt; &lt;!-- 获取所有用户 --&gt; &lt;select id="getUsers" resultMap="UserList"&gt; select * from user_info &lt;/select&gt;&lt;/mapper&gt; pojo类(持久化类包括JSR-303验证)1234567891011121314//id private int id; //name @NotEmpty(message="用户名称不能为空") private String userName; //pwd @NotEmpty(message="用户密码不能为空") private String userPwd; //birthday @JSONField(format="yyyy-MM-dd") private Date userBirthday; service层(实现类)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687@Service("userServiceImpl")public class UserServiceImpl implements UserService &#123; @Autowired @Qualifier("userMapper") private UserMapper userMapper; public UserMapper getUserMapper() &#123; return userMapper; &#125; public void setUserMapper(UserMapper userMapper) &#123; this.userMapper = userMapper; &#125; @Override public int addUser(User user) &#123; // TODO Auto-generated method stub return userMapper.insertUser(user); &#125; @Override public int modifyUser(User user) &#123; // TODO Auto-generated method stub return userMapper.updateUser(user); &#125; @Override public int removerUser(int uid) &#123; // TODO Auto-generated method stub userMapper.deleteAddress(uid); return userMapper.deleteUser(uid); &#125; @Override public List&lt;User&gt; findUser(int uid) &#123; // TODO Auto-generated method stub return userMapper.selectUser(uid); &#125; @Override public List&lt;Address&gt; findAddress(int addressid) &#123; // TODO Auto-generated method stub return userMapper.selectAddress(addressid); &#125; @Override public List&lt;User&gt; findUsers(UserVo vo) &#123; // TODO Auto-generated method stub return userMapper.selectUsers(vo); &#125; @Override public List&lt;User&gt; findUserByUser(User user) &#123; // TODO Auto-generated method stub return userMapper.seleteUserByUser(user); &#125; @Override public int deleteAddress(int uid) &#123; // TODO Auto-generated method stub return userMapper.deleteAddress(uid); &#125; @Override public User login(User user) &#123; // TODO Auto-generated method stub return userMapper.login(user); &#125; @Override public List&lt;User&gt; getUserList(User user) &#123; // TODO Auto-generated method stub return userMapper.getUserList(user); &#125; @Override public User getUserById(int uid) &#123; // TODO Auto-generated method stub return userMapper.getUserById(uid); &#125; @Override public List&lt;User&gt; getUsers() &#123; // TODO Auto-generated method stub return userMapper.getUsers(); &#125; logger(AOP)1234567891011121314151617181920212223242526272829303132/** * 定义切面 * @author F117 * */@Aspectpublic class logger &#123; private static final Logger LOGGER=Logger.getLogger(logger.class); @Pointcut("execution(* cn.service..*.*(..))") public void Pointcut()&#123;&#125; @AfterReturning(pointcut="Pointcut()",returning="returnCalue") public void afterReturning(JoinPoint jp,Object returnCalue)&#123; LOGGER.info("调用"+jp.getTarget()+"的"+jp.getSignature().getName()+"方法,返回值"+returnCalue); &#125; @Around("Pointcut()") public Object aroundLogger(ProceedingJoinPoint jp) throws Throwable&#123; LOGGER.info("调用"+jp.getTarget()+"的"+jp.getSignature().getName()+"方法,方法入参"+Arrays.toString(jp.getArgs())); try &#123; Object result=jp.proceed(); LOGGER.info("调用"+jp.getTarget()+"的"+jp.getSignature().getName()+"方法,返回值"+result); return result; &#125; catch (Throwable e) &#123; // TODO: handle exception throw e; &#125;finally &#123; LOGGER.info("====&gt;"+jp.getSignature().getName()+"方法结束"); &#125; &#125;&#125; StringToDateConverter(自定义转换器)123456789101112131415161718192021222324public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123; private String dataPattern; public StringToDateConverter(String dataPattern) &#123; System.out.println("StringToDateConverter conver"+dataPattern); this.dataPattern=dataPattern; &#125; @Override public Date convert(String s) &#123; // TODO Auto-generated method stub Date date=null; try &#123; date= new SimpleDateFormat(dataPattern).parse(s); System.out.println("convert date:"+date); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return date; &#125;&#125; applicationContextl.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd"&gt; &lt;context:component-scan base-package="cn.service"&gt;&lt;/context:component-scan&gt; &lt;context:component-scan base-package="cn.controller"&gt;&lt;/context:component-scan&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;bean class="cn.tool.logger" /&gt; &lt;!-- 读取数据库配置文件 --&gt; &lt;context:property-placeholder location="classpath:database.properties" /&gt; &lt;!-- JNDI获取数据源(使用dbcp连接池) --&gt; &lt;bean class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" scope="singleton" id="dataSource"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;user&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;" /&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;" /&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;" /&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;" /&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;" /&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;" /&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;" /&gt; &lt;!-- sql 心跳 --&gt; &lt;property name="testWhileIdle" value="true" /&gt; &lt;property name="testOnBorrow" value="false" /&gt; &lt;property name="testOnReturn" value="false" /&gt; &lt;property name="validationQuery" value="select 1" /&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="60000" /&gt; &lt;property name="numTestsPerEvictionRun" value="$&#123;maxActive&#125;" /&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactoryBean --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;property name="configLocation" value="classpath:mybatis-configl.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Dao --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.dao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务增强 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置切面 --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression="execution(* cn.service..*.*(..))" id="myPoint" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="myPoint" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; database.properties1234567891011driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/sm_db?useUnicode=true&amp;characterEncoding=utf-8user=rootpassword=rootminIdle=45maxIdle=50initialSize=5maxActive=100maxWait=100removeAbandonedTimeout=180removeAbandoned=true log4j.properties123456789101112131415161718192021222324252627282930313233343536log4j.rootLogger=DEBUG,CONSOLE,file#log4j.rootLogger=ERROR,ROLLING_FILElog4j.logger.cn.smbms.dao=debuglog4j.logger.com.ibatis=debug log4j.logger.com.ibatis.common.jdbc.SimpleDataSource=debug log4j.logger.com.ibatis.common.jdbc.ScriptRunner=debug log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=debug log4j.logger.java.sql.Connection=debug log4j.logger.java.sql.Statement=debug log4j.logger.java.sql.PreparedStatement=debug log4j.logger.java.sql.ResultSet=debug log4j.logger.org.tuckey.web.filters.urlrewrite.UrlRewriteFilter=debug####################################################################################### Console Appender \u65e5\u5fd7\u5728\u63a7\u5236\u8f93\u51fa\u914d\u7f6e######################################################################################log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.Threshold=errorlog4j.appender.CONSOLE.Target=System.outlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern= [%p] %d %c - %m%n####################################################################################### DailyRolling File \u6bcf\u5929\u4ea7\u751f\u4e00\u4e2a\u65e5\u5fd7\u6587\u4ef6\uff0c\u6587\u4ef6\u540d\u683c\u5f0f:log2009-09-11######################################################################################log4j.appender.file=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.file.DatePattern=yyyy-MM-ddlog4j.appender.file.File=log.loglog4j.appender.file.Append=truelog4j.appender.file.Threshold=errorlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-M-d HH:mm:ss&#125;%x[%5p](%F:%L) %m%nlog4j.logger.com.opensymphony.xwork2=error mybatis-configl.xml1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置mybatis的log实现为LOG4J --&gt; &lt;settings&gt; &lt;!-- &lt;setting name="logImpl" value="LOG4J" /&gt; --&gt; &lt;setting name="lazyLoadingEnabled" value="false"/&gt; &lt;setting name="autoMappingBehavior" value="FULL"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name="cn.pojo"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; springmvc-servlet.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 配置处理器映射 HandlerMapping --&gt; &lt;!-- &lt;bean name="/index.html" class="cn.smbms.controller.IndexController" /&gt; --&gt; &lt;!-- &lt;bean name="/welcome" class="cn.smbms.controller.IndexController" /&gt; --&gt; &lt;!-- &lt;bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;/bean&gt; --&gt; &lt;context:component-scan base-package="cn.controller" /&gt; &lt;!-- 自定义转换器 --&gt; &lt;bean id="myConversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;bean class="cn.tool.StringToDateConverter"&gt; &lt;constructor-arg type="java.lang.String" value="yyyy-MM-dd" /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;mvc:annotation-driven&gt; &lt;!-- 消息转换器 --&gt; &lt;mvc:message-converters&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean class="com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="features"&gt; &lt;list&gt; &lt;value&gt;WriteDateUseDateFormat&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 完成视图的对应 --&gt; &lt;!-- 对转向页面的路径解析。prefix：前缀， suffix：后缀 --&gt; &lt;!-- &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; --&gt; &lt;!-- 配置多视图解析器 ：允许统一的内容数据呈现在不同的view中 --&gt; &lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt; &lt;!-- 支持参数匹配 --&gt; &lt;property name="favorParameter" value="true" /&gt; &lt;property name="mediaTypes"&gt; &lt;map&gt; &lt;entry key="html" value="text/html;charset=UTF-8"&gt;&lt;/entry&gt; &lt;entry key="json" value="application/json;charset=UTF-8"&gt;&lt;/entry&gt; &lt;entry key="xml" value="application/xml;charset=UTF-8"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 网页视图解析器 --&gt; &lt;property name="viewResolvers"&gt; &lt;list&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;mvc:resources location="/statics/" mapping="/statics/**"&gt;&lt;/mvc:resources&gt; &lt;!-- 全局异常的配置 --&gt; &lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt; &lt;property name="exceptionMappings"&gt; &lt;props&gt; &lt;prop key="java.lang.RuntimeException"&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置MulitpartResolver，用于文件上传 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="5000000" /&gt; &lt;property name="defaultEncoding" value="utf-8" /&gt; &lt;/bean&gt;&lt;/beans&gt; web.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;CG09&lt;/display-name&gt; &lt;!-- 配置环境参数，指定spring配置文件的所在目录--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContextl.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 配置spring的ContextLoaderListener监听器，初始化spring容器--&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.util.Log4jConfigListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt;&lt;param-name&gt;webAppRootKey&lt;/param-name&gt;&lt;param-value&gt; app.root &lt;/param-value&gt;&lt;/context-param&gt; &lt;/web-app&gt; UserController(核心)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130@Controller@RequestMapping("/user")public class UserController extends BaseController &#123; public UserService getUserService() &#123; return userService; &#125; public void setUserService(UserService userService) &#123; this.userService = userService; &#125; private Logger logger = Logger.getLogger(UserController.class); @Autowired @Qualifier("userServiceImpl") private UserService userService; // 实现跳转到登录页 @RequestMapping(value = "/login.html") public String login() &#123; logger.info("用户跳转到登录页====================&gt;"); return "login"; &#125; // 主页面 @RequestMapping(value = "main.html") public String hetmain() &#123; logger.info("用户跳转到主页面====================&gt;"); return "main"; &#125; // 实现登录 @RequestMapping(value = "dologin.html", method = RequestMethod.POST) public String doLogin(String userName, String userPwd, HttpSession session, HttpServletRequest request,RedirectAttributes attr) throws Exception &#123; logger.info("登录中======================&gt;"); // 调用service方法进行用户匹配 User user=new User(); user.setUserName(userName); user.setUserPwd(userPwd); User user2=new User(); user2 = userService.login(user); if(null!=user2)&#123;//登陆成功 attr.addFlashAttribute("u1", user2); return "redirect:/user/main.html"; //response.sendRedirect("jsp/frame.jsp") &#125;else&#123; request.setAttribute("error","用户名密码不正确"); return "login"; &#125; &#125; //根据用户id获取用户信息 @RequestMapping(value="usermodify.html",method = RequestMethod.GET) public String getUserByID(@RequestParam int id,Model model)&#123; User user=new User(); user=userService.getUserById(id); model.addAttribute("user", user); return "toEditUserView"; &#125; @RequestMapping(value="usermodifysave.html",method=RequestMethod.POST) public String modifyUserSave(User user,HttpSession session)&#123; if(userService.modifyUser(user)&gt;0)&#123; return "redirect:/user/userlist.html"; &#125; return "toEditUserView"; &#125; @RequestMapping(value="userlist.html",method = RequestMethod.GET) public String getUserList(Model model)&#123; List&lt;User&gt;userList=new ArrayList&lt;User&gt;(); userList=userService.getUsers(); model.addAttribute("userList", userList); return "userInfoList"; &#125; //添加 @RequestMapping(value="addUser.html",method=RequestMethod.GET) public String add(@ModelAttribute("user") User user,Model model)&#123; return "doSaveUserInfo"; &#125; @RequestMapping(value="addUsersave.html",method=RequestMethod.POST) public String addSave(@Valid User user, BindingResult bindingResult, HttpSession session)&#123; if(bindingResult.hasErrors())&#123; return "doSaveUserInfo"; &#125; int num=userService.addUser(user); System.out.println("==================="+num); if(num&gt;0)&#123; return "redirect:/user/userlist.html"; &#125; return "doSaveUserInfo"; &#125; @RequestMapping(value = "/error.html") public String error() &#123; return "error"; &#125; @RequestMapping(value="userdelete.html",method = RequestMethod.GET) public String getUserByIDs(@RequestParam int id,Model model)&#123; User user=new User(); user=userService.getUserById(id); model.addAttribute("user", user); return "deleteUserInfo"; &#125; //删除 @RequestMapping(value="/deleteUser.html",method=RequestMethod.POST) public String deleteUser(@RequestParam int id)&#123; int nums=userService.removerUser(id); System.out.println("===================&gt;"+nums); if(nums&gt;=1)&#123; return "redirect:/user/userlist.html"; &#125;else&#123; return "error"; &#125; &#125;&#125; 保存文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//跳转到新增appinfo页面 @RequestMapping(value="/appinfoadd",method=RequestMethod.GET) public String add(@ModelAttribute("appInfo") AppInfo appInfo)&#123; return "developer/appinfoadd"; &#125; //保存appinfo数据 @RequestMapping(value="/appinfoaddsave",method=RequestMethod.POST) public String addSave(AppInfo appInfo,HttpSession session,HttpServletRequest request, @RequestParam(value="a_logoPicPath",required= false) MultipartFile attach)&#123; String logoPicPath = null; String logoLocPath = null; if(!attach.isEmpty())&#123; String path = request.getSession().getServletContext().getRealPath("statics"+java.io.File.separator+"uploadfiles"); logger.info("uploadFile path: " + path); String oldFileName = attach.getOriginalFilename();//原文件名 String prefix = FilenameUtils.getExtension(oldFileName);//原文件后缀 int filesize = 500000; if(attach.getSize() &gt; filesize)&#123;//上传大小不得超过 50k request.setAttribute("fileUploadError", Constants.FILEUPLOAD_ERROR_4); return "developer/appinfoadd"; &#125;else if(prefix.equalsIgnoreCase("jpg") || prefix.equalsIgnoreCase("png") ||prefix.equalsIgnoreCase("jepg") || prefix.equalsIgnoreCase("pneg"))&#123;//上传图片格式 String fileName = appInfo.getAPKName() + ".jpg";//上传LOGO图片命名:apk名称.apk File targetFile = new File(path,fileName); if(!targetFile.exists())&#123; targetFile.mkdirs(); &#125; try &#123; attach.transferTo(targetFile); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); request.setAttribute("fileUploadError", Constants.FILEUPLOAD_ERROR_2); return "developer/appinfoadd"; &#125; logoPicPath = request.getContextPath()+"/statics/uploadfiles/"+fileName; //绝对路径 logoLocPath = path+File.separator+fileName; //相对路径 &#125;else&#123; request.setAttribute("fileUploadError", Constants.FILEUPLOAD_ERROR_3); return "developer/appinfoadd"; &#125; &#125; appInfo.setCreatedBy(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appInfo.setCreationDate(new Date()); appInfo.setLogoPicPath(logoPicPath); appInfo.setLogoLocPath(logoLocPath); appInfo.setDevId(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appInfo.setStatus(1); try &#123; if(appInfoService.add(appInfo))&#123; return "redirect:/dev/flatform/app/list"; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return "developer/appinfoadd"; &#125; JSP页面列表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt;&lt;head&gt;&lt;base href="&lt;%=basePath%&gt;"&gt;&lt;title&gt;My JSP 'userInfoList.jsp' starting page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="user/addUser.html"&gt;添加用户&lt;/a&gt; &lt;h2&gt;用户列表&lt;/h2&gt; &lt;table class="providerTable" cellpadding="0" cellspacing="0"&gt; &lt;tr class="firstTr"&gt; &lt;th width="10%"&gt;用户id&lt;/th&gt; &lt;th width="20%"&gt;用户名称&lt;/th&gt; &lt;th width="10%"&gt;用户密码&lt;/th&gt; &lt;th width="10%"&gt;生日日期&lt;/th&gt; &lt;th width="10%"&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach var="user" items="$&#123;userList &#125;" varStatus="status" begin="0"&gt; &lt;tr&gt; &lt;td&gt;&lt;span&gt;$&#123;user.id &#125;&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;$&#123;user.userName &#125;&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;$&#123;user.userPwd&#125;&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;$&#123;user.userBirthday.year+1900&#125;-&lt;c:if test="$&#123;user.userBirthday.month+1 &lt; 10&#125;"&gt;0&lt;/c:if&gt;$&#123;user.userBirthday.month+1&#125;-&lt;c:if test="$&#123;user.userBirthday.date &lt; 10&#125;"&gt;0&lt;/c:if&gt;$&#123;user.userBirthday.date&#125;&lt;/span&gt; &lt;/td&gt; &lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/user/usermodify.html?id=$&#123;user.id &#125;"&gt;修改&lt;/a&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/user/userdelete.html?id=$&#123;user.id &#125;"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 添加12345678910111213141516171819202122232425262728293031323334353637383940&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;%@taglib prefix="fm" uri="http://www.springframework.org/tags/form" %&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;My JSP 'doSaveUserInfo.jsp' starting page&lt;/title&gt; &lt;meta http-equiv="pragma" content="no-cache"&gt; &lt;meta http-equiv="cache-control" content="no-cache"&gt; &lt;meta http-equiv="expires" content="0"&gt; &lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt; &lt;meta http-equiv="description" content="This is my page"&gt; &lt;!-- &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;新增用户&lt;/h2&gt; &lt;fm:form method="post" modelAttribute="user" action="$&#123;pageContext.request.contextPath&#125;/user/addUsersave.html"&gt; &lt;fm:errors path="userName"/&gt;&lt;br/&gt; 用户名称：&lt;fm:input path="userName"/&gt;&lt;br/&gt; &lt;fm:errors path="userPwd"/&gt;&lt;br/&gt; 用户密码：&lt;fm:password path="userPwd"/&gt;&lt;br/&gt; &lt;fm:errors path="userBirthday"/&gt;&lt;br/&gt; 用户生日：&lt;fm:input path="userBirthday" Class="Wdate" id="birthday" name="userBirthday" readonly="readonly" /&gt;&lt;br/&gt; &lt;input type="submit" value="保存"&gt; &lt;/fm:form&gt; &lt;/body&gt;&lt;/html&gt; 修改1234567891011121314 &lt;body&gt; &lt;h2&gt;用户修改页面&lt;/h2&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/user/usermodifysave.html" method="post"&gt; &lt;input type="hidden" name="id" value="$&#123;user.id &#125;"&gt;&lt;br/&gt; &lt;input type="text" name="userName" value="$&#123;user.userName &#125;"&gt;&lt;br/&gt; &lt;input type="text" name="userPwd" value="$&#123;user.userPwd &#125;"&gt;&lt;br/&gt; &lt;input type="text" name="userBirthday" value="$&#123;user.userBirthday &#125;"&gt;&lt;br/&gt; &lt;input type="submit" value="修改"&gt; &lt;input type="button" value="返回主页面"&gt; &lt;/form&gt; &lt;/body&gt; ### 有形的东西迟早会凋零，但只有回忆是永远不会凋零的]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hibernate关系映射]]></title>
    <url>%2F2018%2F11%2F08%2FHibernate%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[映射关系的形成 hibernate在实现ORM功能的时候主要用到的文件有：映射类（.Java）、映射文件（.hbm.xml）和数据库配置文件（.properties/.cfg.xml） 映射类（*.java）：它是描述数据库表的结构，表中的字段在类中被描述成属性，将来就可以实现把表中的记录映射成为该类的对象了。 映射文件（*.hbm.xml）：它是指定数据库表和映射类之间的关系，包括映射类和数据库表的对应关系、表字段和类属性类型的对应关系以及表字段和类属性名称的对应关系等。 数据库配置文件（.properties/.cfg.xml）：它是指定与数据库连接时需要的连接信息，比如连接哪种数据库、登录数据库的用户名、登录密码以及连接字符串等。当然还可以把映射类的地址映射信息放在这里。 hibernate中的关联关系有四种：一对一、一对多、多对一、多对多关联关系(是有方向的)Dept(部门表)，Emp(员工表),一个部门下有多个员工，而一个员工只属于一个部门，所以Emp-&gt;Dept是多对一的关系，每个Emp对象只会引用一个Dept对象,而Dept-&gt;Emp是一对多的关系，表示每个Dept对象会引用一组Emp对象，因此在Emp类中应该定义一个Dept类型的属性，而在Dept类中需要定义一个集合类型的属性，来引用Emp所有关联的Emp对象，如果只配置一方被成为单向映射，两个都配置被称为双向 单向关联单向关联是指只有一方有另一方的关联信息而另一方没有关联信息A——&gt;BA对象中有B对象的关联信息B对象中没有A对象的关联信息我们可以通过A对象中B的关联信息查询或修改B对象的信息但无法通过B对象来查询修改A对象的信息同理A&lt;——B也是单向关联 双向关联A&lt;——&gt;BA对象中有B对象的关联信息B对象中也有A对象的关联信息我们可以通过A对象中B的关联信息查询或修改B对象的信息也可以通过B对象来查询修改A对象的信息 单向关联一般在一方配置多方不进行配置 12345 如：一对多 单向关联在“一”的一方配置文件里进行配置,"多"的一方不进行配置双向关联两方都要配置 如：一对多 双向关联在“一”的一方配置文件里需要配置，“多”的一方也需要进行配置 一对一关联映射一对一是指一个对象对应一个对象 如：一个人只有一个身份证。 在两个数据表之间的一对一关系可以有两种实现方法，其中一种就是通过两个表的主键相关联，另一种是通过外键相关联 一个人（Person）对应一个地址（Address） 一对一主键单向关联pojo1234567891011public class Person &#123; private int personid; private String name; private int age; //在Person对象中有Address对象的关联信息 private Address address; public class Address&#123; //Address对象中没有Person对象的关联信息 private int addressid; private String addressdetail; 映射hbm.xml文件12345678910111213141516Person.hbm.xml&lt;hibernate-mapping&gt; &lt;class name="com.entity.Person" table="PERSON"&gt; &lt;id name="personid" column="presonid"&gt; &lt;!--基于主键关联时，主键生成策略是foreign，表明根据关联类生成主键--&gt; &lt;generator class="foreign"&gt; &lt;!--关联持久化类的属性名--&gt; &lt;param name="property"&gt;address&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; &lt;property name="name"/&gt; &lt;property name="age"/&gt; &lt;!--constrained设定为true，表示的主键必须与Person中对应资料的主键相同。--&gt; &lt;one-to-one name="address" constrained="true"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; Address.hbm.xml中不做任何配置 一对一主键双向关联Person&lt;——&gt;Address123456789101112public class Person implements java.io.Serializable &#123; private Long id; private String name; //双向关联中Person对象中有Adderss对象的关联信息 private Address address; public class Address implements java.io.Serializable &#123; private Long id; //Adderss对象中也有Person对象的关联信息 private Person person; private String detail; Person.hbm.xml1234567891011121314&lt;hibernate-mapping&gt; &lt;class name="entity.Person" table="person"&gt; &lt;id name="id" type="java.lang.Long"&gt; &lt;column name="id" /&gt; &lt;generator class="identity" /&gt; &lt;/id&gt; &lt;property name="name" type="java.lang.String"&gt; &lt;column name="name" length="24" not-null="true"&gt; &lt;comment&gt;姓名&lt;/comment&gt; &lt;/column&gt; &lt;/property&gt; &lt;one-to-one name="address"/&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; Address.hbm.xml123456789101112131415161718&lt;hibernate-mapping&gt; &lt;class name="entity.Address" table="address" catalog="mydb"&gt; &lt;id name="id" type="java.lang.Long"&gt; &lt;column name="id" /&gt; &lt;!-- class="foreign": 一对一主键映射中，使用另外一个相关联的对象的标识符 --&gt; &lt;generator class="foreign"&gt; //表明id的生成方式是引用表people的主键 &lt;param name="property"&gt;person&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; &lt;property name="detail" type="java.lang.String"&gt; &lt;column name="detail" length="120" not-null="true"&gt; &lt;comment&gt;详细地址&lt;/comment&gt; &lt;/column&gt; &lt;/property&gt; &lt;!-- 表示在address表存在一个外键约束，外键参考相关联的表person --&gt; &lt;one-to-one name="person" constrained="true" /&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 一对一外键单向关联Person——&gt;Address123456789public class Person &#123; private int personid; private String name; private int age; private Address address; public class Address&#123; private int addressid; private String addressdetail; 123456789101112131415161718Address.hbm.xml&lt;!--address中不做任何配置所以我们省略--&gt; …………………………&lt;!--单向关联和双向关联的区别在于单向关联只在一方配置双向关联两方都要配置--&gt;Person.hbm.xml&lt;hibernate-mapping&gt; &lt;class name="com.entity.Person" table="PERSON"&gt; &lt;id name="personid"&gt; &lt;generator class="identity"/&gt; &lt;/id&gt; &lt;property name="name"/&gt; &lt;property name="age"/&gt; &lt;!--用来映射关联PO column是Address在该表中的外键列名,增加unique变成唯一的--&gt; &lt;many-to-one name="address" unique="true"/&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 外键关联和主键关联不同的地方是采用标签来映射，一对一唯一外键关联映射其实是多对一的特例。指定多的一端unique为true，这样就限制了多的一端的多重性为一，就是这样来映射的。 一对一外键双向关联Person&lt;——&gt;Address12345678910public class Person implements java.io.Serializable &#123; private Long id; private String name; private Address address; public class Address implements java.io.Serializable &#123; private Long id; private Person person; private String detail; 123456789101112131415161718192021222324252627282930313233343536Person.hbm.xml&lt;hibernate-mapping&gt; &lt;class name="com.entity.Person" table="person"&gt; &lt;id name="personid" type="java.lang.Long"&gt; &lt;column name="personid" /&gt; &lt;generator class="identity" /&gt; &lt;/id&gt; &lt;property name="name" type="java.lang.String"&gt; &lt;column name="name" length="24" not-null="true"&gt; &lt;comment&gt;姓名&lt;/comment&gt; &lt;/column&gt; &lt;/property&gt; &lt;!--双向关联配置--&gt; &lt;one-to-one name="address" /&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt;Address.hbm.xml&lt;hibernate-mapping&gt; &lt;class name="com.entity.Address" table="address" catalog="testdb"&gt; &lt;id name="addressid" type="java.lang.Long"&gt; &lt;column name="addressid" /&gt; &lt;generator class="identity" /&gt; &lt;/id&gt; &lt;property name="detail" type="java.lang.String"&gt; &lt;column name="detail" length="120" not-null="true"&gt; &lt;comment&gt;详细地址&lt;/comment&gt; &lt;/column&gt; &lt;/property&gt; &lt;many-to-one name="person" class="entity.Person" unique="true"&gt; &lt;column name="personid"&gt; &lt;comment&gt;人的ID&lt;/comment&gt; &lt;/column&gt; &lt;/many-to-one&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 一对多关联映射一对多单向关联Classes——&gt;Student12345678910public class Classes &#123; private int id; private String name; //Set支持延迟加载因为多个学生所以我们用Set集合关联 private Set students; &#125; public class Student &#123; private int id; private String name; &#125; Classes对象中使用了set属性，但是只是说明了延迟加载的属性，并没有为属性配置对应的对象，属性的对象是要在映射文件中来配置的，需要添加set标签，并在set标签中添加标签123456789101112&lt;hibernate-mapping&gt; &lt;class name="com.hibernate.Classes" table="t_classes"&gt; &lt;id name="id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="name"/&gt; &lt;set name="students"&gt; &lt;key column="classesid"&gt;&lt;/key&gt; &lt;one-to-many class="com.hibernate.Student"&gt;&lt;/one-to-many&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; Student.hbm.xml不做任何改变 一对多双向关联Classes&lt;——&gt;Student123456789101112public class Classes &#123; private int id; private String name; //Set支持延迟加载 private Set&lt;Student&gt; students; &#125; public class Student &#123; private int id; private String name; //添加class对象关联信息因为是一方所以我们用一个对象关联 private Classes classes; &#125; 1234567891011Student.hbm.xml&lt;hibernate-mapping&gt; &lt;class name="com.hibernate.Student" table="t_student"&gt; &lt;id name="id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="name"/&gt; &lt;!-- 在多的一端Student中添加一行新的Classes列 ,并且列的名称要和Classes.hbm.xml的列明相同--&gt; &lt;many-to-one name="classes" column="classesid"&gt;&lt;/many-to-one&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 多对多关联映射多对多关联是指多个对象对应多个对象 如：老师可以有多个学生，学生也可以有多个老师 多对多单向关联Teacher——&gt;Student1234567891011public class Teacher &#123; private int id; private String name; private Set&lt;Student&gt; students = new HashSet&lt;Student&gt;();｝public class Student &#123; private int id; private String name; private String title;｝ Teacher.hbm.xml123456789101112131415&lt;hibernate-mapping&gt; &lt;class name="com.hibernate.Teacher" table="t_teacher"&gt; &lt;id name="id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="name"/&gt; &lt;!--生成一张新表存放两个关联对象的ID--&gt; &lt;set name="students" table="Teacher_Sutdent"&gt; &lt;!--将Teacher表的外键关联 注意不是对象的属性是表中的字段--&gt; &lt;key column="teacher_id"&gt;&lt;/key&gt; &lt;!--将Student表的外键关联 注意不是对象的属性是表中的字段--&gt; &lt;many-to-many class="com.hibernate.Student" column="student_id"&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 多对多双向关联Teacher&lt;——&gt;Student123456789101112public class Teacher &#123; private int id; private String name; private Set&lt;Student&gt; students = new HashSet&lt;Student&gt;();｝public class Student &#123; private int id; private String name; private String title; private Set&lt;Teacher&gt; teachers = new HashSet&lt;Teacher&gt;();｝ Student.hbm.xml123456789101112131415&lt;hibernate-mapping&gt; &lt;class name="com.hibernate.Student" table="t_student"&gt; &lt;id name="id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="name"/&gt; &lt;!--生成一张新表存放两个表的Id--&gt; &lt;set name="teachers" table="Teacher_Student"&gt; &lt;!--将Teacher表的外键关联 注意不是对象的属性是表中的字段--&gt; &lt;key column="student_id"&gt;&lt;/key&gt; &lt;!--将Student表的外键关联 注意不是对象的属性是表中的字段--&gt; &lt;many-to-many class="com.hibernate.Teacher" column="teacher_id"&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; Teacher.hbm.xml123456789101112131415&lt;hibernate-mapping&gt; &lt;class name="com.hibernate.Teacher" table="t_teacher"&gt; &lt;id name="id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="name"/&gt; &lt;!--生成一张新表存放两个关联对象的ID--&gt; &lt;set name="students" table="Teacher_Sutdent"&gt; &lt;!--将Teacher表的外键关联 注意不是对象的属性是表中的字段--&gt; &lt;key column="teacher_id"&gt;&lt;/key&gt; &lt;!--将Student表的外键关联 注意不是对象的属性是表中的字段--&gt; &lt;many-to-many class="com.hibernate.Student" column="student_id"&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 多对一关联对比一对一关联映射和多对一唯一外键关联映射，其实它们两个都是使用了本质上都是外键约束，只不过一对一的是唯一映射，需要添加unique=”true”的属性，其它的它们两个是相同的 多对一关联是指多个对象对应一个对象 如：多个员工对应一个部门 多对一单向关联12345678910public class Department &#123; private int id; private String name; &#125; public class Employee &#123; private int id; private String name; private Department depart;//注意这里是以部门的对象来作为员工的属性的&#125; Employee.hbm.xml123456789101112&lt;hibernate-mapping package="com.suo.domain"&gt; &lt;class name="Employee"&gt; &lt;id name="id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="name"/&gt; &lt;many-to-one name="depart"&gt;&lt;/many-to-one&gt; &lt;!-- many-to-one指明了外键 ，会根据反射机制，找到要和Employee建立多对一关系的类，该列默认的是可以为空的--&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 多对一双向关联123456789101112public class Department &#123; private int id; private String name; private Set&lt;Employee&gt; emps;//用集合来存储员工 &#125; public class Employee &#123; private int id; private String name; private Department depart;//注意这里是以部门的对象来作为员工的属性的，这个思想很关键，是建立起部门和员工关联的关键 &#125; Departement .hbm.xml12345678910111213141516171819&lt;hibernate-mapping package="com.suo.domain"&gt; &lt;class name="Department"&gt; &lt;id name="id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="name"/&gt; &lt;set name="emps"&gt; &lt;key column="depart_id"/&gt;&lt;!-- key指明了员工表中的外键--&gt; &lt;one-to-many class="Employee"/&gt;&lt;!-- one-to-many指明了和哪个类进行一对多的映射 --&gt; &lt;/set&gt; &lt;!-- 用set标签表示Department中的员工集合的属性，这个属性并没有映射到数据库中的部门表中， 即部门表中，并没有emps这样的一个列。 --&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; Employee.hbm.xml123456789101112&lt;hibernate-mapping package="com.suo.domain"&gt; &lt;class name="Employee"&gt; &lt;id name="id"&gt; &lt;generator class="native"/&gt; &lt;/id&gt; &lt;property name="name"/&gt; &lt;many-to-one name="depart"&gt;&lt;/many-to-one&gt; &lt;!-- many-to-one指明了外键 ，会根据反射机制，找到要和Employee建立多对一关系的类，该列默认的是可以为空的--&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 级联操作CasadeCasade用来说明当对主对象进行某种操作时是否对其关联的从对象也作类似的操作，常用的cascade:none,all,save-update,delete 一般对many-to-one,many-to-many不设置级联，在和中设置级联 inverseinverse表“是否放弃维护关联关系”(在Java里两个对象产生关联时，对数据库表的影响)，在one-to-many和many-to-many的集合定义中使用，inverse=”true”表示该对象不维护关联关系]]></content>
      <categories>
        <category>SSH</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HQL实用技术]]></title>
    <url>%2F2018%2F11%2F08%2FHQL%E5%AE%9E%E7%94%A8%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[今天来学习HQL语句 编写HQL语句from子句 例：from com.entity.Dept; from Dept dept;–为持久化类Dept指定了别名dept；可省略包名 select子句 例：select dept from Dept as dept; select dept.DeptName from Dept as dept;–选取单个属性，可选择多个 where子句例：from Dept where DeptName=’SALES’; from Dept dept where dept.DeptName=’SALES’; from Dept dept where dept.location is not null;–查询地址不为空的部门 使用表达式 例：from Dept dept where lower(dept.DeptName)=’sales’;–lower()把字符串中的字母转换成小写 from Emp where year(hireDate)=1980;–year()用于获取日期字段的年份 order by子句 例：from Emp order by hireDate asc from Emp order by hireDate,salary desc; 执行HQL语句 执行HQL语句步骤 1、获取session对象 2、编写HQL语句 3、创建Query对象 4、执行查询 先给大家看一些简单的例子吧 DAO层123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 查询public List&lt;User&gt; findAllUser() &#123; return this.currentSession().createQuery("from User").list();&#125;// Iterator返回public Iterator&lt;User&gt; findAllUser_iterate() &#123; return this.currentSession().createQuery("from User").iterate();&#125;// 根据姓名查询public Iterator&lt;User&gt; findAllUserByName() &#123; return this.currentSession().createQuery("from User where name='李钰洋'").iterate();&#125;// 获取唯一结果public Long countUser() &#123; return (Long) this.currentSession().createQuery("select count(id) from User").uniqueResult();&#125;// 参数查询,位置从0开始public List&lt;User&gt; findUserByName(String name) &#123; return this.currentSession().createQuery("from User where name=?").setString(0, name).list();&#125;// 按参数名绑定public List&lt;User&gt; findUserByName1(String name) &#123; return this.currentSession().createQuery("from User where name=:name1").setString("name1", name).list();&#125;// 多参数查询 +结合位置public List&lt;User&gt; findByCoditions(Object[] param) &#123; Query query = this.currentSession().createQuery("from User where name=? and telephone=?"); if (param != null &amp;&amp; param.length != 0) &#123; for (int i = 0; i &lt; param.length; i++) &#123; query.setParameter(i, param[i]); &#125; &#125; return query.list();&#125;// 多参数查询 +结合名称 赛高public List&lt;User&gt; findByCoditions(User param) &#123; Query query = this.currentSession().createQuery("from User where name=:name and telephone=:telephone"); query.setProperties(param); // 赛高 return query.list();&#125;// 多参数查询 +结合名称 赛高 动态hqlpublic List&lt;User&gt; findByCoditions(String hql, User param) &#123; Query query = this.currentSession().createQuery(hql); query.setProperties(param); // 赛高 return query.list();&#125;// 多参数查询 +结合名称 赛高 动态hql mappublic List&lt;User&gt; findByCoditions(String hql, Map&lt;String, Object&gt; param) &#123; Query query = this.currentSession().createQuery(hql); query.setProperties(param); // 赛高 return query.list();&#125;// 分页public List&lt;User&gt; findByPage(int pageNo, int pageSize) &#123; return this.currentSession().createQuery("from User order by id").setFirstResult((pageNo - 1) * pageSize) .setMaxResults(pageSize).list();&#125;// 根据id降序获取前3public List&lt;User&gt; findByOrder(int topSize) &#123; return this.currentSession().createQuery("from User order by id").setMaxResults(topSize).list();&#125;// 投影查询public List findByProjection() &#123; return this.currentSession().createQuery("select name from User").list();&#125;// 投影查询 查多列public List&lt;Object[]&gt; findByProjection2() &#123; return this.currentSession().createQuery("select name,telephone from User").list();&#125;//构造函数封装对象public List&lt;User&gt; findByProjection3() &#123; return this.currentSession().createQuery("select new User(name,telephone) from User").list();&#125; SERVICE层123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292// 查询public List&lt;User&gt; findAllUser() &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findAllUser(); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// Iterator返回public Iterator&lt;User&gt; findAllUser_Iterator() &#123; Transaction tx = null; Iterator&lt;User&gt; list = null; try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findAllUser_iterate(); User u = new User(); while (list.hasNext()) &#123; u = list.next(); System.out.println(u.getName() + "艸"); &#125; tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 根据姓名Iterator返回public Iterator&lt;User&gt; findAllUser_IteratorByName() &#123; Transaction tx = null; Iterator&lt;User&gt; list = null; try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findAllUserByName(); User u = new User(); while (list.hasNext()) &#123; u = list.next(); System.out.println(u.getName() + "\\" + u.getTelephone()); &#125; tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 返回唯一结果public Long findAllUser_count() &#123; Transaction tx = null; Long count = null; try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); count = userDao.countUser(); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return count;&#125;// 查询+参数public List&lt;User&gt; findAllUser_Name(String name) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findUserByName(name); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 查询+名称参数public List&lt;User&gt; findAllUser_Name1(String name) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findUserByName1(name); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 查询+多参数public List&lt;User&gt; findAllbyCondinitions(Object[] param) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByCoditions(param); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 查询+多参数public List&lt;User&gt; findAllbyCondinitions(User param) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByCoditions(param); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 查询+多参数 动态hqlpublic List&lt;User&gt; findAllbyCondinitions1(User param) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); StringBuilder hql = new StringBuilder("from User where 1=1"); if (param.getName() != null &amp;&amp; param.getName().length() != 0) &#123; hql.append(" and name=:name"); &#125; if (param.getTelephone() != null &amp;&amp; param.getTelephone().length() != 0) &#123; hql.append(" and telephone=:telephone"); &#125; list = userDao.findByCoditions(hql.toString(), param); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 查询+多参数 动态hqlpublic List&lt;User&gt; findAllbyCondinitions2(Map&lt;String, Object&gt; param) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); StringBuilder hql = new StringBuilder("from User where 1=1"); if (param.get("name") != null &amp; ((String) param.get("name")).length() != 0) &#123; hql.append(" and name=:name"); &#125; if (param.get("telephone") != null &amp; ((String) param.get("telephone")).length() != 0) &#123; hql.append(" and telephone=:telephone"); &#125; list = userDao.findByCoditions(hql.toString(), param); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 查询分页public List&lt;User&gt; findAllbyCondinitions3(int pageNo, int pageSize) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByPage(pageNo, pageSize); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 根据id降序查询public List&lt;User&gt; findAllbyCondinitions4(int topSize) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByOrder(topSize); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 投影查询public List&lt;Object&gt; findAllbyCondinitions5() &#123; Transaction tx = null; List&lt;Object&gt; list = null; try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByProjection(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 投影查询 object数组public List&lt;Object[]&gt; findAllbyCondinitions6() &#123; Transaction tx = null; List&lt;Object[]&gt; list = null; try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByProjection2(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 投影查询 构造函数对象public List&lt;User&gt; findAllbyCondinitions7() &#123; Transaction tx = null; List&lt;User&gt; list = null; try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByProjection3(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125; 参数绑定形式按参数位置绑定例：Query query = session.createQuery（”from Emp where job=? and salary&gt;?”）； query.setString(0,job);–第一个参数位置为零 query.setDouble(1,salary); 按参数名称绑定 例：Query query = session.createQuery(“from Emp where job=:empJob and salary&gt;:empSalary”); query.setString(“empJob”,empJob); query.setDouble(“empSalary”,empSalary); //注意这里的所有属性包括表名都是.hbm.xml文件映射来的持久化类属性 绑定各种类型的参数 setBoolean():绑定类型为Boolean的参数 setByte():绑定类型为Byte的参数 setDouble():绑定类型为Double的参数 setDate():绑定类型为Date的参数 setString():绑定类型为String的参数 以上方法都有两种重载方式 如： setString(int position,String val);–按位置绑定参数 setString(String name,String val);–按名称绑定参数 setParameter()方法：绑定任意类型参数该方法使用object类型作为HQL参数的类型，当不便指定参数的类型师，使用setParameter()方法 setProperties(直接放入一个对象)赛高123456789101112131415161718192021222324public List&lt;User&gt; findByCoditions(User param) &#123; Query query = this.currentSession().createQuery("from User where name=:name and telephone=:telephone"); query.setProperties(param); // 赛高 return query.list(); &#125; ----- public List&lt;User&gt; findAllbyCondinitions(User param) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByCoditions(param); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list; &#125; //前提是字段一致，并且不为空（动态hql除外） 使用uniqueResult()方法获取唯一结果当查询结果不唯一时，不能使用query.uniqueResult()方法，否则会报错 查询LIST()12345678910111213141516171819202122public List&lt;User&gt; findAllUser() &#123; return this.currentSession().createQuery("from User").list();&#125;--service使用list集合public List&lt;User&gt; findAllUser() &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findAllUser(); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list; &#125; ITERATE()12345678910111213141516171819202122232425262728public Iterator&lt;User&gt; findAllUser_iterate() &#123; return this.currentSession().createQuery("from User").iterate(); &#125; --service使用Iterator&lt;&gt; public Iterator&lt;User&gt; findAllUser_Iterator() &#123; Transaction tx = null; Iterator&lt;User&gt; list = null; try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findAllUser_iterate(); User u = new User(); while (list.hasNext()) &#123; u = list.next(); System.out.println(u.getName() + "艸"); &#125; tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list; &#125; //ITERATE()要比LIST()效率好，但是ITERATE必须在service层输出或赋值，它是先查主键id，再去查找数据 动态查询123456789101112131415161718192021222324252627282930public List&lt;User&gt; findByCoditions(String hql, User param) &#123; Query query = this.currentSession().createQuery(hql); query.setProperties(param); // 赛高 return query.list(); &#125; ---主要的service public List&lt;User&gt; findAllbyCondinitions1(User param) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); StringBuilder hql = new StringBuilder("from User where 1=1"); if (param.getName() != null &amp;&amp; param.getName().length() != 0) &#123; hql.append(" and name=:name"); &#125; if (param.getTelephone() != null &amp;&amp; param.getTelephone().length() != 0) &#123; hql.append(" and telephone=:telephone"); &#125; list = userDao.findByCoditions(hql.toString(), param); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list; &#125; 动态查询 map参数12345678910111213141516171819202122232425262728293031public List&lt;User&gt; findByCoditions(String hql, Map&lt;String, Object&gt; param) &#123; Query query = this.currentSession().createQuery(hql); query.setProperties(param); // 赛高 return query.list(); &#125; ---service public List&lt;User&gt; findAllbyCondinitions2(Map&lt;String, Object&gt; param) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); StringBuilder hql = new StringBuilder("from User where 1=1"); if (param.get("name") != null &amp; ((String) param.get("name")).length() != 0) &#123; hql.append(" and name=:name"); &#125; if (param.get("telephone") != null &amp; ((String) param.get("telephone")).length() != 0) &#123; hql.append(" and telephone=:telephone"); &#125; list = userDao.findByCoditions(hql.toString(), param); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list; &#125; 分页查询主要的是setFirstResult()与setMaxResults()1234public List&lt;User&gt; findByPage(int pageNo, int pageSize) &#123; return this.currentSession().createQuery("from User order by id").setFirstResult((pageNo - 1) * pageSize) .setMaxResults(pageSize).list(); &#125; 获取前几个数据123public List&lt;User&gt; findByOrder(int topSize) &#123; return this.currentSession().createQuery("from User order by id").setMaxResults(topSize).list(); &#125; 投影查询(只获取单个)123456789101112131415161718192021public List findByProjection() &#123; return this.currentSession().createQuery("select name from User").list(); &#125; ---service public List&lt;Object&gt; findAllbyCondinitions5() &#123; Transaction tx = null; List&lt;Object&gt; list = null; try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByProjection(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list; &#125; 投影查询(多个字段)123456789101112public List&lt;Object[]&gt; findByProjection2() &#123; return this.currentSession().createQuery("select name,telephone from User").list(); &#125; ---test public void findPro2() &#123; List&lt;Object[]&gt; list = new UserBiz().findAllbyCondinitions6(); for (Object[] object : list) &#123; System.out.println(object[0] + "\t" + object[1]); &#125; &#125; 将查询结果通过构造函数封装为对象12345678910public List&lt;User&gt; findByProjection3() &#123; return this.currentSession().createQuery("select new User(name,telephone) from User").list(); &#125; --构造方法 public User(String name,String telephone)&#123; this.name=name; this.telephone=telephone; &#125;]]></content>
      <categories>
        <category>SSH</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试26问]]></title>
    <url>%2F2018%2F11%2F08%2F%E9%9D%A2%E8%AF%9526%E9%97%AE%2F</url>
    <content type="text"><![CDATA[请你自我介绍一下自己好吗一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”，企业喜欢有礼貌的求职者。 你觉得你个性上最大的优点是什么沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱。我在xxx经过一到两年的项目实战，加上实习工作，使我适合这份工作 说说你最大的缺点这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。绝对不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌岌可危了。企业喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分，企业喜欢聪明的求职者 你对薪资的要求如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣 回答样本一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。 回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。 你对加班的看法实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献 回答样本：如果工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时我也会提高工作效率，减少不必要的加班 如果通过这次面试我们录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办一段时间发现工作不适合我，有两种情况：①如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处 谈谈你对跳槽的看法①正常的“跳槽”能促进人才合理流动，应该支持。②频繁的跳槽对单位和个人双方都不利，应该反对 工作中难以和同事、上司相处，你该怎么办①我会服从领导的指挥，配合同事的工作。②我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，如果是这样的话我会努力改正。③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，有问题就及时改正。④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的 你对于我们公司了解多少在去公司面试前上网查一下该公司主营业务。如回答：贵公司有意改变策略，加强与国外大厂的OEM合作，自有品牌的部分则透过海外经销商 最能概括你自己的三个词是什么适应能力强，有责任心和做事有始终，结合具体例子向主考官解释 你的业余爱好是什么找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作 作为被面试者给我打一下分试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的） 你为什么要离开原来的公司①回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。②我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，已经达到顶峰，即没有升迁机会 你欣赏哪种性格的人诚实、不死板而且容易相处的人、有“实际行动”的人 你通常如何对待别人的批评①沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。②我会等大家冷静下来再讨论 怎样对待自己的失败我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误 你为什么愿意到我们公司来工作对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”、“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”、“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划 对这项工作，你有哪些可预见的困难①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。②可以尝试迂回战术，说出应聘者对困难所持有的态度——工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服 如果录用了你，你将怎样开展工作 ①如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法。②可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”。分析：这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性，而且重点想要知道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回避的话，此人绝对不会录用了 你希望与什么样的上级共事①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。②最好回避对上级具体的希望，多谈对自己的要求。③如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏 与上级意见不一时，你将怎么办①一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”②如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映 谈谈如何适应办公室工作的新环境①办公室里每个人有各自的岗位与职责，不得擅离岗位。②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。③多请示并及时汇报，遇到不明白的要虚心请教。④抓间隙时间，多学习，努力提高自己的政治素质和业务水平 除了本公司外，还应聘了哪些公司很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉 你还有什么问题要问吗企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心 如果你被录用，何时可以到职大多数企业会关心就职时间，最好是回答“如果被录用的话，到职日可按公司规定上班”，但如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的 为什么选择我们公司曾经在报章杂志看过关于贵公司的报道，与自己所追求的理念有志一同。而贵公司在业界的成绩也是有目共睹的，而且对员工的教育训练、升迁等也都很有制度]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate入门]]></title>
    <url>%2F2018%2F11%2F07%2FHibernate%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[hello，大家好，今天晚上来学习Hibernate 什么是Hibernate框架？Hibernate是一种ORM框架，全称为 Object_Relative DateBase-Mapping，在Java对象与关系数据库之间建立某种映射，以实现直接存取Java对象！比SSM的orm要强 Hibernate优缺点1.Hibernate优点： （1）对象/关系数据库映射(Basic O/R Mapping) 它使用时只需要操纵对象，使开发更对象化，抛弃了数据库中心的思想，完全的面向对象思想。 （2）透明持久化(Persistent) 带有持久化状态的、具有业务功能的单线程对象，此对象生存期很短。这些对象可能是普通的JavaBeans/POJO，这个对象没有实现第三方框架或者接口，唯一特殊的是他们正与（仅仅一个）Session相关联。一旦这个Session被关闭，这些对象就会脱离持久化状态，这样就可被应用程序的任何层自由使用。（例如，用作跟表示层打交道的数据传输对象。） （3）事务Transaction (org.Hibernate.Transaction) 应用程序用来指定原子操作单元范围的对象，它是单线程的，生命周期很短。它通过抽象将应用从底层具体的JDBC、JTA以及CORBA事务隔离开。某些情况下，一个Session之内可能包含多个Transaction对象。尽管是否使用该对象是可选的，但无论是使用底层的API还是使用Transaction对象，事务边界的开启与关闭是必不可少的。 （4）它没有侵入性，即所谓的轻量级框架。 （5）移植性会很好。 （6）缓存机制。提供一级缓存和二级缓存。 （7）简洁的HQL编程。 2.Hibernate缺点： （1）Hibernate在批量数据处理的时候是有弱势。 （2）针对某一对象(单个对象)简单的查\改\删\增，不是批量修改、删除，适合用Hibernate；而对于批量修改、删除，不适合用Hibernate，这也是OR框架的弱点;要使用数据库的特定优化机制的时候，不适合用Hibernate。 Hibernate环境搭建引入相关jar包antlr-2.7.6.jarcommons-collections-3.1.jardom4j-1.6.1.jarhibernate-jpa-2.0-api-1.0.1.Final.jarhibernate3.jarjavassist-3.12.0.GA.jarjta-1.1.jarlog4j-1.2.17.jarojdbc6.jarslf4j-api-1.6.1.jarslf4j-log4j12-1.6.1.jar 创建Hibernate核心配置文件（hibernate.cfg.xml）1234567891011121314151617181920212223242526272829&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt;&lt;session-factory&gt; &lt;!-- 数据库连接 --&gt; &lt;property name="connection.driver_class"&gt; oracle.jdbc.OracleDriver &lt;/property&gt; &lt;property name="connection.url"&gt; jdbc:oracle:thin:@localhost:1521:orcl &lt;/property&gt; &lt;property name="connection.username"&gt;martin&lt;/property&gt; &lt;property name="connection.password"&gt;mpwd&lt;/property&gt; &lt;!-- 辅助参数 --&gt; &lt;!-- &lt;property name="show_sql"&gt;true&lt;/property&gt; --&gt; &lt;property name="format_sql"&gt;true&lt;/property&gt; &lt;property name="dialect"&gt; org.hibernate.dialect.Oracle10gDialect &lt;/property&gt; &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt; &lt;!-- 映射信息 --&gt; &lt;mapping resource="cn/house/pojo/Depts.hbm.xml" /&gt; &lt;mapping resource="cn/house/pojo/Emps.hbm.xml" /&gt; &lt;mapping resource="cn/house/pojo/Employee.hbm.xml" /&gt; &lt;mapping resource="cn/house/pojo/Project.hbm.xml" /&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 创建持久化类和映射文件持久化类需要implement Serializable接口必须就有一个无参数的构造方法 映射文件（为持久化类名+hbm.xml）123456789101112131415&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="cn.hibernatedemo.entity.Emp" table="`EMP`"&gt; &lt;id name="empNo" column="`EMPNO`" type="java.lang.Integer"&gt; &lt;generator class="increment"/&gt; &lt;/id&gt; &lt;property name="empName" type="java.lang.String" column="`ENAME`"/&gt; &lt;property name="job" type="java.lang.String" column="`JOB`"/&gt; &lt;property name="salary" type="java.lang.Double" column="`SAL`"/&gt; &lt;property name="hireDate" type="java.util.Date"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; property属性中可以设置length 以及 not-null 进行持久化操作12345678910111213141516171819202122232425262728293031323334353637383940public void firstShow() &#123; Configuration conf = null; // 加载hibernate配置文件 SessionFactory sf = null; // 创建session 会话接口 Session session = null; //session实施持久化操作关键api Transaction tx = null; //事务控制 try &#123; conf = new Configuration().configure(); sf = conf.buildSessionFactory(); session = sf.getCurrentSession(); //推荐使用 /*session = sf.openSession(); *///比较垃圾 tx = session.beginTransaction(); //开启事务 User user=new User(); user.setId((byte)2); user.setIsadmin("yes"); user.setName("樊可"); user.setPassword("123456"); user.setTelephone("15035042771"); user.setUsername("悲伤的橙子子树"); /*Dept dept=new Dept(); dept.setDeptName("狙击部"); dept.setDeptNo((byte)50); dept.setLocation("永济市");*/ session.save(user); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if(tx!=null)&#123; tx.rollback(); &#125; &#125;/*finally &#123; session.close(); &#125;*/ &#125; 注意 ：不管是查询还是更新都要开启事务，session会自动关闭 简化一下util创建HibernateUtil.java文件1234567891011121314151617181920212223242526272829package cn;import org.hibernate.HibernateException;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtil &#123; private static Configuration conf; private final static SessionFactory sf; static &#123; try &#123; conf = new Configuration().configure(); sf = conf.buildSessionFactory(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); throw new ExceptionInInitializerError(e); &#125; &#125; private HibernateUtil()&#123;&#125; public static Session currentSession()&#123; return sf.getCurrentSession(); &#125;&#125; dao层创建BaseDao.java123456789package cn.dao;import org.hibernate.Session;import cn.HibernateUtil;public class BaseDao &#123; public Session currentSession()&#123; return HibernateUtil.currentSession(); &#125;&#125; 用的时候直接继承BaseDao既可 按主键查询GET方法123public User getUser(Serializable id)&#123; return (User)currentSession().get(User.class, id);&#125; LOAD方法(需要在会话关闭之前测试查询)123public User loadUser(Serializable id)&#123; return (User)currentSession().load(User.class, id);&#125; 增加操作1234public void save(User user)&#123; currentSession().save(user);&#125;--还有个save-update(他会找主键，如果主键存在，那就修改，如果不存在，就添加) 修改操作1234public void update(User user)&#123; currentSession().update(user);&#125;--还有个save-update(他会找主键，如果主键存在，那就修改，如果不存在，就添加) 删除操作123public void delete(User user)&#123; currentSession().delete(user);&#125; .hbm.xml文件（ dynamic-update=”true”）表示动态更新，只更新变化的字段]]></content>
      <categories>
        <category>SSH</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PL/SQL编程]]></title>
    <url>%2F2018%2F11%2F07%2FPL-SQL%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是PL/SQL呢？ PL/SQL是 Procedure Language &amp; Structured Query Language 的缩写。ORACLE的SQL是支持ANSI(American national Standards Institute)和ISO92 (International Standards Organization)标准的产品。PL/SQL是对SQL语言存储过程语言的扩展。从ORACLE6以后，ORACLE的RDBMS附带了PL/SQL。它现在已经成为一种过程处理语言，简称PL/SQL。目前的PL/SQL包括两部分，一部分是数据库引擎部分；另一部分是可嵌入到许多产品（如C语言，JAVA语言等）工具中的独立引擎。可以将这两部分称为：数据库PL/SQL和工具PL/SQL。两者的编程非常相似。都具有编程结构、语法和逻辑机制。工具PL/SQL另外还增加了用于支持工具（如ORACLE Forms）的句法，如：在窗体上设置按钮等 PL/SQL的优点有利于客户/服务器环境应用的运行对于客户/服务器环境来说，真正的瓶颈是网络上。无论网络多快，只要客户端与服务器进行大量的数据交换。应用运行的效率自然就回受到影响。如果使用PL/SQL进行编程，将这种具有大量数据处理的应用放在服务器端来执行。自然就省去了数据在网上的传输时间。 适合于客户环境PL/SQL由于分为数据库PL/SQL部分和工具PL/SQL。对于客户端来说，PL/SQL可以嵌套到相应的工具中，客户端程序可以执行本地包含PL/SQL部分，也可以向服务发SQL命令或激活服务器端的PL/SQL程序运行。 过程化PL/SQL是Oracle在标准SQL上的过程性扩展，不仅允许在PL/SQL程序内嵌入SQL语句，而且允许使用各种类型的条件分支语句和循环语句，可以多个应用程序之间共享其解决方案。 模块化PL/SQL程序结构是一种描述性很强、界限分明的块结构、嵌套块结构，被分成单独的过程、函数、触发器，且可以把它们组合为程序包，提高程序的模块化能力。 运行错误的可处理性使用PL/SQL提供的异常处理（EXCEPTION），开发人员可集中处理各种ORACLE错误和PL/SQL错误，或处理系统错误与自定义错误，以增强应用程序的健壮性。 提供大量内置程序包ORACLE提供了大量的内置程序包。通过这些程序包能够实现DBS的一些低层操作、高级功能，不论对DBA还是应用开发人员都具有重要作用。 当然还有其它的一些优点如：更好的性能、可移植性和兼容性、可维护性、易用性与快速性等。 PL/SQL可用的SQL语句PL/SQL是ORACLE系统的核心语言，现在ORACLE的许多部件都是由PL/SQL写成。在PL/SQL中可以使用的SQL语句有： INSERT，UPDATE，DELETE，SELECT INTO，COMMIT，ROLLBACK，SAVEPOINT。 提示：在 PL/SQL中只能用 SQL语句中的 DML 部分，不能用 DDL 部分，如果要在PL/SQL中使用DDL(如CREATE table 等)的话，只能以动态的方式来使用。 一个PL/SQL块的组成（由三部分）1234567DECLARE --声明部分: 在此声明PL/SQL用到的变量,类型及游标，以及局部的存储过程和函数 BEGIN -- 执行部分: 过程及SQL 语句 , 即程序的主要部分 EXCEPTION -- 执行异常部分: 错误处理 END; 常量和变量的声明ename varchar2【(20)】 【:=’EricHu’】;· ename表示变量名称· varchar2变量类型以及大小· :=’EricHu’为初始化变量值 PL/SQL程序设计中的标识符定义与SQL 的标识符定义的要求相同。要求和限制有：1.标识符名不能超过30字符； 2.第一个字符必须为字母； 3.不分大小写； 4.不能用’-‘(减号); 5.不能是SQL保留字。 提示: 一般不要把变量名声明与表中字段名完全一样,如果这样可能得到不正确的结果. 变量与常量的赋值1）variable := expression ; variable 是一个PL/SQL变量, expression 是一个PL/SQL 表达式，也可以直接赋一个值2） 字符及数字运算特点空值加数字仍是空值：NULL + &lt; 数字&gt; = NULL空值加（连接）字符，结果为字符：NULL || &lt;字符串&gt; = &lt; 字符串&gt;3）数据库赋值12345678910/*数据库赋值是通过 SELECT语句来完成的，每次执行 SELECT语句就赋值一次，一般要求被赋值的变量与SELECT中的列名要一一对应*/DECLARE emp_id emp.empno%TYPE :=7788; emp_name emp.ename%TYPE; wages emp.sal%TYPE; BEGIN SELECT ename, NVL(sal,0) + NVL(comm,0) INTO emp_name, wages FROM emp WHERE empno = emp_id; DBMS_OUTPUT.PUT_LINE(emp_name||'----'||to_char(wages)); END; 注释12345678910111213141516171819在PL/SQL里，可以使用两种符号来写注释，即：使用双 ‘-‘ ( 减号) 加注释 PL/SQL允许用 – 来写注释，它的作用范围是只能在一行有效。如： V_Sal NUMBER(12,2); -- 人员的工资变量。 使用 /* */ 来加一行或多行注释，如：/***********************************************//* 文件名： department_salary.sql *//* 作 者： 樊可 *//* 时 间： 2018-11-7 *//***********************************************/ PL/SQL数据类型标量数据类型小声bb （其实就是普通数据类型） LOB数据类型存储大数据类型，详情请看Oracle数据库基础 属性类型1）%TYPE定义一个变量，其数据类型与已经定义的某个数据变量(尤其是表的某一列)的数据类型相一致，这时可以使用%TYPE。 使用%TYPE特性的优点在于： 1.所引用的数据库列的数据类型可以不必知道； 2.所引用的数据库列的数据类型可以实时改变，容易保持一致，也不用修改PL/SQL程序。12345678910111213DECLARE -- 用%TYPE 类型定义与表相配的字段 TYPE T_Record IS RECORD( T_no emp.empno%TYPE, T_name emp.ename%TYPE, T_sal emp.sal%TYPE ); -- 声明接收数据的变量 v_emp T_Record; BEGIN SELECT empno, ename, sal INTO v_emp FROM emp WHERE empno=7788; DBMS_OUTPUT.PUT_LINE (TO_CHAR(v_emp.t_no)||' '||v_emp.t_name||' ' || TO_CHAR(v_emp.t_sal)); END; 2）%ROWTYPEPL/SQL 提供%ROWTYPE操作符, 返回一个记录类型, 其数据类型和数据库表的数据结构相一致。 使用%ROWTYPE特性的优点在于： l 所引用的数据库中列的个数和数据类型可以不必知道； l 所引用的数据库中列的个数和数据类型可以实时改变，容易保持一致，也不用修改PL/SQL程序。1234567DECLARE v_empno emp.empno%TYPE :=&amp;no; rec emp%ROWTYPE; BEGIN SELECT * INTO rec FROM emp WHERE empno=v_empno; DBMS_OUTPUT.PUT_LINE('姓名:'||rec.ename||'工资:'||rec.sal||'工作时间:'||rec.hiredate); END; PL/SQL控制语句条件控制IF语句）12345678DECLAREv_countResult NUMBER ;BEGINSELECT COUNT(empno) INTO v_countResult FROM emp ;IF v_countResult &gt; 10 THENDBMS_OUTPUT.put_line('EMP表的记录大于10条。') ;END IF ;END ; IF…ELSE语句）12345678910DECLAREv_countResult NUMBER ;BEGINSELECT COUNT(deptno) INTO v_countResult FROM dept ;IF v_countResult &gt; 10 THENDBMS_OUTPUT.put_line('DEPT表的记录大于10条。') ;ELSEDBMS_OUTPUT.put_line('DEPT表的记录小于10条。') ;END IF ;END ; IF…ELSIF…ELSE语句）123456789101112DECLAREv_countResult NUMBER ;BEGINSELECT COUNT(empno) INTO v_countResult FROM emp ;IF v_countResult &gt; 10 THENDBMS_OUTPUT.put_line('EMP表的记录大于10条。') ;ELSIF v_countResult &lt; 10 THENDBMS_OUTPUT.put_line('EMP表的记录小于10条。') ;ELSEDBMS_OUTPUT.put_line('EMP表的记录等于10条。') ;END IF ;END ; CASE语句）1234567CASE 条件表达式 WHEN 条件表达式结果1 THEN 语句段1 WHEN 条件表达式结果2 THEN 语句段2 [ELSE]END CASE 循环控制用于重复执行的系列语句。包括LOOP和EXIT语句，使用EXIT语句可以立即退出循环; 使用EXIT WHEN 语句可以根据条件结束循环。有3种类型循环，包括LOOP循环、WHILE循环、FOR循环。 LOOP）1234LOOP要执行的语句;EXIT WHEN &lt;条件语句&gt; --条件满足，退出循环语句END LOOP; WHILE）123WHILE &lt;布尔表达式&gt; LOOP要执行的语句;END LOOP; FOR）123FOR 循环计数器 IN [REVERSE] 下限 .... 上限 LOOP要执行的语句;END LOOP; 异常处理PL/SQL预定义异常1234567891011121314151617181920212223242526272829303132333435363738ACCESS_INTO_NULL在未初始化对象时出现CASE_NOT_FOUNDCASE语句中的选项与用户输入的数据不匹配时出现COLLECTION_IS_NULL给尚未初始化的表或数组赋值时出现CORSOR_ALREADY_OPEN在用户试图重新打开已经打开的游标时出现。在重新打开游标前必须先将其关闭DUP_VAL_ON_INDEX在用户试图将重复的值存储在使用唯一索引的数据库列中时出现INVALID_CURSOR在执行非法游标运算（如打开一个尚未打开的游标）时出现INVALID_NUMBER在将字符串转换为数字时出现LOGIN_DENIED在输入的用户名或密码无效时出现NO_DATA_FOUND在表中不存在请求的行时出现。此外，当程序引用已经删除的元素时，也会引发NO_DATA_FOUND异常STORAGE_ERROR在内存损环或PL/SQL耗尽内存时出现TOO_MANY_ROWS在执行SELECT INTO语句后返回多行时出现VALUE_ERROR产生大小限制错误时出现。例如，变量中的列值超出变量的大小ZERO_DIVIDE以零作为除数时出现 异常处理语法1234567891011BEGINsequence_of_statements;EXCEPTIONWHEN &lt;exception_name1&gt; THENsequence_of_statements;WHEN &lt;exception_name2&gt; THENsequence_of_statements;WHEN OTHERS THEN --这里的OTHERS处理程序除之前异常类型外的所有异常。PL/SQL块只能有一个OTHERSsequence_of_statements;END;--可以使用函数SQLCODE和SQLERRM来返回错误代码和错误文本信息。 处理用户自定义异常（1）在PL/SQL块的定义部分定义异常情况： &lt;异常情况&gt; EXCEPTION; （2）抛出异常情况： RAISE &lt;异常情况&gt;; （3）在PL/SQL块的异常情况处理部分对异常情况做出相应的处理。123456789101112131415161718例，查询编号为7788的雇员的福利补助comm列。DECLAREv_comm employee.comm%TYPE;e_comm_is_null EXCEPTION; --定义异常类型变量BEGINSELECT comm INTO v_comm FROM employee WHERE empno=7788;IF v_comm IS NULL THENRAISE e_comm_is_null;END IF;EXCEPTIONWHEN NO_DATA_FOUND THENDBMS_OUTPUT.PUT_LINE(‘雇员不存在！错误为：’||SQLCODE||SQLERRM);WHEN E_COM_IS_NULL THENDBMS_OUTPUT.PUT_LINE(‘该雇员无补助！’);WHEN OTHERS THENDBMS_OUTPUT.PUT_LINE(‘出现其他异常’);END; RAISE_APPLICATION_ERRORRAISE_APPLICATION_ERROR存储过程可以重新定义异常错误消息，为应用程序提供一种与Oracle交互的方法。12345678DECLARE......BEGIN......IF v_com IS NULL THENRAISE_APPLICATION_ERROR(-20001,’该雇员无补助’);END IF;END; 游标显示游标显式游标的使用步聚： 1）声明游标 CURSOR cursor_name [(parameter [,paramter]….)] [RETURN return_type] IS select_statements; –cursor_name指游标的名称。 –parameter用于为游标指定输入参数。在指定数据类型时，不能使用长度约束。 –return_type用于定义游标提取的行的类型。 –select_statement 指游标定义的查询语句。 2）打开游标 OPEN cursor_name[ (parameters) ]; 3）提取游标 FETCH cursor_name INTO variables; –variables是变量名 4）关闭游标 CLOSE cursor_name; 例子 1234567891011121314DECLAREname employee.ename%TYPE;sal employee.sal%TYPE; --定义两个变量来存放ename和sal的内容CURSOR emp_cursor --声明游标IS SELECT ename,sal FROM employee;BEGINOPEN emp_cursor;LOOPFETCH emp_cursor INTO name, sal;EXIT WHEN emp_cursor%NOTFOUND;DBMS_OUTPUT.PUT_LINE(‘第’||emp_cursor%ROWCOUNT||’个雇员：’||name||sal);END LOOP;CLOSE emp_cursor;END; 显式游标属性1）%FOUND：只有在DML语句影响一行或多行时，%FOUND属性才返回TRUE; 2）%NOTFOUND：%NOTFOUND属性与%FOUND属性的作用正好相反。如果DML语句没有影响任何行，则%NOTFOUND属性返回TRUE; 3）%ROWCOUNT：%ROWCOUNT属性返回DML语句影响的行数。如果DML语句没有影响任何行，则%ROWCOUNT属性将返回0; 4）%ISOPEN：%ISOPEN属性返回游标是否已打开。 使用显式游标删除或更新使用游标时，如果处理过程中需要删除或更新行，在定义游标时必须使用SELECT….FOR UPDATE语句; 而在执行DELETE和UPDATE时使用WHERE CURRENT OF子句指定游标的当前行。123456789声明更新游标语法：CURSOR cursor_name IS select_statement FOR UPDATE [OF culumns];--SELECT... FOR UPDATE[OF columns]为更新查询，锁定选择的行。[OF columns]可以不是SELECT后的列--（1）当选择单表更新查询时，可以受省略OF子句;--（2）当选择多个表更新查询时，被锁定的行来源于OF 子句后声明的列所在的表中的行。就是你选哪个表的属性就更新哪个表 例子123456DECLARECURSOR emp_cursor IS SELECT ename, sal FROM employee e INNER JOIN dept d ON e.deptno= d.deptnoFOR UPDATE OF SAL;....UPDATE employee SET sal=sal+100 WHERE CURRENT OF emp_cursor; 使用循环游标简化游标的读取1234FOR record_index IN cursor_nameLOOPexecutable_statementsEND LOOP; –record_index是PL/SQL声明的记录变量。此变量的属性声明为%ROWTYPE类型作用域在循环之内。 循环游标的特性：1）在游标中提取了所有记录之后自动终止。2）提取和处理游标中的每一条记录。3）如果在提取记录之后%NOTFOUND属性返回TRUE，则终止循环。4）如果未返回行，则不进入循环。12345678910DECLARECURSOR emp_cursor IS SELECT ename, sal FROM employee;BEGINFOR emp_record IN emp_cursor LOOPDBMS_OUTPUT.PUT_LINE(‘第’||emp_cursor%ROWCOUNT||’个雇员：’||emp_record.ename||emp_record.sal);END LOOP;END; 存储过程子程序子程序是已命名的PL/SQL块，它们存储在数据库中，包括存储过程和函数。使用存储过程执行操作，使用函数执行操作并返回值1.声明部分，包括类型、游标、常量、异常和嵌套子程序的使用。退出子程序后雩不复存在。 2.可执行部分，包括赋值、控制执行过程以及操纵Oracle数据的语句。 3.异常处理部分，包括异常处理程序，负责处理执行存储过程中出现的异常。 子程序的优点： 1）模块化：通过子种序，可以将程序分解为可管理的、明确的逻辑模块。 2）可重用性：子程序在创建并执行后，就可以在任意数目的应用程序中使用。 3）可维护性：子程序可以简化维护操作，因为如果一个子程序受到影响，则只需要修改该子程序的定义。 4）安全性：用户可以设置权限，使得访问数据的唯一方式就是用户提供的存储过程。这样也可以保证正确性。 创建存储过程123456789CREATE [OR REPLACE] PROCEDURE procedure_name[(parameter_list)][IS|AS][local_declarations]BEGINexecetable_statements[EXCEPTION][exception_handlers]END [procedure_name]; –procedure_name：存储过程的名称。 –parameter_list：参数列表，可选。 –local_declarations：局部声明，可选。 –executable_statements：可执行语句。 –excetption_handlers：异常处理程序，可选。 –OR REPLACE：可选。如果包含OR REPLACE语句，当系统中有这个存储过程时，将覆盖。如果不包含，当系统中有这个存储过程时，将报异常。 –声明时，数据类型不能带大小。如NUMBER(4)，只能写成NUMBER。 –声明时可以给定默认值，如：job VARCHAR2 DEFAULT ‘CLEAK’ 如果调用时不揭定该参数，自动默认值。 调用存储过程（需要通过授权才能使用）用命令调用EXEC[UTE] procedure_name (parameter_list);–EXECUTE：执行命令，可以缩写为EXEC 参数的传递方式：按位置传递，例：EXEC add_employee(1111,’MARY’,2000,’MANAGER’,10); 按名称传递，即在调用时按名称对应。名称的对应关系是最重要的，次序不重要。 例：EXEC add_employee(dno=&gt;10,name=&gt;’MARY’,salary=&gt;2000,job=&gt;’MANAGER’); 还有个混合方法传递，如果有一个是按名称传递的，那后面的参数都是按位置传 PL/SQL块中使用123BEGIN add_employee(2111,’MARY’,2000,’MANAGER’,10);END; 参数模式在存储过程中参数传递的模式有3种：IN、OUT、IN OUT，即输入 、输出、输入/输出参数。 IN模式只能将实参传递给形参，进入函数内部，函数返回时，实参值不变。结论参数传递 模式。 OUT模式会忽略调用时的实参值，在函数内部可写，函数返回时实参的值改变。 IN OUT模式具有前再种模式的特性。即调用时，实参的值总是传递给形参;结束时，形参的值传递给实参 可以在参数列表中为IN参数赋默认值。但是OUT和INT OUT参数不可以赋默认值。 12345678CREATE OR REPLACE PROCEDURE QueryEmp(v_empno IN employee.empno%TYPE DEFAULT 1000, --默认编号为1000v_ename OUT employee.ename%TYPE,v_sal IN OUT employee.sal%TYPE)AS...... 存储过程的访问权限–授权GRANT EXECUTE ON add_employee TO A_oe; –撤销REVOKE EXECUTE ON add_employee FROM A_oe; –删除存储过程DROP PROCEDURE procedure_name; 使用存储过程 返回游标12345678910111213141516171819202122--存储过程CREATE OR REPLACE PROCEDURE test_weber_proc(out_result_cursor OUT Sys_Refcursor) ISBegin OPEN out_result_cursor FOR SELECT * FROM employee;END;--调用DECLAREtype cur is ref cursor;--e_result SYS_REFCURSOR;c1 cur;arr employee%ROWTYPE;begintest_weber_proc(c1);loopFETCH c1 INTO arr;dbms_output.put_line(arr.ENAME || arr.sal);EXIT WHEN c1%notfound;END loop;CLOSE c1;END; 啊！！ 拜拜]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[人间失格]]></title>
    <url>%2F2018%2F11%2F07%2F%E4%BA%BA%E9%97%B4%E5%A4%B1%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[日日重复同样的事，遵循着昨日相同的惯例，若能避开猛烈的狂喜，自然也不会有悲痛的来袭 日日重复同样的事，遵循着与昨日相同的惯例，若能避开猛烈的狂喜 ，自然也不会有悲痛的来袭。相互欺骗，却又令人惊奇地不受到任何伤害，甚至于就好像没有察觉到彼此在欺骗似的，这种不加掩饰从而显得清冽、豁达的互不信任的例子，在人类生活中比比皆是。倒是那些彼此欺骗，却清冽而开朗地生存着，抑或是有信心清冽而开朗地生活下去的人，才是令人费解的。 世间。我开始隐隐约约明白了世间的真相，它就是个人与个人之间的争斗，而且是即时即地的斗争。人需要在那种争斗中当场取胜。人是绝不可能服从他人的。即使是当奴隶，也会以奴隶的方式进行卑屈的反击。]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整合]]></title>
    <url>%2F2018%2F11%2F06%2F%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[配置文件整合（CTRL C CTRL V）根据项目实际情况而定WEB.XML12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;CG14&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContextl.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.util.Log4jConfigListener &lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; applicationContextl.XML1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd"&gt; &lt;context:component-scan base-package="cn.appsys.service"&gt;&lt;/context:component-scan&gt; &lt;context:component-scan base-package="cn.appsys.controller"&gt;&lt;/context:component-scan&gt; &lt;!-- 读取数据库配置文件 --&gt; &lt;context:property-placeholder location="classpath:database.properties"/&gt; &lt;!-- JNDI获取数据源(使用dbcp连接池) --&gt; &lt;bean class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" scope="singleton" id="dataSource"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;user&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"/&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"/&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"/&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"/&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"/&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;"/&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;"/&gt; &lt;!-- sql 心跳 --&gt; &lt;property name= "testWhileIdle" value="true"/&gt; &lt;property name= "testOnBorrow" value="false"/&gt; &lt;property name= "testOnReturn" value="false"/&gt; &lt;property name= "validationQuery" value="select 1"/&gt; &lt;property name= "timeBetweenEvictionRunsMillis" value="60000"/&gt; &lt;property name= "numTestsPerEvictionRun" value="$&#123;maxActive&#125;"/&gt; &lt;/bean&gt; &lt;!-- 数据源在配置文件中 --&gt; &lt;!-- &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- 使用jndi数据源 在tomcat content.xml配置 --&gt; &lt;!-- &lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt; &lt;property name="jndiName"&gt; &lt;value&gt;java:comp/env/jndi/smbms&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- 配置SqlSessionFactoryBean --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;property name="configLocation" value="classpath:mybatis-configl.xml"&gt;&lt;/property&gt; &lt;property name="mapperLocations"&gt; &lt;list&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Dao --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.appsys.dao.*"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务增强 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置切面 --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression="execution(* cn.appsys.service..*.*(..))" id="myPoint" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="myPoint" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; database.properties(mysql)1234567891011driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/appinfodb?useUnicode=true&amp;characterEncoding=utf-8user=rootpassword=rootminIdle=45maxIdle=50initialSize=5maxActive=100maxWait=100removeAbandonedTimeout=180removeAbandoned=true log4j.properties123456789101112131415161718192021222324252627282930313233343536log4j.rootLogger=DEBUG,CONSOLE,file#log4j.rootLogger=ERROR,ROLLING_FILElog4j.logger.cn.smbms.dao=debuglog4j.logger.com.ibatis=debug log4j.logger.com.ibatis.common.jdbc.SimpleDataSource=debug log4j.logger.com.ibatis.common.jdbc.ScriptRunner=debug log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=debug log4j.logger.java.sql.Connection=debug log4j.logger.java.sql.Statement=debug log4j.logger.java.sql.PreparedStatement=debug log4j.logger.java.sql.ResultSet=debug log4j.logger.org.tuckey.web.filters.urlrewrite.UrlRewriteFilter=debug####################################################################################### Console Appender \u65e5\u5fd7\u5728\u63a7\u5236\u8f93\u51fa\u914d\u7f6e######################################################################################log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.Threshold=errorlog4j.appender.CONSOLE.Target=System.outlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern= [%p] %d %c - %m%n####################################################################################### DailyRolling File \u6bcf\u5929\u4ea7\u751f\u4e00\u4e2a\u65e5\u5fd7\u6587\u4ef6\uff0c\u6587\u4ef6\u540d\u683c\u5f0f:log2009-09-11######################################################################################log4j.appender.file=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.file.DatePattern=yyyy-MM-ddlog4j.appender.file.File=log.loglog4j.appender.file.Append=truelog4j.appender.file.Threshold=errorlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-M-d HH:mm:ss&#125;%x[%5p](%F:%L) %m%nlog4j.logger.com.opensymphony.xwork2=error mybatis-configl.XML123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 引入database.properties文件 --&gt; &lt;!-- 配置mybatis的log实现为LOG4J --&gt; &lt;settings&gt; &lt;!-- &lt;setting name="logImpl" value="LOG4J" /&gt; --&gt; &lt;setting name="lazyLoadingEnabled" value="false"/&gt; &lt;setting name="autoMappingBehavior" value="FULL"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name="cn.appsys.pojo"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; springmvc-servlet.XML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 配置处理器映射 HandlerMapping --&gt; &lt;!-- &lt;bean name="/index.html" class="cn.smbms.controller.IndexController" /&gt; --&gt; &lt;!-- &lt;bean name="/welcome" class="cn.smbms.controller.IndexController" /&gt; --&gt; &lt;!-- &lt;bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;/bean&gt; --&gt; &lt;context:component-scan base-package="cn.appsys.controller"/&gt; &lt;!-- 自定义转换器 --&gt; &lt;!-- &lt;bean id="myConversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;bean class="cn.smbms.tools.StringToDateConverter"&gt; &lt;constructor-arg type="java.lang.String" value="yyyy-MM-dd" /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- 拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/sys/**"/&gt; &lt;bean class="cn.appsys.interceptor.SysInterceptor"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;mvc:annotation-driven&gt; &lt;!-- 消息转换器 --&gt; &lt;mvc:message-converters&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean class="com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="features"&gt; &lt;list&gt; &lt;value&gt;WriteDateUseDateFormat&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 完成视图的对应 --&gt; &lt;!-- 对转向页面的路径解析。prefix：前缀， suffix：后缀 --&gt; &lt;!-- &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; --&gt; &lt;!-- 配置多视图解析器 ：允许统一的内容数据呈现在不同的view中 --&gt; &lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt; &lt;!-- 支持参数匹配 --&gt; &lt;property name="favorParameter" value="true"/&gt; &lt;property name="mediaTypes"&gt; &lt;map&gt; &lt;entry key="html" value="text/html;charset=UTF-8"&gt;&lt;/entry&gt; &lt;entry key="json" value="application/json;charset=UTF-8"&gt;&lt;/entry&gt; &lt;entry key="xml" value="application/xml;charset=UTF-8"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 网页视图解析器 --&gt; &lt;property name="viewResolvers"&gt; &lt;list&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;mvc:resources location="/statics/" mapping="/statics/**"&gt;&lt;/mvc:resources&gt; &lt;!-- 全局异常的配置 --&gt; &lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt; &lt;property name="exceptionMappings"&gt; &lt;props&gt; &lt;prop key="java.lang.RuntimeException"&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置MulitpartResolver，用于文件上传 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="5000000" /&gt; &lt;property name="defaultEncoding" value="utf-8" /&gt; &lt;/bean&gt;&lt;/beans&gt; Logger(AOP)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package cn.appsys.tools;import java.util.Arrays;import org.apache.log4j.Logger;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;/** * 注解定义切面 * @author F117 * */@Aspectpublic class UserServiceLogger &#123; private static final Logger LOGGER=Logger.getLogger(UserServiceLogger.class); @Pointcut("execution(* cn.service..*.*(..)) ") public void pointcut()&#123;&#125; /** * 前置增强 * @param jp */ @Before("pointcut()") public void before(JoinPoint jp) &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法入参：" + Arrays.toString(jp.getArgs())); &#125; /** * 后置增强 * @param jp * @param returnValue */ @AfterReturning(pointcut = "pointcut()", returning = "returnValue") public void afterReturning(JoinPoint jp, Object returnValue) &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法返回值：" + returnValue); &#125; /** * 最终增强 * @param jp */ @After("pointcut()") public void afterLogger(JoinPoint jp) &#123; LOGGER.info(jp.getSignature().getName() + " 方法结束执行。"); &#125; /** * 异常增强 * @param jp * @param e */ @AfterThrowing(value="pointcut()", throwing = "e") public void afterThrowing(JoinPoint jp, RuntimeException e) &#123; LOGGER.error(jp.getSignature().getName() + " 方法发生异常：" + e); &#125; /** * 环绕增强 * @param jp * @return * @throws Throwable */ @Around("pointcut()") public Object aroundLogger(ProceedingJoinPoint jp) throws Throwable &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法入参：" + Arrays.toString(jp.getArgs())); try &#123; Object result = jp.proceed(); LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法返回值：" + result); return result; &#125; catch (Throwable e) &#123; LOGGER.error(jp.getSignature().getName() + " 方法发生异常：" + e); throw e; &#125; finally &#123; LOGGER.info(jp.getSignature().getName() + " 方法结束执行。"); &#125; &#125; &#125; Controller增删改查123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728package cn.appsys.controller.developer;import java.io.File;import java.util.Date;import java.util.HashMap;import java.util.List;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import org.apache.commons.io.FilenameUtils;import org.apache.log4j.Logger;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;import com.alibaba.fastjson.JSONArray;import com.mysql.jdbc.StringUtils;import cn.appsys.pojo.AppCategory;import cn.appsys.pojo.AppInfo;import cn.appsys.pojo.AppVersion;import cn.appsys.pojo.DataDictionary;import cn.appsys.pojo.DevUser;import cn.appsys.service.developer.AppCategoryService;import cn.appsys.service.developer.AppInfoService;import cn.appsys.service.developer.AppVersionService;import cn.appsys.service.developer.DataDictionaryService;import cn.appsys.tools.Constants;import cn.appsys.tools.PageSupport;@Controller@RequestMapping(value="/dev/flatform/app")public class AppController &#123; private Logger logger = Logger.getLogger(AppController.class); @Resource private AppInfoService appInfoService; @Resource private DataDictionaryService dataDictionaryService; @Resource private AppCategoryService appCategoryService; @Resource private AppVersionService appVersionService; @RequestMapping(value="/list") public String getAppInfoList(Model model,HttpSession session, @RequestParam(value="querySoftwareName",required=false) String querySoftwareName, @RequestParam(value="queryStatus",required=false) String _queryStatus, @RequestParam(value="queryCategoryLevel1",required=false) String _queryCategoryLevel1, @RequestParam(value="queryCategoryLevel2",required=false) String _queryCategoryLevel2, @RequestParam(value="queryCategoryLevel3",required=false) String _queryCategoryLevel3, @RequestParam(value="queryFlatformId",required=false) String _queryFlatformId, @RequestParam(value="pageIndex",required=false) String pageIndex)&#123; logger.info("getAppInfoList -- &gt; querySoftwareName: " + querySoftwareName); logger.info("getAppInfoList -- &gt; queryStatus: " + _queryStatus); logger.info("getAppInfoList -- &gt; queryCategoryLevel1: " + _queryCategoryLevel1); logger.info("getAppInfoList -- &gt; queryCategoryLevel2: " + _queryCategoryLevel2); logger.info("getAppInfoList -- &gt; queryCategoryLevel3: " + _queryCategoryLevel3); logger.info("getAppInfoList -- &gt; queryFlatformId: " + _queryFlatformId); logger.info("getAppInfoList -- &gt; pageIndex: " + pageIndex); Integer devId = ((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId(); List&lt;AppInfo&gt; appInfoList = null; List&lt;DataDictionary&gt; statusList = null; List&lt;DataDictionary&gt; flatFormList = null; List&lt;AppCategory&gt; categoryLevel1List = null;//列出一级分类列表，注：二级和三级分类列表通过异步ajax获取 List&lt;AppCategory&gt; categoryLevel2List = null; List&lt;AppCategory&gt; categoryLevel3List = null; //页面容量 int pageSize = Constants.pageSize; //当前页码 Integer currentPageNo = 1; if(pageIndex != null)&#123; try&#123; currentPageNo = Integer.valueOf(pageIndex); &#125;catch (NumberFormatException e) &#123; // TODO: handle exception e.printStackTrace(); &#125; &#125; Integer queryStatus = null; if(_queryStatus != null &amp;&amp; !_queryStatus.equals(""))&#123; queryStatus = Integer.parseInt(_queryStatus); &#125; Integer queryCategoryLevel1 = null; if(_queryCategoryLevel1 != null &amp;&amp; !_queryCategoryLevel1.equals(""))&#123; queryCategoryLevel1 = Integer.parseInt(_queryCategoryLevel1); &#125; Integer queryCategoryLevel2 = null; if(_queryCategoryLevel2 != null &amp;&amp; !_queryCategoryLevel2.equals(""))&#123; queryCategoryLevel2 = Integer.parseInt(_queryCategoryLevel2); &#125; Integer queryCategoryLevel3 = null; if(_queryCategoryLevel3 != null &amp;&amp; !_queryCategoryLevel3.equals(""))&#123; queryCategoryLevel3 = Integer.parseInt(_queryCategoryLevel3); &#125; Integer queryFlatformId = null; if(_queryFlatformId != null &amp;&amp; !_queryFlatformId.equals(""))&#123; queryFlatformId = Integer.parseInt(_queryFlatformId); &#125; //总数量（表） int totalCount = 0; try &#123; totalCount = appInfoService.getAppInfoCount(querySoftwareName, queryStatus, queryCategoryLevel1, queryCategoryLevel2, queryCategoryLevel3, queryFlatformId, devId); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //总页数 PageSupport pages = new PageSupport(); pages.setCurrentPageNo(currentPageNo); pages.setPageSize(pageSize); pages.setTotalCount(totalCount); int totalPageCount = pages.getTotalPageCount(); //控制首页和尾页 if(currentPageNo &lt; 1)&#123; currentPageNo = 1; &#125;else if(currentPageNo &gt; totalPageCount)&#123; currentPageNo = totalPageCount; &#125; try &#123; appInfoList = appInfoService.getAppInfoList(querySoftwareName, queryStatus, queryCategoryLevel1, queryCategoryLevel2, queryCategoryLevel3, queryFlatformId, devId, currentPageNo, pageSize); statusList = this.getDataDictionaryList("APP_STATUS"); flatFormList = this.getDataDictionaryList("APP_FLATFORM"); categoryLevel1List = appCategoryService.getAppCategoryListByParentId(null); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; model.addAttribute("appInfoList", appInfoList); model.addAttribute("statusList", statusList); model.addAttribute("flatFormList", flatFormList); model.addAttribute("categoryLevel1List", categoryLevel1List); model.addAttribute("pages", pages); model.addAttribute("queryStatus", queryStatus); model.addAttribute("querySoftwareName", querySoftwareName); model.addAttribute("queryCategoryLevel1", queryCategoryLevel1); model.addAttribute("queryCategoryLevel2", queryCategoryLevel2); model.addAttribute("queryCategoryLevel3", queryCategoryLevel3); model.addAttribute("queryFlatformId", queryFlatformId); //二级分类列表和三级分类列表---回显 if(queryCategoryLevel2 != null &amp;&amp; !queryCategoryLevel2.equals(""))&#123; categoryLevel2List = getCategoryList(queryCategoryLevel1.toString()); model.addAttribute("categoryLevel2List", categoryLevel2List); &#125; if(queryCategoryLevel3 != null &amp;&amp; !queryCategoryLevel3.equals(""))&#123; categoryLevel3List = getCategoryList(queryCategoryLevel2.toString()); model.addAttribute("categoryLevel3List", categoryLevel3List); &#125; return "developer/appinfolist"; &#125; public List&lt;DataDictionary&gt; getDataDictionaryList(String typeCode)&#123; List&lt;DataDictionary&gt; dataDictionaryList = null; try &#123; dataDictionaryList = dataDictionaryService.getDataDictionaryList(typeCode); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return dataDictionaryList; &#125; /** * 根据typeCode查询出相应的数据字典列表 * @param pid * @return */ @RequestMapping(value="/datadictionarylist.json",method=RequestMethod.GET) @ResponseBody public List&lt;DataDictionary&gt; getDataDicList (@RequestParam String tcode)&#123; logger.debug("getDataDicList tcode ============ " + tcode); return this.getDataDictionaryList(tcode); &#125; /** * 根据parentId查询出相应的分类级别列表 * @param pid * @return */ @RequestMapping(value="/categorylevellist.json",method=RequestMethod.GET) @ResponseBody public List&lt;AppCategory&gt; getAppCategoryList (@RequestParam String pid)&#123; logger.debug("getAppCategoryList pid ============ " + pid); if(pid.equals("")) pid = null; return getCategoryList(pid); &#125; public List&lt;AppCategory&gt; getCategoryList (String pid)&#123; List&lt;AppCategory&gt; categoryLevelList = null; try &#123; categoryLevelList = appCategoryService.getAppCategoryListByParentId(pid==null?null:Integer.parseInt(pid)); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return categoryLevelList; &#125; //跳转到新增appinfo页面 @RequestMapping(value="/appinfoadd",method=RequestMethod.GET) public String add(@ModelAttribute("appInfo") AppInfo appInfo)&#123; return "developer/appinfoadd"; &#125; //保存appinfo数据 @RequestMapping(value="/appinfoaddsave",method=RequestMethod.POST) public String addSave(AppInfo appInfo,HttpSession session,HttpServletRequest request, @RequestParam(value="a_logoPicPath",required= false) MultipartFile attach)&#123; String logoPicPath = null; String logoLocPath = null; if(!attach.isEmpty())&#123; String path = request.getSession().getServletContext().getRealPath("statics"+java.io.File.separator+"uploadfiles"); logger.info("uploadFile path: " + path); String oldFileName = attach.getOriginalFilename();//原文件名 String prefix = FilenameUtils.getExtension(oldFileName);//原文件后缀 int filesize = 500000; if(attach.getSize() &gt; filesize)&#123;//上传大小不得超过 50k request.setAttribute("fileUploadError", Constants.FILEUPLOAD_ERROR_4); return "developer/appinfoadd"; &#125;else if(prefix.equalsIgnoreCase("jpg") || prefix.equalsIgnoreCase("png") ||prefix.equalsIgnoreCase("jepg") || prefix.equalsIgnoreCase("pneg"))&#123;//上传图片格式 String fileName = appInfo.getAPKName() + ".jpg";//上传LOGO图片命名:apk名称.apk File targetFile = new File(path,fileName); if(!targetFile.exists())&#123; targetFile.mkdirs(); &#125; try &#123; attach.transferTo(targetFile); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); request.setAttribute("fileUploadError", Constants.FILEUPLOAD_ERROR_2); return "developer/appinfoadd"; &#125; logoPicPath = request.getContextPath()+"/statics/uploadfiles/"+fileName; //绝对路径 logoLocPath = path+File.separator+fileName; //相对路径 &#125;else&#123; request.setAttribute("fileUploadError", Constants.FILEUPLOAD_ERROR_3); return "developer/appinfoadd"; &#125; &#125; appInfo.setCreatedBy(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appInfo.setCreationDate(new Date()); appInfo.setLogoPicPath(logoPicPath); appInfo.setLogoLocPath(logoLocPath); appInfo.setDevId(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appInfo.setStatus(1); try &#123; if(appInfoService.add(appInfo))&#123; return "redirect:/dev/flatform/app/list"; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return "developer/appinfoadd"; &#125; /** * 增加appversion信息（跳转到新增app版本页面） * @param appInfo * @return */ @RequestMapping(value="/appversionadd",method=RequestMethod.GET) public String addVersion(@RequestParam(value="id")String appId, @RequestParam(value="error",required= false)String fileUploadError, AppVersion appVersion,Model model)&#123; logger.debug("fileUploadError============&gt; " + fileUploadError); if(null != fileUploadError &amp;&amp; fileUploadError.equals("error1"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_1; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error2"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_2; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error3"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_3; &#125; appVersion.setAppId(Integer.parseInt(appId)); List&lt;AppVersion&gt; appVersionList = null; try &#123; appVersionList = appVersionService.getAppVersionList(Integer.parseInt(appId)); appVersion.setAppName((appInfoService.getAppInfo(Integer.parseInt(appId),null)).getSoftwareName()); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; model.addAttribute("appVersionList", appVersionList); model.addAttribute(appVersion); model.addAttribute("fileUploadError",fileUploadError); return "developer/appversionadd"; &#125; /** * 保存新增appversion数据（子表）-上传该版本的apk包 * @param appInfo * @param appVersion * @param session * @param request * @param attach * @return */ @RequestMapping(value="/addversionsave",method=RequestMethod.POST) public String addVersionSave(AppVersion appVersion,HttpSession session,HttpServletRequest request, @RequestParam(value="a_downloadLink",required= false) MultipartFile attach )&#123; String downloadLink = null; String apkLocPath = null; String apkFileName = null; if(!attach.isEmpty())&#123; String path = request.getSession().getServletContext().getRealPath("statics"+File.separator+"uploadfiles"); logger.info("uploadFile path: " + path); String oldFileName = attach.getOriginalFilename();//原文件名 String prefix = FilenameUtils.getExtension(oldFileName);//原文件后缀 if(prefix.equalsIgnoreCase("apk"))&#123;//apk文件命名：apk名称+版本号+.apk String apkName = null; try &#123; apkName = appInfoService.getAppInfo(appVersion.getAppId(),null).getAPKName(); &#125; catch (Exception e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; if(apkName == null || "".equals(apkName))&#123; return "redirect:/dev/flatform/app/appversionadd?id="+appVersion.getAppId() +"&amp;error=error1"; &#125; apkFileName = apkName + "-" +appVersion.getVersionNo() + ".apk"; File targetFile = new File(path,apkFileName); if(!targetFile.exists())&#123; targetFile.mkdirs(); &#125; try &#123; attach.transferTo(targetFile); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return "redirect:/dev/flatform/app/appversionadd?id="+appVersion.getAppId() +"&amp;error=error2"; &#125; downloadLink = request.getContextPath()+"/statics/uploadfiles/"+apkFileName; apkLocPath = path+File.separator+apkFileName; &#125;else&#123; return "redirect:/dev/flatform/app/appversionadd?id="+appVersion.getAppId() +"&amp;error=error3"; &#125; &#125; appVersion.setCreatedBy(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appVersion.setCreationDate(new Date()); appVersion.setDownloadLink(downloadLink); appVersion.setApkLocPath(apkLocPath); appVersion.setApkFileName(apkFileName); try &#123; if(appVersionService.appsysadd(appVersion))&#123; return "redirect:/dev/flatform/app/list"; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return "redirect:/dev/flatform/app/appversionadd?id="+appVersion.getAppId(); &#125; @RequestMapping(value="/&#123;appid&#125;/sale",method=RequestMethod.PUT) @ResponseBody public Object sale(@PathVariable String appid,HttpSession session)&#123; HashMap&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); Integer appIdInteger = 0; try&#123; appIdInteger = Integer.parseInt(appid); &#125;catch(Exception e)&#123; appIdInteger = 0; &#125; resultMap.put("errorCode", "0"); resultMap.put("appId", appid); if(appIdInteger&gt;0)&#123; try &#123; DevUser devUser = (DevUser)session.getAttribute(Constants.DEV_USER_SESSION); AppInfo appInfo = new AppInfo(); appInfo.setId(appIdInteger); appInfo.setModifyBy(devUser.getId()); if(appInfoService.appsysUpdateSaleStatusByAppId(appInfo))&#123; resultMap.put("resultMsg", "success"); &#125;else&#123; resultMap.put("resultMsg", "success"); &#125; &#125; catch (Exception e) &#123; resultMap.put("errorCode", "exception000001"); &#125; &#125;else&#123; //errorCode:0为正常 resultMap.put("errorCode", "param000001"); &#125; /* * resultMsg:success/failed * errorCode:exception000001 * appId:appId * errorCode:param000001 */ return resultMap; &#125; /** * 判断APKName是否唯一 * @param apkName * @return */ @RequestMapping(value="/apkexist.json",method=RequestMethod.GET) @ResponseBody public Object apkNameIsExit(@RequestParam String APKName)&#123; HashMap&lt;String, String&gt; resultMap = new HashMap&lt;String, String&gt;(); if(StringUtils.isNullOrEmpty(APKName))&#123; resultMap.put("APKName", "empty"); &#125;else&#123; AppInfo appInfo = null; try &#123; appInfo = appInfoService.getAppInfo(null, APKName); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if(null != appInfo) resultMap.put("APKName", "exist"); else resultMap.put("APKName", "noexist"); &#125; return JSONArray.toJSONString(resultMap); &#125; /** * 查看app信息，包括app基本信息和版本信息列表（跳转到查看页面） * @param appInfo * @return */ @RequestMapping(value="/appview/&#123;id&#125;",method=RequestMethod.GET) public String view(@PathVariable String id,Model model)&#123; AppInfo appInfo = null; List&lt;AppVersion&gt; appVersionList = null; try &#123; appInfo = appInfoService.getAppInfo(Integer.parseInt(id),null); appVersionList = appVersionService.getAppVersionList(Integer.parseInt(id)); &#125;catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; model.addAttribute("appVersionList", appVersionList); model.addAttribute(appInfo); return "developer/appinfoview"; &#125; /** * 修改app信息，包括：修改app基本信息（appInfo）和修改版本信息（appVersion） * 分为两步实现： * 1 修改app基本信息（appInfo） * 2 修改版本信息（appVersion） */ /** * 修改appInfo信息（跳转到修改appInfo页面） * @param id * @param model * @return */ @RequestMapping(value="/appinfomodify",method=RequestMethod.GET) public String modifyAppInfo(@RequestParam("id") String id, @RequestParam(value="error",required= false)String fileUploadError, Model model)&#123; AppInfo appInfo = null; logger.debug("modifyAppInfo --------- id: " + id); if(null != fileUploadError &amp;&amp; fileUploadError.equals("error1"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_1; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error2"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_2; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error3"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_3; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error4"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_4; &#125; try &#123; appInfo = appInfoService.getAppInfo(Integer.parseInt(id),null); &#125;catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; model.addAttribute(appInfo); model.addAttribute("fileUploadError",fileUploadError); return "developer/appinfomodify"; &#125; /** * 修改最新的appVersion信息（跳转到修改appVersion页面） * @param versionId * @param appId * @param model * @return */ @RequestMapping(value="/appversionmodify",method=RequestMethod.GET) public String modifyAppVersion(@RequestParam("vid") String versionId, @RequestParam("aid") String appId, @RequestParam(value="error",required= false)String fileUploadError, Model model)&#123; AppVersion appVersion = null; List&lt;AppVersion&gt; appVersionList = null; if(null != fileUploadError &amp;&amp; fileUploadError.equals("error1"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_1; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error2"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_2; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error3"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_3; &#125; try &#123; appVersion = appVersionService.getAppVersionById(Integer.parseInt(versionId)); appVersionList = appVersionService.getAppVersionList(Integer.parseInt(appId)); &#125;catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; model.addAttribute(appVersion); model.addAttribute("appVersionList",appVersionList); model.addAttribute("fileUploadError",fileUploadError); return "developer/appversionmodify"; &#125; /** * 保存修改后的appVersion * @param appVersion * @param session * @return */ @RequestMapping(value="/appversionmodifysave",method=RequestMethod.POST) public String modifyAppVersionSave(AppVersion appVersion,HttpSession session,HttpServletRequest request, @RequestParam(value="attach",required= false) MultipartFile attach)&#123; String downloadLink = null; String apkLocPath = null; String apkFileName = null; if(!attach.isEmpty())&#123; String path = request.getSession().getServletContext().getRealPath("statics"+File.separator+"uploadfiles"); logger.info("uploadFile path: " + path); String oldFileName = attach.getOriginalFilename();//原文件名 String prefix = FilenameUtils.getExtension(oldFileName);//原文件后缀 if(prefix.equalsIgnoreCase("apk"))&#123;//apk文件命名：apk名称+版本号+.apk String apkName = null; try &#123; apkName = appInfoService.getAppInfo(appVersion.getAppId(),null).getAPKName(); &#125; catch (Exception e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; if(apkName == null || "".equals(apkName))&#123; return "redirect:/dev/flatform/app/appversionmodify?vid="+appVersion.getId() +"&amp;aid="+appVersion.getAppId() +"&amp;error=error1"; &#125; apkFileName = apkName + "-" +appVersion.getVersionNo() + ".apk"; File targetFile = new File(path,apkFileName); if(!targetFile.exists())&#123; targetFile.mkdirs(); &#125; try &#123; attach.transferTo(targetFile); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return "redirect:/dev/flatform/app/appversionmodify?vid="+appVersion.getId() +"&amp;aid="+appVersion.getAppId() +"&amp;error=error2"; &#125; downloadLink = request.getContextPath()+"/statics/uploadfiles/"+apkFileName; apkLocPath = path+File.separator+apkFileName; &#125;else&#123; return "redirect:/dev/flatform/app/appversionmodify?vid="+appVersion.getId() +"&amp;aid="+appVersion.getAppId() +"&amp;error=error3"; &#125; &#125; appVersion.setModifyBy(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appVersion.setModifyDate(new Date()); appVersion.setDownloadLink(downloadLink); appVersion.setApkLocPath(apkLocPath); appVersion.setApkFileName(apkFileName); try &#123; if(appVersionService.modify(appVersion))&#123; return "redirect:/dev/flatform/app/list"; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return "developer/appversionmodify"; &#125; /** * 修改操作时，删除文件（logo图片/apk文件），并更新数据库（app_info/app_version） * @param fileUrlPath * @param fileLocPath * @param flag * @param id * @return */ @RequestMapping(value = "/delfile",method=RequestMethod.GET) @ResponseBody public Object delFile(@RequestParam(value="flag",required=false) String flag, @RequestParam(value="id",required=false) String id)&#123; HashMap&lt;String, String&gt; resultMap = new HashMap&lt;String, String&gt;(); String fileLocPath = null; if(flag == null || flag.equals("") || id == null || id.equals(""))&#123; resultMap.put("result", "failed"); &#125;else if(flag.equals("logo"))&#123;//删除logo图片（操作app_info） try &#123; fileLocPath = (appInfoService.getAppInfo(Integer.parseInt(id), null)).getLogoLocPath(); File file = new File(fileLocPath); if(file.exists()) if(file.delete())&#123;//删除服务器存储的物理文件 if(appInfoService.deleteAppLogo(Integer.parseInt(id)))&#123;//更新表 resultMap.put("result", "success"); &#125; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;else if(flag.equals("apk"))&#123;//删除apk文件（操作app_version） try &#123; fileLocPath = (appVersionService.getAppVersionById(Integer.parseInt(id))).getApkLocPath(); File file = new File(fileLocPath); if(file.exists()) if(file.delete())&#123;//删除服务器存储的物理文件 if(appVersionService.deleteApkFile(Integer.parseInt(id)))&#123;//更新表 resultMap.put("result", "success"); &#125; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return JSONArray.toJSONString(resultMap); &#125; /** * 保存修改后的appInfo * @param appInfo * @param session * @return */ @RequestMapping(value="/appinfomodifysave",method=RequestMethod.POST) public String modifySave(AppInfo appInfo,HttpSession session,HttpServletRequest request, @RequestParam(value="attach",required= false) MultipartFile attach)&#123; String logoPicPath = null; String logoLocPath = null; String APKName = appInfo.getAPKName(); if(!attach.isEmpty())&#123; String path = request.getSession().getServletContext().getRealPath("statics"+File.separator+"uploadfiles"); logger.info("uploadFile path: " + path); String oldFileName = attach.getOriginalFilename();//原文件名 String prefix = FilenameUtils.getExtension(oldFileName);//原文件后缀 int filesize = 500000; if(attach.getSize() &gt; filesize)&#123;//上传大小不得超过 50k return "redirect:/dev/flatform/app/appinfomodify?id="+appInfo.getId() +"&amp;error=error4"; &#125;else if(prefix.equalsIgnoreCase("jpg") || prefix.equalsIgnoreCase("png") ||prefix.equalsIgnoreCase("jepg") || prefix.equalsIgnoreCase("pneg"))&#123;//上传图片格式 String fileName = APKName + ".jpg";//上传LOGO图片命名:apk名称.apk File targetFile = new File(path,fileName); if(!targetFile.exists())&#123; targetFile.mkdirs(); &#125; try &#123; attach.transferTo(targetFile); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return "redirect:/dev/flatform/app/appinfomodify?id="+appInfo.getId() +"&amp;error=error2"; &#125; logoPicPath = request.getContextPath()+"/statics/uploadfiles/"+fileName; logoLocPath = path+File.separator+fileName; &#125;else&#123; return "redirect:/dev/flatform/app/appinfomodify?id="+appInfo.getId() +"&amp;error=error3"; &#125; &#125; appInfo.setModifyBy(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appInfo.setModifyDate(new Date()); appInfo.setLogoLocPath(logoLocPath); appInfo.setLogoPicPath(logoPicPath); try &#123; if(appInfoService.modify(appInfo))&#123; return "redirect:/dev/flatform/app/list"; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return "developer/appinfomodify"; &#125; @RequestMapping(value="/delapp.json") @ResponseBody public Object delApp(@RequestParam String id)&#123; logger.debug("delApp appId===================== "+id); HashMap&lt;String, String&gt; resultMap = new HashMap&lt;String, String&gt;(); if(StringUtils.isNullOrEmpty(id))&#123; resultMap.put("delResult", "notexist"); &#125;else&#123; try &#123; if(appInfoService.appsysdeleteAppById(Integer.parseInt(id))) resultMap.put("delResult", "true"); else resultMap.put("delResult", "false"); &#125; catch (NumberFormatException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return JSONArray.toJSONString(resultMap); &#125;&#125;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MVC体系结构和处理请求控制器]]></title>
    <url>%2F2018%2F11%2F06%2FMVC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%8E%A7%E5%88%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[环境搭建jar包123456789101112aopalliance-1.0.jaraspectjweaver-1.6.9.jarcommons-logging-1.1.1.jarlog4j-1.2.16.jarlog4j-1.2.17.jarspring-aop-3.2.13.RELEASE.jarspring-beans-3.2.13.RELEASE.jarspring-context-3.2.13.RELEASE.jarspring-core-3.2.13.RELEASE.jarspring-expression-3.2.13.RELEASE.jarspring-web-3.2.13.RELEASE.jarspring-webmvc-3.2.13.RELEASE.jar 在web.xml中配置servlet1234567891011121314151617&lt;!-- 核心控制器的配置 DispatchServlet --&gt;&lt;servlet&gt;&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!-- 初始化参数 --&gt;&lt;init-param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;&lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;&lt;/init-param&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 创建Spring MVC的配置文件springmvc-servlet.xml1234567891011121314151617181920212223&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context"xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;&lt;!-- 配置处理器映射 HandlerMapping --&gt;&lt;!-- &lt;bean name="/index.html" class="cn.smbms.controller.IndexController" /&gt; --&gt;&lt;!-- &lt;bean name="/welcome" class="cn.smbms.controller.IndexController" /&gt; --&gt;&lt;mvc:annotation-driven/&gt;&lt;context:component-scan base-package="cn.smbms.controller"/&gt;&lt;!-- 完成视图的对应 --&gt;&lt;!-- 对转向页面的路径解析。prefix：前缀， suffix：后缀 --&gt;&lt;beanclass="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;&lt;property name="prefix" value="/WEB-INF/jsp/" /&gt;&lt;property name="suffix" value=".jsp" /&gt;&lt;/bean&gt;&lt;/beans&gt; 创建Controller12345678910111213@Controllerpublic class IndexController（）&#123;@RequestMapping(&#123;"/index","/you"&#125;)public ModelAndView index()&#123;System.out.println("hello 宇智波鼬");return new ModelAndView("index");&#125;@RequestMapping("/test.html")public String test(String userCode,Model model)&#123;model.addAttribute("userCode", userCode);return "success";&#125;&#125; 参数传递12345678910111213141516171819202122//params和@RequestParam的参数要一致@RequestMapping(value="/welcome",method=RequestMethod.GET)public String welcome(@RequestParam(value="username",required=false) String username)&#123;logger.info("welcome" +username);return "index";&#125;required=false //属性不必须@RequestMapping("/index2")public String index2(@RequestParam String username,Model model)&#123;model.addAttribute("username", username);//可以直接传对象model.addAttribute(username);User user=new User();user.setUserName(username);model.addAttribute("users", user);return "index";&#125;@RequestMapping("/index3")public String index3(@RequestParam String username,Map&lt;String, Object&gt; model)&#123;model.put("username", username);return "index";&#125;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring配置补充]]></title>
    <url>%2F2018%2F11%2F06%2FSpring%E9%85%8D%E7%BD%AE%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[灵活配置DataSource使用属性文件配置数据源123456789101112&lt;!-- 使用数据配置文件设置数据源 --&gt;&lt;beanclass="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;&lt;property name="location"&gt;&lt;value&gt;classpath:database.properties&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 数据源在配置文件中 --&gt;&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;&lt;property name="driverClassName" value="$&#123;driver&#125;"&gt;&lt;/property&gt; &lt;propertyname="url" value="$&#123;url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;user&#125;"&gt;&lt;/property&gt;&lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; 使用jndi数据源 Context节点下12345678910&lt;!-- 使用jndi数据源 在tomcat content.xml配置 --&gt;&lt;Resource name="jndi/smbms" auth="Container" type="javax.sql.DataSource"maxActive="100" maxIdle="30" driverClassName="com.mysql.jdbc.Driver"username="root" password="123456"url="jdbc:mysql://localhost:3306/smbms?useUnicode=true&amp;characterEncoding=utf-8" /&gt;&lt;!-- &lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;&lt;property name="jndiName"&gt;&lt;value&gt;java:comp/env/jndi/smbms&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt; --&gt; Spring中bean的作用域（scope属性）singleton 默认值：单利模式创建bean的实例，实例只有一个 安全差prototype 每次从容器中获取bean时，都会创建一个新的beanrequest web环境 针对每次请求都会创建一个新的beansession web环境 同一个会话共享一个，不同会话使用不同的实例使用注解指定作用域@Scope（””）@Service() Spring自动装配12345autowire属性：no：不使用自动装配，bean依赖关系必须通过property定义bytype：根据属性类型进行装配，寻找容器中的全部bean，找出属性类型相同的bean，如果有多个抛出异常byName：根据属性名进行装配，找出id与属性的setter方法匹配的beanconstructor：与bytype相似，但是用于构造器参数 拆分Spring配置文件12345ApplicationContext ctx=new ClassPathXmlApplicationContext("applicationContextl.xmlapplicationContextl-dao.xmlapplicationContextl-service.xml");使用import导入主配置文件&lt;import resource=""/&gt;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis与Spring的整合]]></title>
    <url>%2F2018%2F11%2F06%2FMybatis%E4%B8%8ESpring%E7%9A%84%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[配置环境添加jar包1234567891011121314151617181920aopalliance-1.0.jaraspectjweaver-1.6.9.jaraspectjweaver.jarcommons-dbcp-1.4.jarcommons-logging-1.2.jarcommons-pool-1.6.jarlog4j-1.2.16.jarlog4j-1.2.17.jarmybatis-3.2.2-sources.jarmybatis-3.2.2.jarmybatis-spring-1.2.0.jarmybatis-spring-1.3.2.jarmysql-connector-java-5.1.0-bin.jarspring-aop-3.2.13.RELEASE.jarspring-beans-3.2.13.RELEASE.jarspring-context-3.2.13.RELEASE.jarspring-core-3.2.13.RELEASE.jarspring-expression-3.2.13.RELEASE.jarspring-jdbc-3.2.13.RELEASE.jarspring-tx-3.2.13.RELEASE.jar 创建数据访问接口（mapper）结尾，实体类，配置MyBatis配置文件配置数据源关键12commons-dbcp-1.4.jarcommons-pool-1.6.jar 在applicationContextl.xml中配置、12345678&lt;!-- 数据源 --&gt;&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;&lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;&lt;property name="url"value="jdbc:mysql://localhost:3306/smbms?useUnicode=true&amp;amp;characterEncoding=utf-8"&gt;&lt;/property&gt;&lt;property name="username" value="root"&gt;&lt;/property&gt;&lt;property name="password" value="123456"&gt;&lt;/property&gt;&lt;/bean&gt; &amp;符号加&amp; 配置SqlSessionFactoryBean获取sqlSessionFactory实例 123456789101112&lt;!-- 配置SqlSessionFactoryBean --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;!-- 引用Mybatis文件中的数据--&gt;&lt;property name="configLocation" value="classpath:mybatis-configl.xml"&gt;&lt;/property&gt;&lt;property name="mapperLocations"&gt;&lt;list&gt;&lt;value&gt;classpath:cn/dao/UserMapper.xml&lt;/value&gt;&lt;value&gt;classpath:cn/dao/ProviderMapper.xml&lt;/value&gt;&lt;/list&gt;&lt;/property&gt;&lt;/bean&gt; 使用SqlSessionTemplate实现数据库操作 配置SqlSessionTemplate在实现类中的代码12345private SqlSessionTemplate sqlSession; getter 和 setter方法@Overridepublic int add(User user) &#123;return sqlSession.getMapper(UserMapper.class).add(user);&#125; Spring配置文件创建SqlSessionTemplate1234&lt;!-- 配置SqlSessionTemplate --&gt;&lt;!-- &lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate"&gt;&lt;constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; --&gt; 实现类继承SqlSessionDaoSupport简化SqlSessionTemplate的配置与获取1return this.getSession().getMapper(UserMapper.class).add(user); Spring配置文件:：12&lt;!-- &lt;bean id="userMapper" class="cn.dao.UserMapperImpl"&gt;&lt;propertyname="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; 注入映射器实现 MapperFactoryBean注入映射器1234&lt;!-- Dao --&gt;&lt;!-- &lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt;&lt;property name="mapperInterface" value="cn.dao.UserMapper"&gt;&lt;/property&gt; &lt;propertyname="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; 无需手工定义实现类，配置MapperFactoryBean可以自动生成使用MapperScannerConfigurer注入映射器可以扫描指定包中的接口并将他们直接定义为MapperFactoryBean1234&lt;!-- 配置Dao --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;&lt;property name="basePackage" value="cn.dao"&gt;&lt;/property&gt;&lt;/bean&gt; 配置声明式事务添加头文件tx和aop12345678910111213141516&lt;!-- 事务管理器 --&gt;&lt;bean id="txManager"class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事务增强 --&gt;&lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;&lt;tx:attributes&gt;&lt;tx:method name="*" propagation="REQUIRED" /&gt;&lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置切面 --&gt;&lt;aop:config&gt;&lt;aop:pointcut expression="execution(* cn.service..*.*(..))" id="myPoint"/&gt;&lt;aop:advisor advice-ref="txAdvice" pointcut-ref="myPoint"/&gt;&lt;/aop:config&gt; 使用注解实现声明式事务处理123456&lt;!-- 事务管理器 --&gt;&lt;bean id="txManager"class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;context:component-scan base-package="cn.service"&gt;&lt;/context:component-scan&gt; 1234@Transactional 全局class@Transactional (propagation=Propagation.SUPPORTS)public int add()&#123;....&#125;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IOC和AOP的使用扩展]]></title>
    <url>%2F2018%2F11%2F06%2FIOC%E5%92%8CAOP%E7%9A%84%E4%BD%BF%E7%94%A8%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[多种方式实现依赖注入通过构造有参函数12345&lt;bean id="userService" class="cn.service.impl.UserServiceimpl"&gt;&lt;constructor-arg ref="userdao" index="0"/&gt;&lt;constructor-arg index="1" value="宇智波鼬" /&gt;&lt;constructor-arg index="2" value="只要是人都是依靠自己的知识与认知并且被之束缚生活着的，那就叫做现实。但是知识与认知是模糊不清的东西，现实也许只是镜中花水中月，人都是活在自己的执念中的，你不这么认为吗"/&gt;&lt;/bean&gt; index代表参数位置，从0开始简单类型为value，引用类型为ref 通过p命名空间(通过seter方法)1&lt;bean id="users" class="cn.entity.User" p:name="宇智波鼬u" p:email="302645509@qq.com" p:dress="永济市" p:mess="无论你变成什么样,我都会永远爱着你"/&gt; 设置变量值：p：属性值=“”，设置引用变量：p：属性名-ref=“”； 注入集合类型list 允许重复(通过seter方法)12345&lt;bean id="play" class="naruto.entity.Player"&gt;&lt;property name="armet" ref="tou"&gt;&lt;list&gt;&lt;value&gt;&lt;/value&gt;&lt;ref&gt;&lt;/ref&gt;&lt;/list&gt;&lt;property&gt;&lt;/bean&gt; set 连线一组值，但不能重复12345&lt;bean id="play" class="naruto.entity.Player"&gt;&lt;property name="armet" ref="tou"&gt;&lt;set&gt;&lt;value&gt;&lt;/value&gt;&lt;ref&gt;&lt;/ref&gt;&lt;/set&gt;&lt;property&gt;&lt;/bean&gt; map 名称-值对的集合，其中名称和值可以是任何类型12345&lt;bean id="play" class="naruto.entity.Player"&gt;&lt;property name="armet" ref="tou"&gt;&lt;map&gt;&lt;entry&gt;&lt;key&gt;&lt;value&gt;&lt;/value&gt;&lt;/key&gt;&lt;value&gt;&lt;/value&gt;&lt;/entry&gt;&lt;/map&gt;&lt;property&gt;&lt;/bean&gt; 注入null和空123456&lt;property name="armet" ref="tou"&gt;&lt;value&gt;&lt;/value&gt;&lt;property&gt;&lt;property name="armet" ref="tou"&gt;&lt;null/&gt;&lt;property&gt; 使用注解实现bean组建装配1234@Component(“userDao”) == &lt;bean id="userDao" class="cn...l"&gt;@Repository //标识dao类@Service //标识业务类@Controller //标识控制器类 使用@Autowired实现bean的装配12345@Autowired private SpellChecker spellChecker; //可以省略相关的setter（）方法采用按照类型匹配的方式自动装配合适的依赖对象如有一个以上的类型相匹配的bean时，使用@Qualifier指定所需bean的名称@Autowired @Qualifier("student1") private Student student; 加载注解定义的bean在配置文件中添加对context的命名空间的声明1&lt;context:annotation-config/&gt; @Autowired 对方法的参数进行标注1@Autowired public void setDao(@Qualifier("userDao") User dao) setter()和构造方法 使用Java标准注解进行装配123@Resource@Resource private SpellChecker spellChecker;如果没有显示的指定bean名称，会根据字段名或时setter产生的名称 使用注解实现aop声明一个 aspect Aspects 类和其他任何正常的 bean 一样，除了它们将会用 @AspectJ 注释之外，它和其他类一样可能有方法和字段123@Aspect public class AspectModule &#123; &#125;声明一个切入点@Pointcut("execution(* com.xyz.myapp.service.*.*(..))") // expression private void businessService() &#123;&#125; 声明12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Aspectpublic class UserServiceLogger &#123; private static final Logger LOGGER=Logger.getLogger(UserServiceLogger.class); @Pointcut("execution(* cn.service..*.*(..)) ") public void pointcut()&#123;&#125; /** * 前置增强 * @param jp */ @Before("pointcut()") public void before(JoinPoint jp) &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法入参：" + Arrays.toString(jp.getArgs())); &#125; /** * 后置增强 * @param jp * @param returnValue */ @AfterReturning(pointcut = "pointcut()", returning = "returnValue") public void afterReturning(JoinPoint jp, Object returnValue) &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法返回值：" + returnValue); &#125; /** * 最终增强 * @param jp */ @After("pointcut()") public void afterLogger(JoinPoint jp) &#123; LOGGER.info(jp.getSignature().getName() + " 方法结束执行。"); &#125; /** * 异常增强 * @param jp * @param e */ @AfterThrowing(value="pointcut()", throwing = "e") public void afterThrowing(JoinPoint jp, RuntimeException e) &#123; LOGGER.error(jp.getSignature().getName() + " 方法发生异常：" + e); &#125; /** * 环绕增强 * @param jp * @return * @throws Throwable */ @Around("pointcut()") public Object aroundLogger(ProceedingJoinPoint jp) throws Throwable &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法入参：" + Arrays.toString(jp.getArgs())); try &#123; Object result = jp.proceed(); LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法返回值：" + result); return result; &#125; catch (Throwable e) &#123; LOGGER.error(jp.getSignature().getName() + " 方法发生异常：" + e); throw e; &#125; finally &#123; LOGGER.info(jp.getSignature().getName() + " 方法结束执行。"); &#125; &#125; &#125;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring核心概念]]></title>
    <url>%2F2018%2F11%2F06%2FSpring%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[控制反转（ioc）也成为依赖注入，来降低代码之间的耦合度搭建spring环境部署jar包12345commons-logging-1.2.jarspring-beans-3.2.13.RELEASE.jarspring-context-3.2.13.RELEASE.jarspring-core-3.2.13.RELEASE.jarspring-expression-3.2.13.RELEASE.jar 创建resources目录，在里面创建applicationContextl.xml1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:aop="http://www.springframework.org/schema/aop"xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsd"&gt;//根据属性seter()方法&lt;bean id="kai" class="naruto.entity.Equip"&gt;&lt;property name="name" value="万世荣光铠甲"/&gt;&lt;property name="speedPlus" value="4"/&gt;&lt;property name="attackPlus" value="108"/&gt;&lt;property name="defencePlus" value="40"/&gt;&lt;property name="type" value="铠甲"/&gt;&lt;/bean&gt;&lt;/bean&gt; 创建测试类12ClassPathXmlApplicationContext context=new ClassPathXmlApplicationContext("applicationContextl.xml"); //xml路径EquipMess jc=(EquipMess)context.getBean("equip"); //bean的id值 aop1234加入jar包spring-aop-3.2.13.RELEASE.jaraopalliance-1.0.jaraspectjweaver.jar 在aop包下创建aop输出类（前置和后置）1234567private static Logger logger=Logger.getLogger(UserServiceLogger.class);public void before(JoinPoint jp)&#123;logger.info("调用"+jp.getTarget()+"的"+jp.getSignature()+"方法，方法参数"+Arrays.toString(jp.getArgs()));&#125;public void afterReturning(JoinPoint jp,Object result)&#123;logger.info("调用"+jp.getTarget()+"的"+jp.getSignature()+"方法，方法返回值"+result);&#125; spring陪着文件导入相关配置定义切入点，加入增强处理12345678910&lt;bean id="theLogger" class="naruto.aop.Snippet"&gt;&lt;/bean&gt;&lt;aop:config&gt;&lt;aop:pointcut id="pointcut"expression="execution(public void updateEquip(entity.Equip))" /&gt;&lt;aop:aspect ref="theLogger"&gt;&lt;aop:before method="before" pointcut-ref="pointcut"&gt;&lt;/aop:before&gt;&lt;aop:after-returning method="afterReturning"pointcut-ref="pointcut" returning="result" /&gt;&lt;/aop:aspect&gt;&lt;/aop:config&gt;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis动态SQL]]></title>
    <url>%2F2018%2F11%2F06%2FMybatis%E5%8A%A8%E6%80%81SQL%2F</url>
    <content type="text"><![CDATA[if 语句123456&lt;select id="selectUserByUsernameAndSex" resultType="user" parameterType="com.ys.po.User"&gt;select * from user where&lt;if test="username != null"&gt;username=#&#123;username&#125;&lt;/if&gt;&lt;/select&gt; if+where 语句1234567891011&lt;select id="selectUserByUsernameAndSex" resultType="user" parameterType="com.ys.po.User"&gt;select * from user&lt;where&gt;&lt;if test="username != null"&gt;username=#&#123;username&#125;&lt;/if&gt;&lt;if test="username != null"&gt;and sex=#&#123;sex&#125;&lt;/if&gt;&lt;/where&gt;&lt;/select&gt; “where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。 if+set 语句12345678910111213&lt;!-- 根据 id 更新 user 表的数据 --&gt;&lt;update id=&quot;updateUserById&quot; parameterType=&quot;com.ys.po.User&quot;&gt;update user u&lt;set&gt;&lt;if test=&quot;username != null and username != &apos;&apos;&quot;&gt;u.username = #&#123;username&#125;,&lt;/if&gt;&lt;if test=&quot;sex != null and sex != &apos;&apos;&quot;&gt;u.sex = #&#123;sex&#125;&lt;/if&gt;&lt;/set&gt;where id=#&#123;id&#125;&lt;/update&gt; 如果第一个条件 username 为空，那么 sql 语句为：update user u set u.sex=? where id=?如果第一个条件不为空，那么 sql 语句为：update user u set u.username = ? ,u.sex = ? where id=? choose(when,otherwise) 语句12345678910111213141516&lt;select id="selectUserByChoose" resultType="com.ys.po.User" parameterType="com.ys.po.User"&gt;select * from user&lt;where&gt;&lt;choose&gt;&lt;when test="id !='' and id != null"&gt;id=#&#123;id&#125;&lt;/when&gt;&lt;when test="username !='' and username != null"&gt;and username=#&#123;username&#125;&lt;/when&gt;&lt;otherwise&gt;and sex=#&#123;sex&#125;&lt;/otherwise&gt;&lt;/choose&gt;&lt;/where&gt;&lt;/select&gt; 和switch语句差不多 trim 语句12345678910111213141516171819&lt;select id="selectUserByUsernameAndSex" resultType="user" parameterType="com.ys.po.User"&gt;select * from user&lt;!-- &lt;where&gt;&lt;if test="username != null"&gt;username=#&#123;username&#125;&lt;/if&gt;&lt;if test="username != null"&gt;and sex=#&#123;sex&#125;&lt;/if&gt;&lt;/where&gt; --&gt;&lt;trim prefix="where" prefixOverrides="and | or"&gt;&lt;if test="username != null"&gt;and username=#&#123;username&#125;&lt;/if&gt;&lt;if test="sex != null"&gt;and sex=#&#123;sex&#125;&lt;/if&gt;&lt;/trim&gt;&lt;/select&gt; prefix：前缀prefixoverride：去掉第一个and或者是or12345678&lt;trim prefix="set" suffixOverrides=","&gt; //去掉最后一个逗号&lt;if test="username != null and username != ''"&gt;u.username = #&#123;username&#125;,&lt;/if&gt;&lt;if test="sex != null and sex != ''"&gt;u.sex = #&#123;sex&#125;,&lt;/if&gt;&lt;/trim&gt; foreach 语句12345678910111213141516&lt;select id="selectUserByListId" parameterType="com.ys.vo.UserVo" resultType="com.ys.po.User"&gt; select * from user &lt;where&gt; &lt;!-- collection:指定输入对象中的集合属性 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串 select * from user where 1=1 and (id=1 or id=2 or id=3) --&gt; &lt;foreach collection="ids" item="id" open="and (" close=")" separator="or"&gt; id=#&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MybatisSQL映射文件]]></title>
    <url>%2F2018%2F11%2F06%2FMybatisSQL%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[sql映射文件顶级元素配置mapper：映射元素的根节点，只有一个属性namespace，用于区分不同的mapper，绑定dao接口cache：配置给命名空间引用缓存cache-ref：从其他命名空间引用缓存配置resultMap：描述数据库结果集和对象的对应关系sql：可以重用的sql块 insert：插入语句12345&lt;insert id="add" parameterType="Destineinfo"&gt;INSERT INTOdestineinfo(room_name,destine_time,destine_name,dress)VALUES(#&#123;room_name&#125;,#&#123;destine_time&#125;,#&#123;destine_name&#125;,#&#123;dress&#125;)&lt;/insert&gt; delete：删除语句123&lt;delete id="dele"&gt;DELETE FROM destineinfo where id=#&#123;id&#125;&lt;/delete&gt; update：更新语句12345&lt;update id="modify" parameterType="Destineinfo"&gt;UPDATE destineinfo SETroom_name=#&#123;room_name&#125;,destine_name=#&#123;destine_name&#125;where id=#&#123;id&#125;&lt;/update&gt; select：查询语句namespace的命名必须和某个dao接口相同，已Mapper结尾接口中的方法与映射文件中的sql语句id要对应的 눈눈select属性id：命名空间的唯一标识符，要和接口的方法一致눈눈parameterType：传入参数的类型，可以是类，或基本数据类型resultType：查询语句返回结果类型，可以是类，或基本数据类型 使用map入参查询1234&lt;select id="getMap" resultType="Destineinfo" parameterType="Map"&gt;SELECT * FROM destineinfo WHERE destine_name LIKECONCAT('%',#&#123;name&#125;,'%')&lt;/select&gt; map对象.put(“name”,姓名)； 使用resultMap完成查询结果的展现用于数据库字段名不同与实体类的属性名 ，可以进行自动映射 resultMap自动映射(FULL)12&lt;!-- 设置resultMap的自动映射级别为none(禁止自动匹配) --&gt;&lt;!-- &lt;setting name="autoMappingBehavior" value="NONE"/&gt; --&gt; 自动映射前提：字段名和属性名要一致12345&lt;result property="id" column="id" /&gt;&lt;result property="room_name" column="room_name" /&gt;&lt;result property="destine_time" column="destine_time" /&gt;&lt;result property="destine_name" column="destine_name" /&gt;&lt;result property="dressName" column="dressName" /&gt; 使用resultType完成查询结果的展现直接返回类型，包括基本数据类型和复杂数据类型resultType和resultMap只能有一个使用@param实现多参数入参12xml中id为updateName的id和destine_namepublic int updateName(@Param("id")Integer id,@Param("destine_name")String name); 高级映射association12345678&lt;resultMap type="Destineinfo" id="userRoleResult"&gt; &lt;id property="id"column="id" /&gt; &lt;result property="room_name" column="room_name"/&gt; &lt;resultproperty="destine_time" column="destine_time"/&gt; &lt;result property="destine_name"column="destine_name"/&gt; &lt;association property="dress2" javaType="Dress"&gt;&lt;id property="id" column="r_id" /&gt; &lt;result property="dressName" column="dressName"/&gt;&lt;/association&gt; &lt;/resultMap&gt; association映射 &lt;select id="getListByDressid" resultMap="userRoleResult"parameterType="Integer"&gt; SELECT d.*,s.id as r_id,s.dressName FROM destineinfod, dress s WHERE d.dress=#&#123;dress&#125; and d.dress=s.id &lt;/select&gt; 可以内嵌12345&lt;association property="dress2" javaType="Dress" resultMap="roleResult" /&gt;&lt;resultMap type="Dress" id="roleResult"&gt;&lt;id property="id" column="r_id"/&gt;&lt;result property="dressName" column="dressName"/&gt;&lt;/resultMap&gt; 使用对象 1对1association属性property：实体对象的属性，此处为user里定义的Role类对象rolejavaType：完整的Java类名或别名 collection123456789101112&lt;resultMap type="Destineinfo" id="userAddressResult"&gt;&lt;id property="id" column="id"/&gt;&lt;result property="room_name" column="room_name" /&gt;&lt;result property="destine_time" column="destine_time" /&gt;&lt;result property="destine_name" column="destine_name" /&gt;&lt;result property="dress" column="dress" /&gt;&lt;collection property="addressList" ofType="Dress" resultMap="Addresss" /&gt;&lt;/resultMap&gt;&lt;resultMap type="Dress" id="Addresss"&gt;&lt;id property="id" column="r_id"/&gt;&lt;result property="dressName" column="dressName"/&gt;&lt;/resultMap&gt; collection属性property：实体对象的属性ofType：完整的Java类名或别名使用集合 1对多]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初识Mybatis]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%88%9D%E8%AF%86Mybatis%2F</url>
    <content type="text"><![CDATA[部署mybatis部署jar包创建database.properties和mybatis-configl.xml文件12345database.propertiesdriver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/boardroom?useUnicode=true&amp;characterEncoding=utf-8user=rootpassword=123456 mybatis-configl.xml 最重要的核心文件123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;!-- 引入database.properties文件 --&gt;&lt;properties resource="database.properties" /&gt;&lt;!-- 配置mybatis的log实现为LOG4J --&gt;&lt;settings&gt;&lt;setting name="logImpl" value="LOG4J" /&gt;&lt;/settings&gt;&lt;typeAliases&gt;&lt;typeAlias alias="user" type="cn.entity.User"/&gt;&lt;typeAlias alias="product" type="cn.entity.Product"/&gt;&lt;package name="cn.entity"/&gt;&lt;/typeAliases&gt;&lt;!-- 配置mybatis多套运行环境 --&gt;&lt;environments default="development"&gt;&lt;environment id="development"&gt;&lt;!-- 配置事务管理,采用JDBC的事务管理 --&gt;&lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt;&lt;!-- POOLED:mybatis自带的数据源,JNDI:基于tomcat的数据源 --&gt;&lt;dataSource type="POOLED"&gt;&lt;property name="driver" value="$&#123;driver&#125;"/&gt;&lt;property name="url" value="$&#123;url&#125;"/&gt;&lt;property name="username" value="$&#123;user&#125;"/&gt;&lt;property name="password" value="$&#123;password&#125;"/&gt;&lt;/dataSource&gt;&lt;/environment&gt;&lt;/environments&gt;&lt;!-- 将mapper文件加入到配置文件中 --&gt;&lt;mappers&gt;&lt;mapper resource="cn/entity/ProductMapper.xml"/&gt;&lt;mapper resource="cn/entity/DestineinfoMapper.xml"/&gt;&lt;/mappers&gt;&lt;/configuration&gt; util包下创建MyBatisUtil.java文件12345678910111213141516171819private static SqlSessionFactory factory;static&#123;InputStream is;try &#123;is = Resources.getResourceAsStream("mybatis-configl.xml");factory=new SqlSessionFactoryBuilder().build(is);&#125; catch (IOException e) &#123;// TODO Auto-generated catch blocke.printStackTrace();&#125;&#125;public static SqlSession CreateSqlSession()&#123;return factory.openSession(false); //true为自动提交事务&#125;public static void closeSqlSession(SqlSession sqlSession)&#123;if(null!=sqlSession)&#123;sqlSession.close();&#125;&#125; dao层创建接口,以实体类名字+mapper命名entity层创建实体类和实体类名字+mapper.xml1234567891011namespace建议使用接口地址，进行增删改查&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.dao.impl.DestineinfoMapper"&gt;&lt;!-- 查询用户表记录数 --&gt;&lt;select id="selall" resultType="Destineinfo"&gt;SELECT * FROM destineinfo&lt;/select&gt;&lt;/mapper&gt; 创建测试类1234567891011121314151617@Testpublic void testGetUserList()&#123;SqlSession sqlSession=null;List&lt;Destineinfo&gt;userList=new ArrayList&lt;Destineinfo&gt;();try &#123;sqlSession=MyBatisUtil.CreateSqlSession();userList=sqlSession.getMapper(DestineinfoMapper.class).selall();&#125; catch (Exception e) &#123;// TODO: handle exceptione.printStackTrace();&#125;finally &#123;MyBatisUtil.closeSqlSession(sqlSession);&#125;for (Destineinfo destineinfo : userList) &#123;logger.debug("testGetUserList userCodeL"+destineinfo.getId()+"--"+destineinfo.getRoom_name()+"--"+destineinfo.getDestine_name()+"------"+destineinfo.getDestine_time());&#125;&#125; mybatis核心对象SqlSessionFactoryBuilder负责构建SqlSessionFactory，特点：用过就丢，SqlSessionFactory创建后就不不需要存在了 SqlSessionFactory创建SqlSession实例的工厂，SqlSession通过SqlSessionFactory的openSession()来获取openSession()的参数为bollean类型时，true为关闭事务控制，自动提交，不穿参数，默认为true一旦创建始终存在,不建议创建多个 SqlSession用于持久化操作的对象，类似与jdbc的connection，提供了面向数据库sql命令的所有方法使用SqlSession的两种方法通过sqlSession实例直接执行已映射的sql语句通过mapper接口方法操作数据 mybatis-configl.xml的核心元素typeAliases配置类型别名12345&lt;typeAliases&gt;&lt;typeAlias alias="user" type="cn.entity.User"/&gt;&lt;typeAlias alias="product" type="cn.entity.Product"/&gt;&lt;package name="cn.entity"/&gt;&lt;/typeAliases&gt; mappers映射器1234&lt;mappers&gt;&lt;mapper resource="cn/entity/ProductMapper.xml"/&gt;&lt;mapper resource="cn/entity/DestineinfoMapper.xml"/&gt;&lt;/mappers&gt;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[漫漫归家路]]></title>
    <url>%2F2018%2F11%2F05%2F%E6%BC%AB%E6%BC%AB%E5%BD%92%E5%AE%B6%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[漫漫归家路其实我喊了一次又一次，每一次，都清醒的认识到果然没有人回应我，无论怎么呼唤，怎么祈祷，还是有无法实现的东西。 最后还是没能找到家，迷路了，累到了，然后，我决定不在呼唤无法给予我回应的东西。——《夏目友人帐》漫漫回家路]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[S8决赛IG3:0夺冠]]></title>
    <url>%2F2018%2F11%2F04%2FS8%E5%86%B3%E8%B5%9BIG3-0%E5%A4%BA%E5%86%A0%2F</url>
    <content type="text"><![CDATA[一个纨绔的老板， 一个没战队要的上单， 一个附赠的中单， 一个借来的打野， 一个直播抓来的ad， 一个双排排到的辅助， 一支没什么人看好的战队， 一场全球总决赛冠军， 一座山，山后是你们的故事 恭喜IG]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理想乡]]></title>
    <url>%2F2018%2F11%2F02%2F%E7%90%86%E6%83%B3%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[理想乡孤独な巡礼我在这世上活着 手无寸铁 没有任何人站在我的身后 挡住汹涌的风 更没有人能站在我的面前 挡住浩瀚的阳光 我在这世上活着 怀抱一小弦洁净 像黑夜抱着月亮那样慎重 怀抱着一大束荆棘 像土地抱着青草那样深情 怀抱着一大捧冰雪 像群山怀抱着清泉一样珍重 我在这世上活着 一切规章一切守则都是假设 他们说 你得有人 才是真的 我抱紧我自己 我有我自己 抱得更紧更牢靠一些啊 我的尊严 我的本份 我人的样子 我活在这世上 手无寸铁 没有刀锋 没有尖锐的刺 从不无往不利 从不春风得意 我站立的姿势比剑优美 我沉醉的笑容比花绚丽 我写字的认真比诵经虔诚 我痛哭的声音比长歌真实 我活在这世上 手无寸铁 我活在这世上 自强自立 自得其美 我只有 自己]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库应用]]></title>
    <url>%2F2018%2F11%2F01%2FOracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[回顾什么是索引索引是对数据库表中一列或多列的值进行排序的一种结构,索引会帮助您更快地获得该信息 索引分为几类123456789101112131.普通索引 添加INDEXALTER TABLE `table_name` ADD INDEX index_name ( `column` )下面演示下给user表的name字段添加一个索引2.主键索引 添加PRIMARY KEYALTER TABLE `table_name` ADD PRIMARY KEY ( `column` )3.唯一索引 添加UNIQUEALTER TABLE `table_name` ADD UNIQUE ( `column` )4.全文索引 添加FULLTEXTALTER TABLE `table_name` ADD FULLTEXT ( `column`) 序列可以作为主键，还有什么可以作为主键？rowid：就是数据的实际物理地址，rowid没必要自己创建，用户也没有权限创建rowid，它是oracle系统生成的索引 间隔分区和范围分区的区别间隔分区实现的自动生成分区 私有同义词和共有同义词的区别私有同义词只能在当前模式内访问，且不能与当前模式的对象同名 公有同义词可被所有的数据库用户访问使用 表空间（用来存放各种应用文件）一般分为三种123$ 永久性表空间：一般保存表，过程，索引等数据$ 临时性表空间：只用于保存系统中短期活动的数据，如排序数据$ 撤销表空间：用来帮助回退为=未提交的事务数据 那么为什么要创建表空间呢？对不同用户分配不同的表空间，方便管理有利于管理磁盘空间，提高i/o性能 一些基本的授权1234567891011创建用户没有授权【创建表】create table student(stu_id number(2),stu_name varchar2(10));create table student(stu_id number(2),stu_name varchar2(10))*第 1 行出现错误:ORA-01031: 权限不足?//使用system用户授权grant connect,resource to martin; //授权用户connect,resource 权限grant select on scott.emp to martin; //允许用户查看emp表中记录grant update on scott.emp to martin; //允许用户修改emp表中记录 同义词（公有和私有 //私有只能被当前模式用户访问）简化sql语句隐藏对象名称和所有者为分布式数据库的远程对象提供了位置透明性提供对象的公共访问 给用户martin授权同义词 grant create synonym to martin; ? 创建私有同义词 SQL&gt; create synonym sy_emp for system.employee; ? 同义词已创建。 ? SQL&gt; select *from sy_emp; ? 创建共有同义词（在物主用户上创建） SQL&gt; create public synonym public_sy_emp for employee; ? 同义词已创建。 ? SQL&gt; ? 删除私有同义词 SQL&gt; drop synonym martin.sy_emp; ? 同义词已删除。 ? SQL&gt; ? 删除共有同义词 SQL&gt; drop public synonym public_sy_emp; ? 同义词已删除。 SQL&gt; 创建序列和就是生成主键要用的，感觉不好用 SQL&gt; create sequence seq1 2 start with 10 3 increment by 1 4 maxvalue 2000 5 nocycle 6 cache 30; ? 序列已创建。 ? SQL&gt; create table toys(toyid number(2), toyname varchar2(10),toyprice number(4,2)); ? 表已创建。 ? SQL&gt; insert into toys(toyid,toyname,toyprice)values(seql.nextval,'杰尼龟',25); insert into toys(toyid,toyname,toyprice)values(seql.nextval,'杰尼龟',25) * 第 1 行出现错误: ORA-02289: 序列不存在 ? ? SQL&gt; insert into toys(toyid,toyname,toyprice)values(seq1.nextval,'杰尼龟',25); ? 已创建 1 行。 ? SQL&gt; insert into toys(toyid,toyname,toyprice)values(seq1.nextval,'憨八龟',35); ? 已创建 1 行。 ? SQL&gt; select * from toys; ? TOYID TOYNAME TOYPRICE ---------- -------------------- ---------- 11 杰尼龟 25 12 憨八龟 35 ? SQL&gt; create table tots(totid number(2), totname varchar2(10),totprice number(4,2)); ? 表已创建。 ? SQL&gt; insert into tots(totid,totname,totprice)values(seq1.nextval,'小火龙',40); ? 已创建 1 行。 ? SQL&gt; insert into tots(totid,totname,totprice)values(seq1.nextval,'毒龙钻',80); ? 已创建 1 行。 ? SQL&gt; select * from tots; ? TOTID TOTNAME TOTPRICE ---------- -------------------- ---------- 14 小火龙 40 15 毒龙钻 80 反向键索引目的：比如索引值是一个自动增长的列多个用户对集中在少数块上的索引行进行修改，容易引起资源的争用，比如对数据块的等待。此时建立反向索 引。语法：CREATE INDEX index_REVERSE_EMPNO ON table (column) REVERSE; 位图索引1、 何时创建：列中有非常多的重复的值时候。例如某列保存了 “性别”信息。Where 条件中包含了很多OR操作符。较少的update操作，因为要相应的跟新所有的bitmap2、 结构：位图索引使用位图作为键值，对于表中的每一数据行位图包含了TRUE(1)、FALSE(0)、或NULL值。3、 优点：位图以一种压缩格式存放，因此占用的磁盘空间比标准索引要小得多4、 语法：CREATE BITMAP INDEX index ON table (column[, column]…); 唯一索引1、 何时创建：当某列任意两行的值都不相同2、 当建立Primary Key(主键)或者Unique constraint(唯一约束)时，唯一索引将被自动建立3、 语法：CREATE UNIQUE INDEX index ON table (column); 熟练并背诵数据库建立索引的原则1，确定针对该表的操作是大量的查询操作还是大量的增删改操作。?2，尝试建立索引来帮助特定的查询。检查自己的sql语句，为那些频繁在where子句中出现的字段建立索引。?3，尝试建立复合索引来进一步提高系统性能。修改复合索引将消耗更长时间，同时，复合索引也占磁盘空间。?4，对于小型的表，建立索引可能会影响性能?5，应该避免对具有较少值的字段进行索引。?6，避免选择大型数据类型的列作为索引。?索引建立的原则?索引查询是数据库中重要的记录查询方法，要不要进入索引以及在那些字段上建立索引都要和实际数据库系统的查询要求结合来考虑，下面给出实际中的一些通用的原则：? 在经常用作过滤器的字段上建立索引；? 在SQL语句中经常进行GROUP BY、ORDER BY的字段上建立索引；? 在不同值较少的字段上不必要建立索引，如性别字段；? 对于经常存取的列避免建立索引；? 用于联接的列（主健/外健）上建立索引；? 在经常存取的多个列上建立复合索引，但要注意复合索引的建立顺序要按照使用的频度来确定；? 缺省情况下建立的是非簇集索引，但在以下情况下最好考虑簇集索引，如：含有有限数目（不是很少）唯一的列；进行大范围的查询；充分的利用索引可以减少表扫描I/0的次数，有效的避免对整表的搜索。当然合理的索引要建立在对各种查询的分析和预测中，也取决于DBA的所设计的数据库结构。 范围分区（超好用，就是麻烦）范围分区（数字类型） create table graderecord ( sno varchar2(10), sname varchar2(20), dormitory varchar2(3), grade int ) partition by range(grade) ( partition bujige values less than(60), --不及格 partition jige values less than(85), --及格 partition youxiu values less than(maxvalue) --优秀 ) ? 范围分区（日期类型） create table sales ( sales_id number, product_id varchar2(5), sales_date date not null, sales_cost number(10), areacode varchar2(10) ) partition by range(sales_date) ( partition p1 values less than(to_date('2013-04-1','yyyy-mm-dd')), partition p2 values less than(to_date('2013-07-1','yyyy-mm-dd')), partition p3 values less than(to_date('2013-10-1','yyyy-mm-dd')), partition p4 values less than(to_date('2014-01-1','yyyy-mm-dd')), partition p5 values less than(maxvalue) ); insert into sales values(1,'22',to_date('2013-04-1','yyyy-mm-dd'),92,'美国'); insert into sales values(2,'22',to_date('2013-05-1','yyyy-mm-dd'),92,'韩国'); insert into sales values(3,'23',to_date('2013-08-1','yyyy-mm-dd'),92,'中国'); insert into sales values(4,'24',to_date('2013-11-1','yyyy-mm-dd'),92,'日本'); insert into sales values(5,'25',to_date('2013-09-1','yyyy-mm-dd'),92,'俄罗斯'); 查询分区情况查询分区情况 SELECT table_name,partition_name,tablespace_name FROM user_tab_partitions WHERE table_name=UPPER('sales_interval1'); 间隔分区表，会自动创建分区=========================================================== | 间隔分区表 ============================================================ */ CREATE TABLE sales_interval1 (sales_id NUMBER NOT NULL, product_id VARCHAR2(5), sales_date DATE, sales_cost NUMBER(10), areacode VARCHAR2(5) ) PARTITION BY RANGE(sales_date) INTERVAL(NUMTOYMINTERVAL(1,'YEAR')) (PARTITION part1 VALUES LESS THAN (to_date('2011/01/01','yyyy/mm/dd'))) 使用分区查找信息查看分区并查询信息 SQL&gt; select table_name,partition_name from user_tab_partitions where table_name=upper('sales2'); ? TABLE_NAME ------------------------------------------------------------ PARTITION_NAME ------------------------------------------------------------ SALES2 P1 ? SALES2 SYS_P24 ? ? SQL&gt; select * from sales2 partition(sys_p24); ? SALES_ID PRODUCT_ID SALES_DATE SALES_COST AREACODE ---------- ---------- -------------- ---------- -------------------- 4 24 01-11月-13 92 日本 5 25 01-9月 -13 92 俄罗斯 ? SQL&gt; select * from sales2 partition(p1); ? SALES_ID PRODUCT_ID SALES_DATE SALES_COST AREACODE ---------- ---------- -------------- ---------- -------------------- 1 22 01-4月 -13 92 美国 2 22 01-5月 -13 92 韩国 3 23 01-8月 -13 92 中国 ? SQL&gt; ? 今天我是听着Ragga Bomb -Skrillex完成的]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库基础]]></title>
    <url>%2F2018%2F11%2F01%2FOracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Oracle简介1$ 众所周知，Oracle是个数据库，是Oracle公司的核心产品，优越的数据安全性和完整性，以及跨操作系统，跨硬件平台，主要特点：支持多用户，大事务的事务处理，在保持数据安全性和完整性方面性能优越，支持分布式事务处理，具有可移植性 Oracle基本概念$ 数据库：这不是我们平时所说的数据库，它是磁盘上存储数据的集合 $ 全局数据库名：用于区分一个数据库的标识，要唯一 $ 数据库实例：每个启动的数据库都对应一个数据库实例，有这个实例来访问数据库中的数据 $ 表空间：数据库若干个表空间组成，... $ 数据文件：数据文件扩展名.dbf 是来存储数据库数据的文件 $ 控制文件：控制文件扩展名.ctl 一个二进制文件,根据控制文件查找数据文件 $ 日志文件：日志文件扩展名.log,记录数据更改信息 Oracle重要的三个服务（建议全部设为手动，玩游戏的时候会卡的）$ OracleServiceSID：Oracle数据库服务，对应名为SID（系统标识符）我的是orcl $ OracleOraDb11g_home1TNSListener：监听器服务，如果要远程链接数据库服务器，就必须启动它 $ OracleDBConsoleSID：嗯，这个是控制台服务 SID（系统标识符） 连接Oracle数据库$ SQL*PLUS：system/orcl@orclDB //system是当前用户，orcl为密码，orclDB为使用的网络服务名 $ PL/SQL Developer：直接输入登录ok了 Oracle数据类型（列举几个比较难理解的）$ NUMBER(P,S)：p是精度，标识数字的有效位数，不包括小数点后，s标识小数点右边的位数，是四舍五入的哦 $ Date：SYSDATE标识返回当前的日期和时间，SYSTIMESTAMP返回当前的日期和时间和时区（精确到毫秒）可怕 $ LOB数据类型（大对象）：CLOB(字符clob，存储大量文字),BLOB(二进制lob，存储视频，图片这类)，BFILE(二进制文件，存储二进制文件)，NCLOB(存储大的nchar数据) Oracle中的伪列就像是一个表列，但是它并没有存储到表中，可以查询伪列，但是不能增删改 $ ROWID：每行都有一个行地址，ROWID就是返回该行地址 $ ROWNUM：返回一个数值代表行的次序，可以限制返回的行数（ROWNUM=1可以查到数据，ROWNUM=2就查不到，ROWNUM&gt;N也差不到，ROWNUM&lt;11查询10条记录） 查询数据不重复显示(DISTINCT)SELECT DISTINCT stuNmae from student 集合操作符UNION：返回连个查询选定的所有不重复行UNION ALL：符合两个查询锁定的所有行，包括重复的行INTERSECT：只返回两个查询都有的行MINUS：只返回第一个选定而未被第二个选定的行 连接操作符（||）将两个或多个字符串合并为一个字符串 SQL函数常用的转换函数 $ TO_CHAR 转字符串 （TO_CHAR(SYSDATE，‘YYYY 年fmMM月fmDD日 HH24:MI:SS’)） $ TO_DATE 转日期类型 $ TO_NUMBER 转数值类型 其他函数 $ NVL(EXP1,EXP2)：如果EXP1的值为null，返回EXP2,否则返回EXP1 $ NVL2(EXP1,EXP2,EXP3)：如果EXP1为null，返回EXP3,否则返回EXP2 $ DECODE(VALUE,IF1,THEN1,IF2,THEN2,ELSE)：VALUE值为IF1,则进入THEN1.. 分析函数马上11点了.. 我先走了，自行百度 今天我是听着THE NIGHT – Avicii完成的]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[漫漫归家路]]></title>
    <url>%2F2018%2F11%2F01%2F2018-DJ-MAG%2F</url>
    <content type="text"><![CDATA[漫漫归家路其实我喊了一次又一次，每一次，都清醒的认识到果然没有人回应我，无论怎么呼唤，怎么祈祷，还是有无法实现的东西。 最后还是没能找到家，迷路了，累到了，然后，我决定不在呼唤无法给予我回应的东西。——《夏目友人帐》漫漫回家路]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试问老天，不抵抗是罪吗？]]></title>
    <url>%2F2018%2F11%2F01%2F%E8%AF%95%E9%97%AE%E8%80%81%E5%A4%A9%EF%BC%8C%E4%B8%8D%E6%8A%B5%E6%8A%97%E6%98%AF%E7%BD%AA%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[OK Start任由其他人攀爬丝也会断,那么 “试问老天,不抵抗是罪吗?”太宰治 《人间失格》1「释迦牟尼看到在地狱挣扎的大盗，他干尽了恶事，但他唯一做的好事就是放过了一只蜘蛛，佛祖考虑救他一命，就取下一缕蛛丝朝着地狱垂了下去大盗无意间看到了这根蜘蛛丝，他顺着爬了上去，却发现后面罪人们跟着一起，自私的叫他们滚开，结果蛛丝断了，他们又回到血色的地狱」]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现在是星期三22:10分]]></title>
    <url>%2F2018%2F10%2F31%2F%E7%8E%B0%E5%9C%A8%E6%98%AF%E6%98%9F%E6%9C%9F%E4%B8%8922-10%E5%88%86%2F</url>
    <content type="text"><![CDATA[OK Start今天也是幸福的一天，晚上吃了两个烤馍，一根烤面筋，一根烤肠1$ 还有一件事，评论发送邮件功能开启]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的一天]]></title>
    <url>%2F2018%2F10%2F30%2F%E6%96%B0%E7%9A%84%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"></content>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[在一个突如其来的下午，一个可怕的想法在我的脑中出现 ###它诞生了…]]></content>
  </entry>
</search>
