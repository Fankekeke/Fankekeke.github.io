<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSM基础案例文件]]></title>
    <url>%2F2018%2F11%2F11%2FSSM%E5%9F%BA%E7%A1%80%E6%A1%88%E4%BE%8B%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[BaseController.java(这个基类用来设置继承他的子类的持久化类的date属性)12345@InitBinder public void initBinder(WebDataBinder dataBinder)&#123; System.out.println("initBinder======================="); dataBinder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), true)); &#125; dao层接口与xml接口1234567891011121314151617181920212223242526272829303132333435// 增加public int insertUser(User user);// 修改public int updateUser(User user);// 删除public int deleteUser(@Param("uid") int uid);//删除地址public int deleteAddress(@Param("uid") int uid);// 根据用户id查询地址信息public List&lt;User&gt; selectUser(@Param("uid") int uid);// 根据地址id查询用户信息public List&lt;Address&gt; selectAddress(@Param("addressid") int addressid);// 根据多个用户查询public List&lt;User&gt; selectUsers(UserVo vo);//动态trim模糊查询public List&lt;User&gt;seleteUserByUser(User user);//登录public User login(User user);//模糊查询public List&lt;User&gt;getUserList(User user);//根据id获取用户信息public User getUserById(@Param("uid") int uid);//获取所有用户public List&lt;User&gt;getUsers(); xml(mapper映射)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.dao.UserMapper"&gt; &lt;!-- 增加 --&gt; &lt;insert id="insertUser" parameterType="User"&gt; INSERT INTO user_info(user_name,user_pwd,user_birthday)VALUES(#&#123;userName&#125;,#&#123;userPwd&#125;,#&#123;userBirthday&#125;) &lt;/insert&gt; &lt;!-- 动态trim修改 --&gt; &lt;update id="updateUser" parameterType="User"&gt; UPDATE user_info &lt;trim prefix="set" suffixOverrides=","&gt; &lt;if test="userName!=null and userName!=''"&gt; user_name=#&#123;userName&#125;, &lt;/if&gt; &lt;if test="userPwd!=null and userPwd!=''"&gt; user_pwd=#&#123;userPwd&#125;, &lt;/if&gt; &lt;if test="userBirthday!=null and userBirthday!=''"&gt; user_birthday=#&#123;userBirthday&#125;, &lt;/if&gt; &lt;/trim&gt; where id=#&#123;id&#125; &lt;/update&gt; &lt;!-- 删除 --&gt; &lt;delete id="deleteUser" parameterType="int"&gt; DELETE from user_info WHERE id=#&#123;uid&#125; &lt;/delete&gt; &lt;!-- 删除地址 --&gt; &lt;delete id="deleteAddress" parameterType="int"&gt; DELETE from address_info WHERE user_id=#&#123;uid&#125; &lt;/delete&gt; &lt;!-- trim查询user --&gt; &lt;select id="seleteUserByUser" resultMap="UserList" parameterType="User"&gt; SELECT *FROM user_info WHERE user_name=#&#123;userName&#125; and user_pwd=#&#123;userPwd&#125; &lt;/select&gt; &lt;resultMap type="User" id="UserList"&gt; &lt;result property="id" column="id" /&gt; &lt;result property="userName" column="user_name" /&gt; &lt;result property="userPwd" column="user_pwd" /&gt; &lt;result property="userBirthday" column="user_birthday" /&gt; &lt;/resultMap&gt; &lt;!-- 根据用户id查询地址信息 --&gt; &lt;select id="selectUser" parameterType="User" resultMap="getAddress"&gt; SELECT * FROM user_info u,address_info a WHERE a.user_id=u.id AND u.id=#&#123;uid&#125; &lt;/select&gt; &lt;resultMap type="User" id="getAddress"&gt; &lt;result property="id" column="id" /&gt; &lt;result property="userName" column="user_name" /&gt; &lt;result property="userPwd" column="user_pwd" /&gt; &lt;result property="userBirthday" column="user_birthday" /&gt; &lt;collection property="addresses" ofType="Address"&gt; &lt;result property="id" column="id" /&gt; &lt;result property="addressName" column="address_name" /&gt; &lt;result property="userId" column="user_id" /&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 根据地址id查询用户信息 --&gt; &lt;select id="selectAddress" resultMap="getUser"&gt; SELECT * FROM user_info u,address_info a WHERE a.user_id=u.id AND a.id=#&#123;addressid&#125; &lt;/select&gt; &lt;resultMap type="Address" id="getUser"&gt; &lt;result property="id" column="id" /&gt; &lt;result property="addressName" column="address_name" /&gt; &lt;result property="userId" column="user_id" /&gt; &lt;association property="user" javaType="User"&gt; &lt;result property="id" column="id" /&gt; &lt;result property="userName" column="user_name" /&gt; &lt;result property="userPwd" column="user_pwd" /&gt; &lt;result property="userBirthday" column="user_birthday" /&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 根据多个用户查询 --&gt; &lt;select id="selectUsers" parameterType="UserVo" resultMap="UserList"&gt; SELECT * FROM user_info &lt;where&gt; &lt;foreach collection="list" item="id" open="and (" close=")" separator="or"&gt; id=#&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- 登录 --&gt; &lt;select id="login" resultMap="UserList" parameterType="User"&gt; SELECT * FROM user_info WHERE user_name=#&#123;userName&#125; and user_pwd=#&#123;userPwd&#125; &lt;/select&gt; &lt;!-- 模糊查询 --&gt; &lt;select id="getUserList" resultMap="UserList" parameterType="User"&gt; SELECT * FROM user_info &lt;trim prefix="where" prefixOverrides="and | or"&gt; &lt;if test="userName!=null and userName!=''"&gt; and user_name like CONCAT('%',#&#123;userName&#125;,'%') &lt;/if&gt; &lt;if test="id!=null and id!=''"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; &lt;!-- 根据id获取用户信息 --&gt; &lt;select id="getUserById" resultMap="UserList"&gt; select * from user_info where id=#&#123;uid&#125; &lt;/select&gt; &lt;!-- 获取所有用户 --&gt; &lt;select id="getUsers" resultMap="UserList"&gt; select * from user_info &lt;/select&gt;&lt;/mapper&gt; pojo类(持久化类包括JSR-303验证)1234567891011121314//id private int id; //name @NotEmpty(message="用户名称不能为空") private String userName; //pwd @NotEmpty(message="用户密码不能为空") private String userPwd; //birthday @JSONField(format="yyyy-MM-dd") private Date userBirthday; service层(实现类)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687@Service("userServiceImpl")public class UserServiceImpl implements UserService &#123; @Autowired @Qualifier("userMapper") private UserMapper userMapper; public UserMapper getUserMapper() &#123; return userMapper; &#125; public void setUserMapper(UserMapper userMapper) &#123; this.userMapper = userMapper; &#125; @Override public int addUser(User user) &#123; // TODO Auto-generated method stub return userMapper.insertUser(user); &#125; @Override public int modifyUser(User user) &#123; // TODO Auto-generated method stub return userMapper.updateUser(user); &#125; @Override public int removerUser(int uid) &#123; // TODO Auto-generated method stub userMapper.deleteAddress(uid); return userMapper.deleteUser(uid); &#125; @Override public List&lt;User&gt; findUser(int uid) &#123; // TODO Auto-generated method stub return userMapper.selectUser(uid); &#125; @Override public List&lt;Address&gt; findAddress(int addressid) &#123; // TODO Auto-generated method stub return userMapper.selectAddress(addressid); &#125; @Override public List&lt;User&gt; findUsers(UserVo vo) &#123; // TODO Auto-generated method stub return userMapper.selectUsers(vo); &#125; @Override public List&lt;User&gt; findUserByUser(User user) &#123; // TODO Auto-generated method stub return userMapper.seleteUserByUser(user); &#125; @Override public int deleteAddress(int uid) &#123; // TODO Auto-generated method stub return userMapper.deleteAddress(uid); &#125; @Override public User login(User user) &#123; // TODO Auto-generated method stub return userMapper.login(user); &#125; @Override public List&lt;User&gt; getUserList(User user) &#123; // TODO Auto-generated method stub return userMapper.getUserList(user); &#125; @Override public User getUserById(int uid) &#123; // TODO Auto-generated method stub return userMapper.getUserById(uid); &#125; @Override public List&lt;User&gt; getUsers() &#123; // TODO Auto-generated method stub return userMapper.getUsers(); &#125; logger(AOP)1234567891011121314151617181920212223242526272829303132/** * 定义切面 * @author F117 * */@Aspectpublic class logger &#123; private static final Logger LOGGER=Logger.getLogger(logger.class); @Pointcut("execution(* cn.service..*.*(..))") public void Pointcut()&#123;&#125; @AfterReturning(pointcut="Pointcut()",returning="returnCalue") public void afterReturning(JoinPoint jp,Object returnCalue)&#123; LOGGER.info("调用"+jp.getTarget()+"的"+jp.getSignature().getName()+"方法,返回值"+returnCalue); &#125; @Around("Pointcut()") public Object aroundLogger(ProceedingJoinPoint jp) throws Throwable&#123; LOGGER.info("调用"+jp.getTarget()+"的"+jp.getSignature().getName()+"方法,方法入参"+Arrays.toString(jp.getArgs())); try &#123; Object result=jp.proceed(); LOGGER.info("调用"+jp.getTarget()+"的"+jp.getSignature().getName()+"方法,返回值"+result); return result; &#125; catch (Throwable e) &#123; // TODO: handle exception throw e; &#125;finally &#123; LOGGER.info("====&gt;"+jp.getSignature().getName()+"方法结束"); &#125; &#125;&#125; StringToDateConverter(自定义转换器)123456789101112131415161718192021222324public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123; private String dataPattern; public StringToDateConverter(String dataPattern) &#123; System.out.println("StringToDateConverter conver"+dataPattern); this.dataPattern=dataPattern; &#125; @Override public Date convert(String s) &#123; // TODO Auto-generated method stub Date date=null; try &#123; date= new SimpleDateFormat(dataPattern).parse(s); System.out.println("convert date:"+date); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return date; &#125;&#125; applicationContextl.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd"&gt; &lt;context:component-scan base-package="cn.service"&gt;&lt;/context:component-scan&gt; &lt;context:component-scan base-package="cn.controller"&gt;&lt;/context:component-scan&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;bean class="cn.tool.logger" /&gt; &lt;!-- 读取数据库配置文件 --&gt; &lt;context:property-placeholder location="classpath:database.properties" /&gt; &lt;!-- JNDI获取数据源(使用dbcp连接池) --&gt; &lt;bean class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" scope="singleton" id="dataSource"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;user&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;" /&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;" /&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;" /&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;" /&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;" /&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;" /&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;" /&gt; &lt;!-- sql 心跳 --&gt; &lt;property name="testWhileIdle" value="true" /&gt; &lt;property name="testOnBorrow" value="false" /&gt; &lt;property name="testOnReturn" value="false" /&gt; &lt;property name="validationQuery" value="select 1" /&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="60000" /&gt; &lt;property name="numTestsPerEvictionRun" value="$&#123;maxActive&#125;" /&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactoryBean --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;property name="configLocation" value="classpath:mybatis-configl.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Dao --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.dao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务增强 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置切面 --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression="execution(* cn.service..*.*(..))" id="myPoint" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="myPoint" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; database.properties1234567891011driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/sm_db?useUnicode=true&amp;characterEncoding=utf-8user=rootpassword=rootminIdle=45maxIdle=50initialSize=5maxActive=100maxWait=100removeAbandonedTimeout=180removeAbandoned=true log4j.properties123456789101112131415161718192021222324252627282930313233343536log4j.rootLogger=DEBUG,CONSOLE,file#log4j.rootLogger=ERROR,ROLLING_FILElog4j.logger.cn.smbms.dao=debuglog4j.logger.com.ibatis=debug log4j.logger.com.ibatis.common.jdbc.SimpleDataSource=debug log4j.logger.com.ibatis.common.jdbc.ScriptRunner=debug log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=debug log4j.logger.java.sql.Connection=debug log4j.logger.java.sql.Statement=debug log4j.logger.java.sql.PreparedStatement=debug log4j.logger.java.sql.ResultSet=debug log4j.logger.org.tuckey.web.filters.urlrewrite.UrlRewriteFilter=debug####################################################################################### Console Appender \u65e5\u5fd7\u5728\u63a7\u5236\u8f93\u51fa\u914d\u7f6e######################################################################################log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.Threshold=errorlog4j.appender.CONSOLE.Target=System.outlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern= [%p] %d %c - %m%n####################################################################################### DailyRolling File \u6bcf\u5929\u4ea7\u751f\u4e00\u4e2a\u65e5\u5fd7\u6587\u4ef6\uff0c\u6587\u4ef6\u540d\u683c\u5f0f:log2009-09-11######################################################################################log4j.appender.file=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.file.DatePattern=yyyy-MM-ddlog4j.appender.file.File=log.loglog4j.appender.file.Append=truelog4j.appender.file.Threshold=errorlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-M-d HH:mm:ss&#125;%x[%5p](%F:%L) %m%nlog4j.logger.com.opensymphony.xwork2=error mybatis-configl.xml1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置mybatis的log实现为LOG4J --&gt; &lt;settings&gt; &lt;!-- &lt;setting name="logImpl" value="LOG4J" /&gt; --&gt; &lt;setting name="lazyLoadingEnabled" value="false"/&gt; &lt;setting name="autoMappingBehavior" value="FULL"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name="cn.pojo"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; springmvc-servlet.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 配置处理器映射 HandlerMapping --&gt; &lt;!-- &lt;bean name="/index.html" class="cn.smbms.controller.IndexController" /&gt; --&gt; &lt;!-- &lt;bean name="/welcome" class="cn.smbms.controller.IndexController" /&gt; --&gt; &lt;!-- &lt;bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;/bean&gt; --&gt; &lt;context:component-scan base-package="cn.controller" /&gt; &lt;!-- 自定义转换器 --&gt; &lt;bean id="myConversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;bean class="cn.tool.StringToDateConverter"&gt; &lt;constructor-arg type="java.lang.String" value="yyyy-MM-dd" /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;mvc:annotation-driven&gt; &lt;!-- 消息转换器 --&gt; &lt;mvc:message-converters&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean class="com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="features"&gt; &lt;list&gt; &lt;value&gt;WriteDateUseDateFormat&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 完成视图的对应 --&gt; &lt;!-- 对转向页面的路径解析。prefix：前缀， suffix：后缀 --&gt; &lt;!-- &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; --&gt; &lt;!-- 配置多视图解析器 ：允许统一的内容数据呈现在不同的view中 --&gt; &lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt; &lt;!-- 支持参数匹配 --&gt; &lt;property name="favorParameter" value="true" /&gt; &lt;property name="mediaTypes"&gt; &lt;map&gt; &lt;entry key="html" value="text/html;charset=UTF-8"&gt;&lt;/entry&gt; &lt;entry key="json" value="application/json;charset=UTF-8"&gt;&lt;/entry&gt; &lt;entry key="xml" value="application/xml;charset=UTF-8"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 网页视图解析器 --&gt; &lt;property name="viewResolvers"&gt; &lt;list&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;mvc:resources location="/statics/" mapping="/statics/**"&gt;&lt;/mvc:resources&gt; &lt;!-- 全局异常的配置 --&gt; &lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt; &lt;property name="exceptionMappings"&gt; &lt;props&gt; &lt;prop key="java.lang.RuntimeException"&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置MulitpartResolver，用于文件上传 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="5000000" /&gt; &lt;property name="defaultEncoding" value="utf-8" /&gt; &lt;/bean&gt;&lt;/beans&gt; web.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;CG09&lt;/display-name&gt; &lt;!-- 配置环境参数，指定spring配置文件的所在目录--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContextl.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 配置spring的ContextLoaderListener监听器，初始化spring容器--&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.util.Log4jConfigListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt;&lt;param-name&gt;webAppRootKey&lt;/param-name&gt;&lt;param-value&gt; app.root &lt;/param-value&gt;&lt;/context-param&gt; &lt;/web-app&gt; UserController(核心)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130@Controller@RequestMapping("/user")public class UserController extends BaseController &#123; public UserService getUserService() &#123; return userService; &#125; public void setUserService(UserService userService) &#123; this.userService = userService; &#125; private Logger logger = Logger.getLogger(UserController.class); @Autowired @Qualifier("userServiceImpl") private UserService userService; // 实现跳转到登录页 @RequestMapping(value = "/login.html") public String login() &#123; logger.info("用户跳转到登录页====================&gt;"); return "login"; &#125; // 主页面 @RequestMapping(value = "main.html") public String hetmain() &#123; logger.info("用户跳转到主页面====================&gt;"); return "main"; &#125; // 实现登录 @RequestMapping(value = "dologin.html", method = RequestMethod.POST) public String doLogin(String userName, String userPwd, HttpSession session, HttpServletRequest request,RedirectAttributes attr) throws Exception &#123; logger.info("登录中======================&gt;"); // 调用service方法进行用户匹配 User user=new User(); user.setUserName(userName); user.setUserPwd(userPwd); User user2=new User(); user2 = userService.login(user); if(null!=user2)&#123;//登陆成功 attr.addFlashAttribute("u1", user2); return "redirect:/user/main.html"; //response.sendRedirect("jsp/frame.jsp") &#125;else&#123; request.setAttribute("error","用户名密码不正确"); return "login"; &#125; &#125; //根据用户id获取用户信息 @RequestMapping(value="usermodify.html",method = RequestMethod.GET) public String getUserByID(@RequestParam int id,Model model)&#123; User user=new User(); user=userService.getUserById(id); model.addAttribute("user", user); return "toEditUserView"; &#125; @RequestMapping(value="usermodifysave.html",method=RequestMethod.POST) public String modifyUserSave(User user,HttpSession session)&#123; if(userService.modifyUser(user)&gt;0)&#123; return "redirect:/user/userlist.html"; &#125; return "toEditUserView"; &#125; @RequestMapping(value="userlist.html",method = RequestMethod.GET) public String getUserList(Model model)&#123; List&lt;User&gt;userList=new ArrayList&lt;User&gt;(); userList=userService.getUsers(); model.addAttribute("userList", userList); return "userInfoList"; &#125; //添加 @RequestMapping(value="addUser.html",method=RequestMethod.GET) public String add(@ModelAttribute("user") User user,Model model)&#123; return "doSaveUserInfo"; &#125; @RequestMapping(value="addUsersave.html",method=RequestMethod.POST) public String addSave(@Valid User user, BindingResult bindingResult, HttpSession session)&#123; if(bindingResult.hasErrors())&#123; return "doSaveUserInfo"; &#125; int num=userService.addUser(user); System.out.println("==================="+num); if(num&gt;0)&#123; return "redirect:/user/userlist.html"; &#125; return "doSaveUserInfo"; &#125; @RequestMapping(value = "/error.html") public String error() &#123; return "error"; &#125; @RequestMapping(value="userdelete.html",method = RequestMethod.GET) public String getUserByIDs(@RequestParam int id,Model model)&#123; User user=new User(); user=userService.getUserById(id); model.addAttribute("user", user); return "deleteUserInfo"; &#125; //删除 @RequestMapping(value="/deleteUser.html",method=RequestMethod.POST) public String deleteUser(@RequestParam int id)&#123; int nums=userService.removerUser(id); System.out.println("===================&gt;"+nums); if(nums&gt;=1)&#123; return "redirect:/user/userlist.html"; &#125;else&#123; return "error"; &#125; &#125;&#125; 保存文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//跳转到新增appinfo页面 @RequestMapping(value="/appinfoadd",method=RequestMethod.GET) public String add(@ModelAttribute("appInfo") AppInfo appInfo)&#123; return "developer/appinfoadd"; &#125; //保存appinfo数据 @RequestMapping(value="/appinfoaddsave",method=RequestMethod.POST) public String addSave(AppInfo appInfo,HttpSession session,HttpServletRequest request, @RequestParam(value="a_logoPicPath",required= false) MultipartFile attach)&#123; String logoPicPath = null; String logoLocPath = null; if(!attach.isEmpty())&#123; String path = request.getSession().getServletContext().getRealPath("statics"+java.io.File.separator+"uploadfiles"); logger.info("uploadFile path: " + path); String oldFileName = attach.getOriginalFilename();//原文件名 String prefix = FilenameUtils.getExtension(oldFileName);//原文件后缀 int filesize = 500000; if(attach.getSize() &gt; filesize)&#123;//上传大小不得超过 50k request.setAttribute("fileUploadError", Constants.FILEUPLOAD_ERROR_4); return "developer/appinfoadd"; &#125;else if(prefix.equalsIgnoreCase("jpg") || prefix.equalsIgnoreCase("png") ||prefix.equalsIgnoreCase("jepg") || prefix.equalsIgnoreCase("pneg"))&#123;//上传图片格式 String fileName = appInfo.getAPKName() + ".jpg";//上传LOGO图片命名:apk名称.apk File targetFile = new File(path,fileName); if(!targetFile.exists())&#123; targetFile.mkdirs(); &#125; try &#123; attach.transferTo(targetFile); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); request.setAttribute("fileUploadError", Constants.FILEUPLOAD_ERROR_2); return "developer/appinfoadd"; &#125; logoPicPath = request.getContextPath()+"/statics/uploadfiles/"+fileName; //绝对路径 logoLocPath = path+File.separator+fileName; //相对路径 &#125;else&#123; request.setAttribute("fileUploadError", Constants.FILEUPLOAD_ERROR_3); return "developer/appinfoadd"; &#125; &#125; appInfo.setCreatedBy(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appInfo.setCreationDate(new Date()); appInfo.setLogoPicPath(logoPicPath); appInfo.setLogoLocPath(logoLocPath); appInfo.setDevId(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appInfo.setStatus(1); try &#123; if(appInfoService.add(appInfo))&#123; return "redirect:/dev/flatform/app/list"; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return "developer/appinfoadd"; &#125; JSP页面列表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort() + path + "/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt;&lt;head&gt;&lt;base href="&lt;%=basePath%&gt;"&gt;&lt;title&gt;My JSP 'userInfoList.jsp' starting page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="user/addUser.html"&gt;添加用户&lt;/a&gt; &lt;h2&gt;用户列表&lt;/h2&gt; &lt;table class="providerTable" cellpadding="0" cellspacing="0"&gt; &lt;tr class="firstTr"&gt; &lt;th width="10%"&gt;用户id&lt;/th&gt; &lt;th width="20%"&gt;用户名称&lt;/th&gt; &lt;th width="10%"&gt;用户密码&lt;/th&gt; &lt;th width="10%"&gt;生日日期&lt;/th&gt; &lt;th width="10%"&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach var="user" items="$&#123;userList &#125;" varStatus="status" begin="0"&gt; &lt;tr&gt; &lt;td&gt;&lt;span&gt;$&#123;user.id &#125;&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;$&#123;user.userName &#125;&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;$&#123;user.userPwd&#125;&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;$&#123;user.userBirthday.year+1900&#125;-&lt;c:if test="$&#123;user.userBirthday.month+1 &lt; 10&#125;"&gt;0&lt;/c:if&gt;$&#123;user.userBirthday.month+1&#125;-&lt;c:if test="$&#123;user.userBirthday.date &lt; 10&#125;"&gt;0&lt;/c:if&gt;$&#123;user.userBirthday.date&#125;&lt;/span&gt; &lt;/td&gt; &lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/user/usermodify.html?id=$&#123;user.id &#125;"&gt;修改&lt;/a&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/user/userdelete.html?id=$&#123;user.id &#125;"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 添加12345678910111213141516171819202122232425262728293031323334353637383940&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;%@taglib prefix="fm" uri="http://www.springframework.org/tags/form" %&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;My JSP 'doSaveUserInfo.jsp' starting page&lt;/title&gt; &lt;meta http-equiv="pragma" content="no-cache"&gt; &lt;meta http-equiv="cache-control" content="no-cache"&gt; &lt;meta http-equiv="expires" content="0"&gt; &lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt; &lt;meta http-equiv="description" content="This is my page"&gt; &lt;!-- &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;新增用户&lt;/h2&gt; &lt;fm:form method="post" modelAttribute="user" action="$&#123;pageContext.request.contextPath&#125;/user/addUsersave.html"&gt; &lt;fm:errors path="userName"/&gt;&lt;br/&gt; 用户名称：&lt;fm:input path="userName"/&gt;&lt;br/&gt; &lt;fm:errors path="userPwd"/&gt;&lt;br/&gt; 用户密码：&lt;fm:password path="userPwd"/&gt;&lt;br/&gt; &lt;fm:errors path="userBirthday"/&gt;&lt;br/&gt; 用户生日：&lt;fm:input path="userBirthday" Class="Wdate" id="birthday" name="userBirthday" readonly="readonly" /&gt;&lt;br/&gt; &lt;input type="submit" value="保存"&gt; &lt;/fm:form&gt; &lt;/body&gt;&lt;/html&gt; 修改1234567891011121314 &lt;body&gt; &lt;h2&gt;用户修改页面&lt;/h2&gt; &lt;form action="$&#123;pageContext.request.contextPath&#125;/user/usermodifysave.html" method="post"&gt; &lt;input type="hidden" name="id" value="$&#123;user.id &#125;"&gt;&lt;br/&gt; &lt;input type="text" name="userName" value="$&#123;user.userName &#125;"&gt;&lt;br/&gt; &lt;input type="text" name="userPwd" value="$&#123;user.userPwd &#125;"&gt;&lt;br/&gt; &lt;input type="text" name="userBirthday" value="$&#123;user.userBirthday &#125;"&gt;&lt;br/&gt; &lt;input type="submit" value="修改"&gt; &lt;input type="button" value="返回主页面"&gt; &lt;/form&gt; &lt;/body&gt; ### 有形的东西迟早会凋零，但只有回忆是永远不会凋零的]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hibernate关系映射]]></title>
    <url>%2F2018%2F11%2F08%2FHibernate%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[映射关系的形成 hibernate在实现ORM功能的时候主要用到的文件有：映射类（.Java）、映射文件（.hbm.xml）和数据库配置文件（.properties/.cfg.xml） 映射类（*.java）：它是描述数据库表的结构，表中的字段在类中被描述成属性，将来就可以实现把表中的记录映射成为该类的对象了。 映射文件（*.hbm.xml）：它是指定数据库表和映射类之间的关系，包括映射类和数据库表的对应关系、表字段和类属性类型的对应关系以及表字段和类属性名称的对应关系等。 数据库配置文件（.properties/.cfg.xml）：它是指定与数据库连接时需要的连接信息，比如连接哪种数据库、登录数据库的用户名、登录密码以及连接字符串等。当然还可以把映射类的地址映射信息放在这里。 关联关系(是有方向的)Dept(部门表)，Emp(员工表),一个部门下有多个员工，而一个员工只属于一个部门，所以Emp-&gt;Dept是多对一的关系，每个Emp对象只会引用一个Dept对象,而Dept-&gt;Emp是一对多的关系，表示每个Dept对象会引用一组Emp对象，因此在Emp类中应该定义一个Dept类型的属性，而在Dept类中需要定义一个集合类型的属性，来引用Emp所有关联的Emp对象，如果只配置一方被成为单向映射，两个都配置被称为双向 配置单项一对多在Emp类中定义Dept对象(全部都要提供getter与setter方法)12345678//USER_IDprivate Integer userId;//USER_NAMEprivate String userName;//DEPTNOprivate Integer deptNo;//Deptprivate Depts depts; Emp.hbm.xml配置元素1&lt;many-to-one name="depts" column="`DEPTNO`" class="cn.house.pojo.Depts" cascade="save-update"&gt;&lt;/many-to-one&gt; name：设定持久化类的属性名，此处为Emp类中的dept属性column：设定持久化类的属性对应的表的外键，此处为Emp表的外键DEPTNOclass:设定持久化类的属性的类型明天再见，这章太难理解了]]></content>
      <categories>
        <category>SSH</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HQL实用技术]]></title>
    <url>%2F2018%2F11%2F08%2FHQL%E5%AE%9E%E7%94%A8%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[今天来学习HQL语句 编写HQL语句from子句 例：from com.entity.Dept; from Dept dept;–为持久化类Dept指定了别名dept；可省略包名 select子句 例：select dept from Dept as dept; select dept.DeptName from Dept as dept;–选取单个属性，可选择多个 where子句例：from Dept where DeptName=’SALES’; from Dept dept where dept.DeptName=’SALES’; from Dept dept where dept.location is not null;–查询地址不为空的部门 使用表达式 例：from Dept dept where lower(dept.DeptName)=’sales’;–lower()把字符串中的字母转换成小写 from Emp where year(hireDate)=1980;–year()用于获取日期字段的年份 order by子句 例：from Emp order by hireDate asc from Emp order by hireDate,salary desc; 执行HQL语句 执行HQL语句步骤 1、获取session对象 2、编写HQL语句 3、创建Query对象 4、执行查询 先给大家看一些简单的例子吧 DAO层123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 查询public List&lt;User&gt; findAllUser() &#123; return this.currentSession().createQuery("from User").list();&#125;// Iterator返回public Iterator&lt;User&gt; findAllUser_iterate() &#123; return this.currentSession().createQuery("from User").iterate();&#125;// 根据姓名查询public Iterator&lt;User&gt; findAllUserByName() &#123; return this.currentSession().createQuery("from User where name='李钰洋'").iterate();&#125;// 获取唯一结果public Long countUser() &#123; return (Long) this.currentSession().createQuery("select count(id) from User").uniqueResult();&#125;// 参数查询,位置从0开始public List&lt;User&gt; findUserByName(String name) &#123; return this.currentSession().createQuery("from User where name=?").setString(0, name).list();&#125;// 按参数名绑定public List&lt;User&gt; findUserByName1(String name) &#123; return this.currentSession().createQuery("from User where name=:name1").setString("name1", name).list();&#125;// 多参数查询 +结合位置public List&lt;User&gt; findByCoditions(Object[] param) &#123; Query query = this.currentSession().createQuery("from User where name=? and telephone=?"); if (param != null &amp;&amp; param.length != 0) &#123; for (int i = 0; i &lt; param.length; i++) &#123; query.setParameter(i, param[i]); &#125; &#125; return query.list();&#125;// 多参数查询 +结合名称 赛高public List&lt;User&gt; findByCoditions(User param) &#123; Query query = this.currentSession().createQuery("from User where name=:name and telephone=:telephone"); query.setProperties(param); // 赛高 return query.list();&#125;// 多参数查询 +结合名称 赛高 动态hqlpublic List&lt;User&gt; findByCoditions(String hql, User param) &#123; Query query = this.currentSession().createQuery(hql); query.setProperties(param); // 赛高 return query.list();&#125;// 多参数查询 +结合名称 赛高 动态hql mappublic List&lt;User&gt; findByCoditions(String hql, Map&lt;String, Object&gt; param) &#123; Query query = this.currentSession().createQuery(hql); query.setProperties(param); // 赛高 return query.list();&#125;// 分页public List&lt;User&gt; findByPage(int pageNo, int pageSize) &#123; return this.currentSession().createQuery("from User order by id").setFirstResult((pageNo - 1) * pageSize) .setMaxResults(pageSize).list();&#125;// 根据id降序获取前3public List&lt;User&gt; findByOrder(int topSize) &#123; return this.currentSession().createQuery("from User order by id").setMaxResults(topSize).list();&#125;// 投影查询public List findByProjection() &#123; return this.currentSession().createQuery("select name from User").list();&#125;// 投影查询 查多列public List&lt;Object[]&gt; findByProjection2() &#123; return this.currentSession().createQuery("select name,telephone from User").list();&#125;//构造函数封装对象public List&lt;User&gt; findByProjection3() &#123; return this.currentSession().createQuery("select new User(name,telephone) from User").list();&#125; SERVICE层123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292// 查询public List&lt;User&gt; findAllUser() &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findAllUser(); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// Iterator返回public Iterator&lt;User&gt; findAllUser_Iterator() &#123; Transaction tx = null; Iterator&lt;User&gt; list = null; try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findAllUser_iterate(); User u = new User(); while (list.hasNext()) &#123; u = list.next(); System.out.println(u.getName() + "艸"); &#125; tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 根据姓名Iterator返回public Iterator&lt;User&gt; findAllUser_IteratorByName() &#123; Transaction tx = null; Iterator&lt;User&gt; list = null; try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findAllUserByName(); User u = new User(); while (list.hasNext()) &#123; u = list.next(); System.out.println(u.getName() + "\\" + u.getTelephone()); &#125; tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 返回唯一结果public Long findAllUser_count() &#123; Transaction tx = null; Long count = null; try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); count = userDao.countUser(); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return count;&#125;// 查询+参数public List&lt;User&gt; findAllUser_Name(String name) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findUserByName(name); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 查询+名称参数public List&lt;User&gt; findAllUser_Name1(String name) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findUserByName1(name); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 查询+多参数public List&lt;User&gt; findAllbyCondinitions(Object[] param) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByCoditions(param); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 查询+多参数public List&lt;User&gt; findAllbyCondinitions(User param) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByCoditions(param); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 查询+多参数 动态hqlpublic List&lt;User&gt; findAllbyCondinitions1(User param) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); StringBuilder hql = new StringBuilder("from User where 1=1"); if (param.getName() != null &amp;&amp; param.getName().length() != 0) &#123; hql.append(" and name=:name"); &#125; if (param.getTelephone() != null &amp;&amp; param.getTelephone().length() != 0) &#123; hql.append(" and telephone=:telephone"); &#125; list = userDao.findByCoditions(hql.toString(), param); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 查询+多参数 动态hqlpublic List&lt;User&gt; findAllbyCondinitions2(Map&lt;String, Object&gt; param) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); StringBuilder hql = new StringBuilder("from User where 1=1"); if (param.get("name") != null &amp; ((String) param.get("name")).length() != 0) &#123; hql.append(" and name=:name"); &#125; if (param.get("telephone") != null &amp; ((String) param.get("telephone")).length() != 0) &#123; hql.append(" and telephone=:telephone"); &#125; list = userDao.findByCoditions(hql.toString(), param); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 查询分页public List&lt;User&gt; findAllbyCondinitions3(int pageNo, int pageSize) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByPage(pageNo, pageSize); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 根据id降序查询public List&lt;User&gt; findAllbyCondinitions4(int topSize) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByOrder(topSize); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 投影查询public List&lt;Object&gt; findAllbyCondinitions5() &#123; Transaction tx = null; List&lt;Object&gt; list = null; try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByProjection(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 投影查询 object数组public List&lt;Object[]&gt; findAllbyCondinitions6() &#123; Transaction tx = null; List&lt;Object[]&gt; list = null; try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByProjection2(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125;// 投影查询 构造函数对象public List&lt;User&gt; findAllbyCondinitions7() &#123; Transaction tx = null; List&lt;User&gt; list = null; try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByProjection3(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list;&#125; 参数绑定形式按参数位置绑定例：Query query = session.createQuery（”from Emp where job=? and salary&gt;?”）； query.setString(0,job);–第一个参数位置为零 query.setDouble(1,salary); 按参数名称绑定 例：Query query = session.createQuery(“from Emp where job=:empJob and salary&gt;:empSalary”); query.setString(“empJob”,empJob); query.setDouble(“empSalary”,empSalary); //注意这里的所有属性包括表名都是.hbm.xml文件映射来的持久化类属性 绑定各种类型的参数 setBoolean():绑定类型为Boolean的参数 setByte():绑定类型为Byte的参数 setDouble():绑定类型为Double的参数 setDate():绑定类型为Date的参数 setString():绑定类型为String的参数 以上方法都有两种重载方式 如： setString(int position,String val);–按位置绑定参数 setString(String name,String val);–按名称绑定参数 setParameter()方法：绑定任意类型参数该方法使用object类型作为HQL参数的类型，当不便指定参数的类型师，使用setParameter()方法 setProperties(直接放入一个对象)赛高123456789101112131415161718192021222324public List&lt;User&gt; findByCoditions(User param) &#123; Query query = this.currentSession().createQuery("from User where name=:name and telephone=:telephone"); query.setProperties(param); // 赛高 return query.list(); &#125; ----- public List&lt;User&gt; findAllbyCondinitions(User param) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByCoditions(param); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list; &#125; //前提是字段一致，并且不为空（动态hql除外） 使用uniqueResult()方法获取唯一结果当查询结果不唯一时，不能使用query.uniqueResult()方法，否则会报错 查询LIST()12345678910111213141516171819202122public List&lt;User&gt; findAllUser() &#123; return this.currentSession().createQuery("from User").list();&#125;--service使用list集合public List&lt;User&gt; findAllUser() &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findAllUser(); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list; &#125; ITERATE()12345678910111213141516171819202122232425262728public Iterator&lt;User&gt; findAllUser_iterate() &#123; return this.currentSession().createQuery("from User").iterate(); &#125; --service使用Iterator&lt;&gt; public Iterator&lt;User&gt; findAllUser_Iterator() &#123; Transaction tx = null; Iterator&lt;User&gt; list = null; try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findAllUser_iterate(); User u = new User(); while (list.hasNext()) &#123; u = list.next(); System.out.println(u.getName() + "艸"); &#125; tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list; &#125; //ITERATE()要比LIST()效率好，但是ITERATE必须在service层输出或赋值，它是先查主键id，再去查找数据 动态查询123456789101112131415161718192021222324252627282930public List&lt;User&gt; findByCoditions(String hql, User param) &#123; Query query = this.currentSession().createQuery(hql); query.setProperties(param); // 赛高 return query.list(); &#125; ---主要的service public List&lt;User&gt; findAllbyCondinitions1(User param) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); StringBuilder hql = new StringBuilder("from User where 1=1"); if (param.getName() != null &amp;&amp; param.getName().length() != 0) &#123; hql.append(" and name=:name"); &#125; if (param.getTelephone() != null &amp;&amp; param.getTelephone().length() != 0) &#123; hql.append(" and telephone=:telephone"); &#125; list = userDao.findByCoditions(hql.toString(), param); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list; &#125; 动态查询 map参数12345678910111213141516171819202122232425262728293031public List&lt;User&gt; findByCoditions(String hql, Map&lt;String, Object&gt; param) &#123; Query query = this.currentSession().createQuery(hql); query.setProperties(param); // 赛高 return query.list(); &#125; ---service public List&lt;User&gt; findAllbyCondinitions2(Map&lt;String, Object&gt; param) &#123; Transaction tx = null; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); StringBuilder hql = new StringBuilder("from User where 1=1"); if (param.get("name") != null &amp; ((String) param.get("name")).length() != 0) &#123; hql.append(" and name=:name"); &#125; if (param.get("telephone") != null &amp; ((String) param.get("telephone")).length() != 0) &#123; hql.append(" and telephone=:telephone"); &#125; list = userDao.findByCoditions(hql.toString(), param); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list; &#125; 分页查询主要的是setFirstResult()与setMaxResults()1234public List&lt;User&gt; findByPage(int pageNo, int pageSize) &#123; return this.currentSession().createQuery("from User order by id").setFirstResult((pageNo - 1) * pageSize) .setMaxResults(pageSize).list(); &#125; 获取前几个数据123public List&lt;User&gt; findByOrder(int topSize) &#123; return this.currentSession().createQuery("from User order by id").setMaxResults(topSize).list(); &#125; 投影查询(只获取单个)123456789101112131415161718192021public List findByProjection() &#123; return this.currentSession().createQuery("select name from User").list(); &#125; ---service public List&lt;Object&gt; findAllbyCondinitions5() &#123; Transaction tx = null; List&lt;Object&gt; list = null; try &#123; UserDao userDao = new UserDao(); tx = userDao.currentSession().beginTransaction(); list = userDao.findByProjection(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if (tx != null) &#123; tx.rollback(); &#125; &#125; return list; &#125; 投影查询(多个字段)123456789101112public List&lt;Object[]&gt; findByProjection2() &#123; return this.currentSession().createQuery("select name,telephone from User").list(); &#125; ---test public void findPro2() &#123; List&lt;Object[]&gt; list = new UserBiz().findAllbyCondinitions6(); for (Object[] object : list) &#123; System.out.println(object[0] + "\t" + object[1]); &#125; &#125; 将查询结果通过构造函数封装为对象12345678910public List&lt;User&gt; findByProjection3() &#123; return this.currentSession().createQuery("select new User(name,telephone) from User").list(); &#125; --构造方法 public User(String name,String telephone)&#123; this.name=name; this.telephone=telephone; &#125;]]></content>
      <categories>
        <category>SSH</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试26问]]></title>
    <url>%2F2018%2F11%2F08%2F%E9%9D%A2%E8%AF%9526%E9%97%AE%2F</url>
    <content type="text"><![CDATA[请你自我介绍一下自己好吗一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以和学习无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”，企业喜欢有礼貌的求职者。 你觉得你个性上最大的优点是什么沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱。我在xxx经过一到两年的项目实战，加上实习工作，使我适合这份工作 说说你最大的缺点这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。绝对不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌岌可危了。企业喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分，企业喜欢聪明的求职者 你对薪资的要求如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣 回答样本一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。 回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。 你对加班的看法实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献 回答样本：如果工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时我也会提高工作效率，减少不必要的加班 如果通过这次面试我们录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办一段时间发现工作不适合我，有两种情况：①如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处 谈谈你对跳槽的看法①正常的“跳槽”能促进人才合理流动，应该支持。②频繁的跳槽对单位和个人双方都不利，应该反对 工作中难以和同事、上司相处，你该怎么办①我会服从领导的指挥，配合同事的工作。②我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，如果是这样的话我会努力改正。③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，有问题就及时改正。④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的 你对于我们公司了解多少在去公司面试前上网查一下该公司主营业务。如回答：贵公司有意改变策略，加强与国外大厂的OEM合作，自有品牌的部分则透过海外经销商 最能概括你自己的三个词是什么适应能力强，有责任心和做事有始终，结合具体例子向主考官解释 你的业余爱好是什么找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作 作为被面试者给我打一下分试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的） 你为什么要离开原来的公司①回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言，都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。②我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，已经达到顶峰，即没有升迁机会 你欣赏哪种性格的人诚实、不死板而且容易相处的人、有“实际行动”的人 你通常如何对待别人的批评①沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。②我会等大家冷静下来再讨论 怎样对待自己的失败我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误 你为什么愿意到我们公司来工作对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”、“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”、“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划 对这项工作，你有哪些可预见的困难①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。②可以尝试迂回战术，说出应聘者对困难所持有的态度——工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服 如果录用了你，你将怎样开展工作 ①如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法。②可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”。分析：这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性，而且重点想要知道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回避的话，此人绝对不会录用了 你希望与什么样的上级共事①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。②最好回避对上级具体的希望，多谈对自己的要求。③如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏 与上级意见不一时，你将怎么办①一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”②如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映 谈谈如何适应办公室工作的新环境①办公室里每个人有各自的岗位与职责，不得擅离岗位。②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。③多请示并及时汇报，遇到不明白的要虚心请教。④抓间隙时间，多学习，努力提高自己的政治素质和业务水平 除了本公司外，还应聘了哪些公司很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉 你还有什么问题要问吗企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心 如果你被录用，何时可以到职大多数企业会关心就职时间，最好是回答“如果被录用的话，到职日可按公司规定上班”，但如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的 为什么选择我们公司曾经在报章杂志看过关于贵公司的报道，与自己所追求的理念有志一同。而贵公司在业界的成绩也是有目共睹的，而且对员工的教育训练、升迁等也都很有制度]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate入门]]></title>
    <url>%2F2018%2F11%2F07%2FHibernate%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[hello，大家好，今天晚上来学习Hibernate 什么是Hibernate框架？Hibernate是一种ORM框架，全称为 Object_Relative DateBase-Mapping，在Java对象与关系数据库之间建立某种映射，以实现直接存取Java对象！比SSM的orm要强 Hibernate优缺点1.Hibernate优点： （1）对象/关系数据库映射(Basic O/R Mapping) 它使用时只需要操纵对象，使开发更对象化，抛弃了数据库中心的思想，完全的面向对象思想。 （2）透明持久化(Persistent) 带有持久化状态的、具有业务功能的单线程对象，此对象生存期很短。这些对象可能是普通的JavaBeans/POJO，这个对象没有实现第三方框架或者接口，唯一特殊的是他们正与（仅仅一个）Session相关联。一旦这个Session被关闭，这些对象就会脱离持久化状态，这样就可被应用程序的任何层自由使用。（例如，用作跟表示层打交道的数据传输对象。） （3）事务Transaction (org.Hibernate.Transaction) 应用程序用来指定原子操作单元范围的对象，它是单线程的，生命周期很短。它通过抽象将应用从底层具体的JDBC、JTA以及CORBA事务隔离开。某些情况下，一个Session之内可能包含多个Transaction对象。尽管是否使用该对象是可选的，但无论是使用底层的API还是使用Transaction对象，事务边界的开启与关闭是必不可少的。 （4）它没有侵入性，即所谓的轻量级框架。 （5）移植性会很好。 （6）缓存机制。提供一级缓存和二级缓存。 （7）简洁的HQL编程。 2.Hibernate缺点： （1）Hibernate在批量数据处理的时候是有弱势。 （2）针对某一对象(单个对象)简单的查\改\删\增，不是批量修改、删除，适合用Hibernate；而对于批量修改、删除，不适合用Hibernate，这也是OR框架的弱点;要使用数据库的特定优化机制的时候，不适合用Hibernate。 Hibernate环境搭建引入相关jar包antlr-2.7.6.jarcommons-collections-3.1.jardom4j-1.6.1.jarhibernate-jpa-2.0-api-1.0.1.Final.jarhibernate3.jarjavassist-3.12.0.GA.jarjta-1.1.jarlog4j-1.2.17.jarojdbc6.jarslf4j-api-1.6.1.jarslf4j-log4j12-1.6.1.jar 创建Hibernate核心配置文件（hibernate.cfg.xml）1234567891011121314151617181920212223242526272829&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt;&lt;session-factory&gt; &lt;!-- 数据库连接 --&gt; &lt;property name="connection.driver_class"&gt; oracle.jdbc.OracleDriver &lt;/property&gt; &lt;property name="connection.url"&gt; jdbc:oracle:thin:@localhost:1521:orcl &lt;/property&gt; &lt;property name="connection.username"&gt;martin&lt;/property&gt; &lt;property name="connection.password"&gt;mpwd&lt;/property&gt; &lt;!-- 辅助参数 --&gt; &lt;!-- &lt;property name="show_sql"&gt;true&lt;/property&gt; --&gt; &lt;property name="format_sql"&gt;true&lt;/property&gt; &lt;property name="dialect"&gt; org.hibernate.dialect.Oracle10gDialect &lt;/property&gt; &lt;property name="current_session_context_class"&gt;thread&lt;/property&gt; &lt;!-- 映射信息 --&gt; &lt;mapping resource="cn/house/pojo/Depts.hbm.xml" /&gt; &lt;mapping resource="cn/house/pojo/Emps.hbm.xml" /&gt; &lt;mapping resource="cn/house/pojo/Employee.hbm.xml" /&gt; &lt;mapping resource="cn/house/pojo/Project.hbm.xml" /&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 创建持久化类和映射文件持久化类需要implement Serializable接口必须就有一个无参数的构造方法 映射文件（为持久化类名+hbm.xml）123456789101112131415&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="cn.hibernatedemo.entity.Emp" table="`EMP`"&gt; &lt;id name="empNo" column="`EMPNO`" type="java.lang.Integer"&gt; &lt;generator class="increment"/&gt; &lt;/id&gt; &lt;property name="empName" type="java.lang.String" column="`ENAME`"/&gt; &lt;property name="job" type="java.lang.String" column="`JOB`"/&gt; &lt;property name="salary" type="java.lang.Double" column="`SAL`"/&gt; &lt;property name="hireDate" type="java.util.Date"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; property属性中可以设置length 以及 not-null 进行持久化操作12345678910111213141516171819202122232425262728293031323334353637383940public void firstShow() &#123; Configuration conf = null; // 加载hibernate配置文件 SessionFactory sf = null; // 创建session 会话接口 Session session = null; //session实施持久化操作关键api Transaction tx = null; //事务控制 try &#123; conf = new Configuration().configure(); sf = conf.buildSessionFactory(); session = sf.getCurrentSession(); //推荐使用 /*session = sf.openSession(); *///比较垃圾 tx = session.beginTransaction(); //开启事务 User user=new User(); user.setId((byte)2); user.setIsadmin("yes"); user.setName("樊可"); user.setPassword("123456"); user.setTelephone("15035042771"); user.setUsername("悲伤的橙子子树"); /*Dept dept=new Dept(); dept.setDeptName("狙击部"); dept.setDeptNo((byte)50); dept.setLocation("永济市");*/ session.save(user); tx.commit(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); if(tx!=null)&#123; tx.rollback(); &#125; &#125;/*finally &#123; session.close(); &#125;*/ &#125; 注意 ：不管是查询还是更新都要开启事务，session会自动关闭 简化一下util创建HibernateUtil.java文件1234567891011121314151617181920212223242526272829package cn;import org.hibernate.HibernateException;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtil &#123; private static Configuration conf; private final static SessionFactory sf; static &#123; try &#123; conf = new Configuration().configure(); sf = conf.buildSessionFactory(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); throw new ExceptionInInitializerError(e); &#125; &#125; private HibernateUtil()&#123;&#125; public static Session currentSession()&#123; return sf.getCurrentSession(); &#125;&#125; dao层创建BaseDao.java123456789package cn.dao;import org.hibernate.Session;import cn.HibernateUtil;public class BaseDao &#123; public Session currentSession()&#123; return HibernateUtil.currentSession(); &#125;&#125; 用的时候直接继承BaseDao既可 按主键查询GET方法123public User getUser(Serializable id)&#123; return (User)currentSession().get(User.class, id);&#125; LOAD方法(需要在会话关闭之前测试查询)123public User loadUser(Serializable id)&#123; return (User)currentSession().load(User.class, id);&#125; 增加操作1234public void save(User user)&#123; currentSession().save(user);&#125;--还有个save-update(他会找主键，如果主键存在，那就修改，如果不存在，就添加) 修改操作1234public void update(User user)&#123; currentSession().update(user);&#125;--还有个save-update(他会找主键，如果主键存在，那就修改，如果不存在，就添加) 删除操作123public void delete(User user)&#123; currentSession().delete(user);&#125; .hbm.xml文件（ dynamic-update=”true”）表示动态更新，只更新变化的字段]]></content>
      <categories>
        <category>SSH</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PL/SQL编程]]></title>
    <url>%2F2018%2F11%2F07%2FPL-SQL%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是PL/SQL呢？ PL/SQL是 Procedure Language &amp; Structured Query Language 的缩写。ORACLE的SQL是支持ANSI(American national Standards Institute)和ISO92 (International Standards Organization)标准的产品。PL/SQL是对SQL语言存储过程语言的扩展。从ORACLE6以后，ORACLE的RDBMS附带了PL/SQL。它现在已经成为一种过程处理语言，简称PL/SQL。目前的PL/SQL包括两部分，一部分是数据库引擎部分；另一部分是可嵌入到许多产品（如C语言，JAVA语言等）工具中的独立引擎。可以将这两部分称为：数据库PL/SQL和工具PL/SQL。两者的编程非常相似。都具有编程结构、语法和逻辑机制。工具PL/SQL另外还增加了用于支持工具（如ORACLE Forms）的句法，如：在窗体上设置按钮等 PL/SQL的优点有利于客户/服务器环境应用的运行对于客户/服务器环境来说，真正的瓶颈是网络上。无论网络多快，只要客户端与服务器进行大量的数据交换。应用运行的效率自然就回受到影响。如果使用PL/SQL进行编程，将这种具有大量数据处理的应用放在服务器端来执行。自然就省去了数据在网上的传输时间。 适合于客户环境PL/SQL由于分为数据库PL/SQL部分和工具PL/SQL。对于客户端来说，PL/SQL可以嵌套到相应的工具中，客户端程序可以执行本地包含PL/SQL部分，也可以向服务发SQL命令或激活服务器端的PL/SQL程序运行。 过程化PL/SQL是Oracle在标准SQL上的过程性扩展，不仅允许在PL/SQL程序内嵌入SQL语句，而且允许使用各种类型的条件分支语句和循环语句，可以多个应用程序之间共享其解决方案。 模块化PL/SQL程序结构是一种描述性很强、界限分明的块结构、嵌套块结构，被分成单独的过程、函数、触发器，且可以把它们组合为程序包，提高程序的模块化能力。 运行错误的可处理性使用PL/SQL提供的异常处理（EXCEPTION），开发人员可集中处理各种ORACLE错误和PL/SQL错误，或处理系统错误与自定义错误，以增强应用程序的健壮性。 提供大量内置程序包ORACLE提供了大量的内置程序包。通过这些程序包能够实现DBS的一些低层操作、高级功能，不论对DBA还是应用开发人员都具有重要作用。 当然还有其它的一些优点如：更好的性能、可移植性和兼容性、可维护性、易用性与快速性等。 PL/SQL可用的SQL语句PL/SQL是ORACLE系统的核心语言，现在ORACLE的许多部件都是由PL/SQL写成。在PL/SQL中可以使用的SQL语句有： INSERT，UPDATE，DELETE，SELECT INTO，COMMIT，ROLLBACK，SAVEPOINT。 提示：在 PL/SQL中只能用 SQL语句中的 DML 部分，不能用 DDL 部分，如果要在PL/SQL中使用DDL(如CREATE table 等)的话，只能以动态的方式来使用。 一个PL/SQL块的组成（由三部分）1234567DECLARE --声明部分: 在此声明PL/SQL用到的变量,类型及游标，以及局部的存储过程和函数 BEGIN -- 执行部分: 过程及SQL 语句 , 即程序的主要部分 EXCEPTION -- 执行异常部分: 错误处理 END; 常量和变量的声明ename varchar2【(20)】 【:=’EricHu’】;· ename表示变量名称· varchar2变量类型以及大小· :=’EricHu’为初始化变量值 PL/SQL程序设计中的标识符定义与SQL 的标识符定义的要求相同。要求和限制有：1.标识符名不能超过30字符； 2.第一个字符必须为字母； 3.不分大小写； 4.不能用’-‘(减号); 5.不能是SQL保留字。 提示: 一般不要把变量名声明与表中字段名完全一样,如果这样可能得到不正确的结果. 变量与常量的赋值1）variable := expression ; variable 是一个PL/SQL变量, expression 是一个PL/SQL 表达式，也可以直接赋一个值2） 字符及数字运算特点空值加数字仍是空值：NULL + &lt; 数字&gt; = NULL空值加（连接）字符，结果为字符：NULL || &lt;字符串&gt; = &lt; 字符串&gt;3）数据库赋值12345678910/*数据库赋值是通过 SELECT语句来完成的，每次执行 SELECT语句就赋值一次，一般要求被赋值的变量与SELECT中的列名要一一对应*/DECLARE emp_id emp.empno%TYPE :=7788; emp_name emp.ename%TYPE; wages emp.sal%TYPE; BEGIN SELECT ename, NVL(sal,0) + NVL(comm,0) INTO emp_name, wages FROM emp WHERE empno = emp_id; DBMS_OUTPUT.PUT_LINE(emp_name||'----'||to_char(wages)); END; 注释12345678910111213141516171819在PL/SQL里，可以使用两种符号来写注释，即：使用双 ‘-‘ ( 减号) 加注释 PL/SQL允许用 – 来写注释，它的作用范围是只能在一行有效。如： V_Sal NUMBER(12,2); -- 人员的工资变量。 使用 /* */ 来加一行或多行注释，如：/***********************************************//* 文件名： department_salary.sql *//* 作 者： 樊可 *//* 时 间： 2018-11-7 *//***********************************************/ PL/SQL数据类型标量数据类型小声bb （其实就是普通数据类型） LOB数据类型存储大数据类型，详情请看Oracle数据库基础 属性类型1）%TYPE定义一个变量，其数据类型与已经定义的某个数据变量(尤其是表的某一列)的数据类型相一致，这时可以使用%TYPE。 使用%TYPE特性的优点在于： 1.所引用的数据库列的数据类型可以不必知道； 2.所引用的数据库列的数据类型可以实时改变，容易保持一致，也不用修改PL/SQL程序。12345678910111213DECLARE -- 用%TYPE 类型定义与表相配的字段 TYPE T_Record IS RECORD( T_no emp.empno%TYPE, T_name emp.ename%TYPE, T_sal emp.sal%TYPE ); -- 声明接收数据的变量 v_emp T_Record; BEGIN SELECT empno, ename, sal INTO v_emp FROM emp WHERE empno=7788; DBMS_OUTPUT.PUT_LINE (TO_CHAR(v_emp.t_no)||' '||v_emp.t_name||' ' || TO_CHAR(v_emp.t_sal)); END; 2）%ROWTYPEPL/SQL 提供%ROWTYPE操作符, 返回一个记录类型, 其数据类型和数据库表的数据结构相一致。 使用%ROWTYPE特性的优点在于： l 所引用的数据库中列的个数和数据类型可以不必知道； l 所引用的数据库中列的个数和数据类型可以实时改变，容易保持一致，也不用修改PL/SQL程序。1234567DECLARE v_empno emp.empno%TYPE :=&amp;no; rec emp%ROWTYPE; BEGIN SELECT * INTO rec FROM emp WHERE empno=v_empno; DBMS_OUTPUT.PUT_LINE('姓名:'||rec.ename||'工资:'||rec.sal||'工作时间:'||rec.hiredate); END; PL/SQL控制语句条件控制IF语句）12345678DECLAREv_countResult NUMBER ;BEGINSELECT COUNT(empno) INTO v_countResult FROM emp ;IF v_countResult &gt; 10 THENDBMS_OUTPUT.put_line('EMP表的记录大于10条。') ;END IF ;END ; IF…ELSE语句）12345678910DECLAREv_countResult NUMBER ;BEGINSELECT COUNT(deptno) INTO v_countResult FROM dept ;IF v_countResult &gt; 10 THENDBMS_OUTPUT.put_line('DEPT表的记录大于10条。') ;ELSEDBMS_OUTPUT.put_line('DEPT表的记录小于10条。') ;END IF ;END ; IF…ELSIF…ELSE语句）123456789101112DECLAREv_countResult NUMBER ;BEGINSELECT COUNT(empno) INTO v_countResult FROM emp ;IF v_countResult &gt; 10 THENDBMS_OUTPUT.put_line('EMP表的记录大于10条。') ;ELSIF v_countResult &lt; 10 THENDBMS_OUTPUT.put_line('EMP表的记录小于10条。') ;ELSEDBMS_OUTPUT.put_line('EMP表的记录等于10条。') ;END IF ;END ; CASE语句）1234567CASE 条件表达式 WHEN 条件表达式结果1 THEN 语句段1 WHEN 条件表达式结果2 THEN 语句段2 [ELSE]END CASE 循环控制用于重复执行的系列语句。包括LOOP和EXIT语句，使用EXIT语句可以立即退出循环; 使用EXIT WHEN 语句可以根据条件结束循环。有3种类型循环，包括LOOP循环、WHILE循环、FOR循环。 LOOP）1234LOOP要执行的语句;EXIT WHEN &lt;条件语句&gt; --条件满足，退出循环语句END LOOP; WHILE）123WHILE &lt;布尔表达式&gt; LOOP要执行的语句;END LOOP; FOR）123FOR 循环计数器 IN [REVERSE] 下限 .... 上限 LOOP要执行的语句;END LOOP; 异常处理PL/SQL预定义异常1234567891011121314151617181920212223242526272829303132333435363738ACCESS_INTO_NULL在未初始化对象时出现CASE_NOT_FOUNDCASE语句中的选项与用户输入的数据不匹配时出现COLLECTION_IS_NULL给尚未初始化的表或数组赋值时出现CORSOR_ALREADY_OPEN在用户试图重新打开已经打开的游标时出现。在重新打开游标前必须先将其关闭DUP_VAL_ON_INDEX在用户试图将重复的值存储在使用唯一索引的数据库列中时出现INVALID_CURSOR在执行非法游标运算（如打开一个尚未打开的游标）时出现INVALID_NUMBER在将字符串转换为数字时出现LOGIN_DENIED在输入的用户名或密码无效时出现NO_DATA_FOUND在表中不存在请求的行时出现。此外，当程序引用已经删除的元素时，也会引发NO_DATA_FOUND异常STORAGE_ERROR在内存损环或PL/SQL耗尽内存时出现TOO_MANY_ROWS在执行SELECT INTO语句后返回多行时出现VALUE_ERROR产生大小限制错误时出现。例如，变量中的列值超出变量的大小ZERO_DIVIDE以零作为除数时出现 异常处理语法1234567891011BEGINsequence_of_statements;EXCEPTIONWHEN &lt;exception_name1&gt; THENsequence_of_statements;WHEN &lt;exception_name2&gt; THENsequence_of_statements;WHEN OTHERS THEN --这里的OTHERS处理程序除之前异常类型外的所有异常。PL/SQL块只能有一个OTHERSsequence_of_statements;END;--可以使用函数SQLCODE和SQLERRM来返回错误代码和错误文本信息。 处理用户自定义异常（1）在PL/SQL块的定义部分定义异常情况： &lt;异常情况&gt; EXCEPTION; （2）抛出异常情况： RAISE &lt;异常情况&gt;; （3）在PL/SQL块的异常情况处理部分对异常情况做出相应的处理。123456789101112131415161718例，查询编号为7788的雇员的福利补助comm列。DECLAREv_comm employee.comm%TYPE;e_comm_is_null EXCEPTION; --定义异常类型变量BEGINSELECT comm INTO v_comm FROM employee WHERE empno=7788;IF v_comm IS NULL THENRAISE e_comm_is_null;END IF;EXCEPTIONWHEN NO_DATA_FOUND THENDBMS_OUTPUT.PUT_LINE(‘雇员不存在！错误为：’||SQLCODE||SQLERRM);WHEN E_COM_IS_NULL THENDBMS_OUTPUT.PUT_LINE(‘该雇员无补助！’);WHEN OTHERS THENDBMS_OUTPUT.PUT_LINE(‘出现其他异常’);END; RAISE_APPLICATION_ERRORRAISE_APPLICATION_ERROR存储过程可以重新定义异常错误消息，为应用程序提供一种与Oracle交互的方法。12345678DECLARE......BEGIN......IF v_com IS NULL THENRAISE_APPLICATION_ERROR(-20001,’该雇员无补助’);END IF;END; 游标显示游标显式游标的使用步聚： 1）声明游标 CURSOR cursor_name [(parameter [,paramter]….)] [RETURN return_type] IS select_statements; –cursor_name指游标的名称。 –parameter用于为游标指定输入参数。在指定数据类型时，不能使用长度约束。 –return_type用于定义游标提取的行的类型。 –select_statement 指游标定义的查询语句。 2）打开游标 OPEN cursor_name[ (parameters) ]; 3）提取游标 FETCH cursor_name INTO variables; –variables是变量名 4）关闭游标 CLOSE cursor_name; 例子 1234567891011121314DECLAREname employee.ename%TYPE;sal employee.sal%TYPE; --定义两个变量来存放ename和sal的内容CURSOR emp_cursor --声明游标IS SELECT ename,sal FROM employee;BEGINOPEN emp_cursor;LOOPFETCH emp_cursor INTO name, sal;EXIT WHEN emp_cursor%NOTFOUND;DBMS_OUTPUT.PUT_LINE(‘第’||emp_cursor%ROWCOUNT||’个雇员：’||name||sal);END LOOP;CLOSE emp_cursor;END; 显式游标属性1）%FOUND：只有在DML语句影响一行或多行时，%FOUND属性才返回TRUE; 2）%NOTFOUND：%NOTFOUND属性与%FOUND属性的作用正好相反。如果DML语句没有影响任何行，则%NOTFOUND属性返回TRUE; 3）%ROWCOUNT：%ROWCOUNT属性返回DML语句影响的行数。如果DML语句没有影响任何行，则%ROWCOUNT属性将返回0; 4）%ISOPEN：%ISOPEN属性返回游标是否已打开。 使用显式游标删除或更新使用游标时，如果处理过程中需要删除或更新行，在定义游标时必须使用SELECT….FOR UPDATE语句; 而在执行DELETE和UPDATE时使用WHERE CURRENT OF子句指定游标的当前行。123456789声明更新游标语法：CURSOR cursor_name IS select_statement FOR UPDATE [OF culumns];--SELECT... FOR UPDATE[OF columns]为更新查询，锁定选择的行。[OF columns]可以不是SELECT后的列--（1）当选择单表更新查询时，可以受省略OF子句;--（2）当选择多个表更新查询时，被锁定的行来源于OF 子句后声明的列所在的表中的行。就是你选哪个表的属性就更新哪个表 例子123456DECLARECURSOR emp_cursor IS SELECT ename, sal FROM employee e INNER JOIN dept d ON e.deptno= d.deptnoFOR UPDATE OF SAL;....UPDATE employee SET sal=sal+100 WHERE CURRENT OF emp_cursor; 使用循环游标简化游标的读取1234FOR record_index IN cursor_nameLOOPexecutable_statementsEND LOOP; –record_index是PL/SQL声明的记录变量。此变量的属性声明为%ROWTYPE类型作用域在循环之内。 循环游标的特性：1）在游标中提取了所有记录之后自动终止。2）提取和处理游标中的每一条记录。3）如果在提取记录之后%NOTFOUND属性返回TRUE，则终止循环。4）如果未返回行，则不进入循环。12345678910DECLARECURSOR emp_cursor IS SELECT ename, sal FROM employee;BEGINFOR emp_record IN emp_cursor LOOPDBMS_OUTPUT.PUT_LINE(‘第’||emp_cursor%ROWCOUNT||’个雇员：’||emp_record.ename||emp_record.sal);END LOOP;END; 存储过程子程序子程序是已命名的PL/SQL块，它们存储在数据库中，包括存储过程和函数。使用存储过程执行操作，使用函数执行操作并返回值1.声明部分，包括类型、游标、常量、异常和嵌套子程序的使用。退出子程序后雩不复存在。 2.可执行部分，包括赋值、控制执行过程以及操纵Oracle数据的语句。 3.异常处理部分，包括异常处理程序，负责处理执行存储过程中出现的异常。 子程序的优点： 1）模块化：通过子种序，可以将程序分解为可管理的、明确的逻辑模块。 2）可重用性：子程序在创建并执行后，就可以在任意数目的应用程序中使用。 3）可维护性：子程序可以简化维护操作，因为如果一个子程序受到影响，则只需要修改该子程序的定义。 4）安全性：用户可以设置权限，使得访问数据的唯一方式就是用户提供的存储过程。这样也可以保证正确性。 创建存储过程123456789CREATE [OR REPLACE] PROCEDURE procedure_name[(parameter_list)][IS|AS][local_declarations]BEGINexecetable_statements[EXCEPTION][exception_handlers]END [procedure_name]; –procedure_name：存储过程的名称。 –parameter_list：参数列表，可选。 –local_declarations：局部声明，可选。 –executable_statements：可执行语句。 –excetption_handlers：异常处理程序，可选。 –OR REPLACE：可选。如果包含OR REPLACE语句，当系统中有这个存储过程时，将覆盖。如果不包含，当系统中有这个存储过程时，将报异常。 –声明时，数据类型不能带大小。如NUMBER(4)，只能写成NUMBER。 –声明时可以给定默认值，如：job VARCHAR2 DEFAULT ‘CLEAK’ 如果调用时不揭定该参数，自动默认值。 调用存储过程（需要通过授权才能使用）用命令调用EXEC[UTE] procedure_name (parameter_list);–EXECUTE：执行命令，可以缩写为EXEC 参数的传递方式：按位置传递，例：EXEC add_employee(1111,’MARY’,2000,’MANAGER’,10); 按名称传递，即在调用时按名称对应。名称的对应关系是最重要的，次序不重要。 例：EXEC add_employee(dno=&gt;10,name=&gt;’MARY’,salary=&gt;2000,job=&gt;’MANAGER’); 还有个混合方法传递，如果有一个是按名称传递的，那后面的参数都是按位置传 PL/SQL块中使用123BEGIN add_employee(2111,’MARY’,2000,’MANAGER’,10);END; 参数模式在存储过程中参数传递的模式有3种：IN、OUT、IN OUT，即输入 、输出、输入/输出参数。 IN模式只能将实参传递给形参，进入函数内部，函数返回时，实参值不变。结论参数传递 模式。 OUT模式会忽略调用时的实参值，在函数内部可写，函数返回时实参的值改变。 IN OUT模式具有前再种模式的特性。即调用时，实参的值总是传递给形参;结束时，形参的值传递给实参 可以在参数列表中为IN参数赋默认值。但是OUT和INT OUT参数不可以赋默认值。 12345678CREATE OR REPLACE PROCEDURE QueryEmp(v_empno IN employee.empno%TYPE DEFAULT 1000, --默认编号为1000v_ename OUT employee.ename%TYPE,v_sal IN OUT employee.sal%TYPE)AS...... 存储过程的访问权限–授权GRANT EXECUTE ON add_employee TO A_oe; –撤销REVOKE EXECUTE ON add_employee FROM A_oe; –删除存储过程DROP PROCEDURE procedure_name; 啊！！ 拜拜]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[人间失格]]></title>
    <url>%2F2018%2F11%2F07%2F%E4%BA%BA%E9%97%B4%E5%A4%B1%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[日日重复同样的事，遵循着昨日相同的惯例，若能避开猛烈的狂喜，自然也不会有悲痛的来袭 日日重复同样的事，遵循着与昨日相同的惯例，若能避开猛烈的狂喜 ，自然也不会有悲痛的来袭。相互欺骗，却又令人惊奇地不受到任何伤害，甚至于就好像没有察觉到彼此在欺骗似的，这种不加掩饰从而显得清冽、豁达的互不信任的例子，在人类生活中比比皆是。倒是那些彼此欺骗，却清冽而开朗地生存着，抑或是有信心清冽而开朗地生活下去的人，才是令人费解的。 世间。我开始隐隐约约明白了世间的真相，它就是个人与个人之间的争斗，而且是即时即地的斗争。人需要在那种争斗中当场取胜。人是绝不可能服从他人的。即使是当奴隶，也会以奴隶的方式进行卑屈的反击。]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整合]]></title>
    <url>%2F2018%2F11%2F06%2F%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[配置文件整合（CTRL C CTRL V）根据项目实际情况而定WEB.XML12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;CG14&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContextl.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.util.Log4jConfigListener &lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; applicationContextl.XML1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd"&gt; &lt;context:component-scan base-package="cn.appsys.service"&gt;&lt;/context:component-scan&gt; &lt;context:component-scan base-package="cn.appsys.controller"&gt;&lt;/context:component-scan&gt; &lt;!-- 读取数据库配置文件 --&gt; &lt;context:property-placeholder location="classpath:database.properties"/&gt; &lt;!-- JNDI获取数据源(使用dbcp连接池) --&gt; &lt;bean class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" scope="singleton" id="dataSource"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;user&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"/&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"/&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"/&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"/&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"/&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;"/&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;"/&gt; &lt;!-- sql 心跳 --&gt; &lt;property name= "testWhileIdle" value="true"/&gt; &lt;property name= "testOnBorrow" value="false"/&gt; &lt;property name= "testOnReturn" value="false"/&gt; &lt;property name= "validationQuery" value="select 1"/&gt; &lt;property name= "timeBetweenEvictionRunsMillis" value="60000"/&gt; &lt;property name= "numTestsPerEvictionRun" value="$&#123;maxActive&#125;"/&gt; &lt;/bean&gt; &lt;!-- 数据源在配置文件中 --&gt; &lt;!-- &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- 使用jndi数据源 在tomcat content.xml配置 --&gt; &lt;!-- &lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt; &lt;property name="jndiName"&gt; &lt;value&gt;java:comp/env/jndi/smbms&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- 配置SqlSessionFactoryBean --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;property name="configLocation" value="classpath:mybatis-configl.xml"&gt;&lt;/property&gt; &lt;property name="mapperLocations"&gt; &lt;list&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Dao --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.appsys.dao.*"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务增强 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置切面 --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression="execution(* cn.appsys.service..*.*(..))" id="myPoint" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="myPoint" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; database.properties(mysql)1234567891011driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/appinfodb?useUnicode=true&amp;characterEncoding=utf-8user=rootpassword=rootminIdle=45maxIdle=50initialSize=5maxActive=100maxWait=100removeAbandonedTimeout=180removeAbandoned=true log4j.properties123456789101112131415161718192021222324252627282930313233343536log4j.rootLogger=DEBUG,CONSOLE,file#log4j.rootLogger=ERROR,ROLLING_FILElog4j.logger.cn.smbms.dao=debuglog4j.logger.com.ibatis=debug log4j.logger.com.ibatis.common.jdbc.SimpleDataSource=debug log4j.logger.com.ibatis.common.jdbc.ScriptRunner=debug log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=debug log4j.logger.java.sql.Connection=debug log4j.logger.java.sql.Statement=debug log4j.logger.java.sql.PreparedStatement=debug log4j.logger.java.sql.ResultSet=debug log4j.logger.org.tuckey.web.filters.urlrewrite.UrlRewriteFilter=debug####################################################################################### Console Appender \u65e5\u5fd7\u5728\u63a7\u5236\u8f93\u51fa\u914d\u7f6e######################################################################################log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.Threshold=errorlog4j.appender.CONSOLE.Target=System.outlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern= [%p] %d %c - %m%n####################################################################################### DailyRolling File \u6bcf\u5929\u4ea7\u751f\u4e00\u4e2a\u65e5\u5fd7\u6587\u4ef6\uff0c\u6587\u4ef6\u540d\u683c\u5f0f:log2009-09-11######################################################################################log4j.appender.file=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.file.DatePattern=yyyy-MM-ddlog4j.appender.file.File=log.loglog4j.appender.file.Append=truelog4j.appender.file.Threshold=errorlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-M-d HH:mm:ss&#125;%x[%5p](%F:%L) %m%nlog4j.logger.com.opensymphony.xwork2=error mybatis-configl.XML123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 引入database.properties文件 --&gt; &lt;!-- 配置mybatis的log实现为LOG4J --&gt; &lt;settings&gt; &lt;!-- &lt;setting name="logImpl" value="LOG4J" /&gt; --&gt; &lt;setting name="lazyLoadingEnabled" value="false"/&gt; &lt;setting name="autoMappingBehavior" value="FULL"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name="cn.appsys.pojo"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; springmvc-servlet.XML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 配置处理器映射 HandlerMapping --&gt; &lt;!-- &lt;bean name="/index.html" class="cn.smbms.controller.IndexController" /&gt; --&gt; &lt;!-- &lt;bean name="/welcome" class="cn.smbms.controller.IndexController" /&gt; --&gt; &lt;!-- &lt;bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;/bean&gt; --&gt; &lt;context:component-scan base-package="cn.appsys.controller"/&gt; &lt;!-- 自定义转换器 --&gt; &lt;!-- &lt;bean id="myConversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;bean class="cn.smbms.tools.StringToDateConverter"&gt; &lt;constructor-arg type="java.lang.String" value="yyyy-MM-dd" /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- 拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/sys/**"/&gt; &lt;bean class="cn.appsys.interceptor.SysInterceptor"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;mvc:annotation-driven&gt; &lt;!-- 消息转换器 --&gt; &lt;mvc:message-converters&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean class="com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="features"&gt; &lt;list&gt; &lt;value&gt;WriteDateUseDateFormat&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 完成视图的对应 --&gt; &lt;!-- 对转向页面的路径解析。prefix：前缀， suffix：后缀 --&gt; &lt;!-- &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; --&gt; &lt;!-- 配置多视图解析器 ：允许统一的内容数据呈现在不同的view中 --&gt; &lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt; &lt;!-- 支持参数匹配 --&gt; &lt;property name="favorParameter" value="true"/&gt; &lt;property name="mediaTypes"&gt; &lt;map&gt; &lt;entry key="html" value="text/html;charset=UTF-8"&gt;&lt;/entry&gt; &lt;entry key="json" value="application/json;charset=UTF-8"&gt;&lt;/entry&gt; &lt;entry key="xml" value="application/xml;charset=UTF-8"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 网页视图解析器 --&gt; &lt;property name="viewResolvers"&gt; &lt;list&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;mvc:resources location="/statics/" mapping="/statics/**"&gt;&lt;/mvc:resources&gt; &lt;!-- 全局异常的配置 --&gt; &lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt; &lt;property name="exceptionMappings"&gt; &lt;props&gt; &lt;prop key="java.lang.RuntimeException"&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置MulitpartResolver，用于文件上传 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="5000000" /&gt; &lt;property name="defaultEncoding" value="utf-8" /&gt; &lt;/bean&gt;&lt;/beans&gt; Logger(AOP)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package cn.appsys.tools;import java.util.Arrays;import org.apache.log4j.Logger;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;/** * 注解定义切面 * @author F117 * */@Aspectpublic class UserServiceLogger &#123; private static final Logger LOGGER=Logger.getLogger(UserServiceLogger.class); @Pointcut("execution(* cn.service..*.*(..)) ") public void pointcut()&#123;&#125; /** * 前置增强 * @param jp */ @Before("pointcut()") public void before(JoinPoint jp) &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法入参：" + Arrays.toString(jp.getArgs())); &#125; /** * 后置增强 * @param jp * @param returnValue */ @AfterReturning(pointcut = "pointcut()", returning = "returnValue") public void afterReturning(JoinPoint jp, Object returnValue) &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法返回值：" + returnValue); &#125; /** * 最终增强 * @param jp */ @After("pointcut()") public void afterLogger(JoinPoint jp) &#123; LOGGER.info(jp.getSignature().getName() + " 方法结束执行。"); &#125; /** * 异常增强 * @param jp * @param e */ @AfterThrowing(value="pointcut()", throwing = "e") public void afterThrowing(JoinPoint jp, RuntimeException e) &#123; LOGGER.error(jp.getSignature().getName() + " 方法发生异常：" + e); &#125; /** * 环绕增强 * @param jp * @return * @throws Throwable */ @Around("pointcut()") public Object aroundLogger(ProceedingJoinPoint jp) throws Throwable &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法入参：" + Arrays.toString(jp.getArgs())); try &#123; Object result = jp.proceed(); LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法返回值：" + result); return result; &#125; catch (Throwable e) &#123; LOGGER.error(jp.getSignature().getName() + " 方法发生异常：" + e); throw e; &#125; finally &#123; LOGGER.info(jp.getSignature().getName() + " 方法结束执行。"); &#125; &#125; &#125; Controller增删改查123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728package cn.appsys.controller.developer;import java.io.File;import java.util.Date;import java.util.HashMap;import java.util.List;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import org.apache.commons.io.FilenameUtils;import org.apache.log4j.Logger;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;import com.alibaba.fastjson.JSONArray;import com.mysql.jdbc.StringUtils;import cn.appsys.pojo.AppCategory;import cn.appsys.pojo.AppInfo;import cn.appsys.pojo.AppVersion;import cn.appsys.pojo.DataDictionary;import cn.appsys.pojo.DevUser;import cn.appsys.service.developer.AppCategoryService;import cn.appsys.service.developer.AppInfoService;import cn.appsys.service.developer.AppVersionService;import cn.appsys.service.developer.DataDictionaryService;import cn.appsys.tools.Constants;import cn.appsys.tools.PageSupport;@Controller@RequestMapping(value="/dev/flatform/app")public class AppController &#123; private Logger logger = Logger.getLogger(AppController.class); @Resource private AppInfoService appInfoService; @Resource private DataDictionaryService dataDictionaryService; @Resource private AppCategoryService appCategoryService; @Resource private AppVersionService appVersionService; @RequestMapping(value="/list") public String getAppInfoList(Model model,HttpSession session, @RequestParam(value="querySoftwareName",required=false) String querySoftwareName, @RequestParam(value="queryStatus",required=false) String _queryStatus, @RequestParam(value="queryCategoryLevel1",required=false) String _queryCategoryLevel1, @RequestParam(value="queryCategoryLevel2",required=false) String _queryCategoryLevel2, @RequestParam(value="queryCategoryLevel3",required=false) String _queryCategoryLevel3, @RequestParam(value="queryFlatformId",required=false) String _queryFlatformId, @RequestParam(value="pageIndex",required=false) String pageIndex)&#123; logger.info("getAppInfoList -- &gt; querySoftwareName: " + querySoftwareName); logger.info("getAppInfoList -- &gt; queryStatus: " + _queryStatus); logger.info("getAppInfoList -- &gt; queryCategoryLevel1: " + _queryCategoryLevel1); logger.info("getAppInfoList -- &gt; queryCategoryLevel2: " + _queryCategoryLevel2); logger.info("getAppInfoList -- &gt; queryCategoryLevel3: " + _queryCategoryLevel3); logger.info("getAppInfoList -- &gt; queryFlatformId: " + _queryFlatformId); logger.info("getAppInfoList -- &gt; pageIndex: " + pageIndex); Integer devId = ((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId(); List&lt;AppInfo&gt; appInfoList = null; List&lt;DataDictionary&gt; statusList = null; List&lt;DataDictionary&gt; flatFormList = null; List&lt;AppCategory&gt; categoryLevel1List = null;//列出一级分类列表，注：二级和三级分类列表通过异步ajax获取 List&lt;AppCategory&gt; categoryLevel2List = null; List&lt;AppCategory&gt; categoryLevel3List = null; //页面容量 int pageSize = Constants.pageSize; //当前页码 Integer currentPageNo = 1; if(pageIndex != null)&#123; try&#123; currentPageNo = Integer.valueOf(pageIndex); &#125;catch (NumberFormatException e) &#123; // TODO: handle exception e.printStackTrace(); &#125; &#125; Integer queryStatus = null; if(_queryStatus != null &amp;&amp; !_queryStatus.equals(""))&#123; queryStatus = Integer.parseInt(_queryStatus); &#125; Integer queryCategoryLevel1 = null; if(_queryCategoryLevel1 != null &amp;&amp; !_queryCategoryLevel1.equals(""))&#123; queryCategoryLevel1 = Integer.parseInt(_queryCategoryLevel1); &#125; Integer queryCategoryLevel2 = null; if(_queryCategoryLevel2 != null &amp;&amp; !_queryCategoryLevel2.equals(""))&#123; queryCategoryLevel2 = Integer.parseInt(_queryCategoryLevel2); &#125; Integer queryCategoryLevel3 = null; if(_queryCategoryLevel3 != null &amp;&amp; !_queryCategoryLevel3.equals(""))&#123; queryCategoryLevel3 = Integer.parseInt(_queryCategoryLevel3); &#125; Integer queryFlatformId = null; if(_queryFlatformId != null &amp;&amp; !_queryFlatformId.equals(""))&#123; queryFlatformId = Integer.parseInt(_queryFlatformId); &#125; //总数量（表） int totalCount = 0; try &#123; totalCount = appInfoService.getAppInfoCount(querySoftwareName, queryStatus, queryCategoryLevel1, queryCategoryLevel2, queryCategoryLevel3, queryFlatformId, devId); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //总页数 PageSupport pages = new PageSupport(); pages.setCurrentPageNo(currentPageNo); pages.setPageSize(pageSize); pages.setTotalCount(totalCount); int totalPageCount = pages.getTotalPageCount(); //控制首页和尾页 if(currentPageNo &lt; 1)&#123; currentPageNo = 1; &#125;else if(currentPageNo &gt; totalPageCount)&#123; currentPageNo = totalPageCount; &#125; try &#123; appInfoList = appInfoService.getAppInfoList(querySoftwareName, queryStatus, queryCategoryLevel1, queryCategoryLevel2, queryCategoryLevel3, queryFlatformId, devId, currentPageNo, pageSize); statusList = this.getDataDictionaryList("APP_STATUS"); flatFormList = this.getDataDictionaryList("APP_FLATFORM"); categoryLevel1List = appCategoryService.getAppCategoryListByParentId(null); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; model.addAttribute("appInfoList", appInfoList); model.addAttribute("statusList", statusList); model.addAttribute("flatFormList", flatFormList); model.addAttribute("categoryLevel1List", categoryLevel1List); model.addAttribute("pages", pages); model.addAttribute("queryStatus", queryStatus); model.addAttribute("querySoftwareName", querySoftwareName); model.addAttribute("queryCategoryLevel1", queryCategoryLevel1); model.addAttribute("queryCategoryLevel2", queryCategoryLevel2); model.addAttribute("queryCategoryLevel3", queryCategoryLevel3); model.addAttribute("queryFlatformId", queryFlatformId); //二级分类列表和三级分类列表---回显 if(queryCategoryLevel2 != null &amp;&amp; !queryCategoryLevel2.equals(""))&#123; categoryLevel2List = getCategoryList(queryCategoryLevel1.toString()); model.addAttribute("categoryLevel2List", categoryLevel2List); &#125; if(queryCategoryLevel3 != null &amp;&amp; !queryCategoryLevel3.equals(""))&#123; categoryLevel3List = getCategoryList(queryCategoryLevel2.toString()); model.addAttribute("categoryLevel3List", categoryLevel3List); &#125; return "developer/appinfolist"; &#125; public List&lt;DataDictionary&gt; getDataDictionaryList(String typeCode)&#123; List&lt;DataDictionary&gt; dataDictionaryList = null; try &#123; dataDictionaryList = dataDictionaryService.getDataDictionaryList(typeCode); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return dataDictionaryList; &#125; /** * 根据typeCode查询出相应的数据字典列表 * @param pid * @return */ @RequestMapping(value="/datadictionarylist.json",method=RequestMethod.GET) @ResponseBody public List&lt;DataDictionary&gt; getDataDicList (@RequestParam String tcode)&#123; logger.debug("getDataDicList tcode ============ " + tcode); return this.getDataDictionaryList(tcode); &#125; /** * 根据parentId查询出相应的分类级别列表 * @param pid * @return */ @RequestMapping(value="/categorylevellist.json",method=RequestMethod.GET) @ResponseBody public List&lt;AppCategory&gt; getAppCategoryList (@RequestParam String pid)&#123; logger.debug("getAppCategoryList pid ============ " + pid); if(pid.equals("")) pid = null; return getCategoryList(pid); &#125; public List&lt;AppCategory&gt; getCategoryList (String pid)&#123; List&lt;AppCategory&gt; categoryLevelList = null; try &#123; categoryLevelList = appCategoryService.getAppCategoryListByParentId(pid==null?null:Integer.parseInt(pid)); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return categoryLevelList; &#125; //跳转到新增appinfo页面 @RequestMapping(value="/appinfoadd",method=RequestMethod.GET) public String add(@ModelAttribute("appInfo") AppInfo appInfo)&#123; return "developer/appinfoadd"; &#125; //保存appinfo数据 @RequestMapping(value="/appinfoaddsave",method=RequestMethod.POST) public String addSave(AppInfo appInfo,HttpSession session,HttpServletRequest request, @RequestParam(value="a_logoPicPath",required= false) MultipartFile attach)&#123; String logoPicPath = null; String logoLocPath = null; if(!attach.isEmpty())&#123; String path = request.getSession().getServletContext().getRealPath("statics"+java.io.File.separator+"uploadfiles"); logger.info("uploadFile path: " + path); String oldFileName = attach.getOriginalFilename();//原文件名 String prefix = FilenameUtils.getExtension(oldFileName);//原文件后缀 int filesize = 500000; if(attach.getSize() &gt; filesize)&#123;//上传大小不得超过 50k request.setAttribute("fileUploadError", Constants.FILEUPLOAD_ERROR_4); return "developer/appinfoadd"; &#125;else if(prefix.equalsIgnoreCase("jpg") || prefix.equalsIgnoreCase("png") ||prefix.equalsIgnoreCase("jepg") || prefix.equalsIgnoreCase("pneg"))&#123;//上传图片格式 String fileName = appInfo.getAPKName() + ".jpg";//上传LOGO图片命名:apk名称.apk File targetFile = new File(path,fileName); if(!targetFile.exists())&#123; targetFile.mkdirs(); &#125; try &#123; attach.transferTo(targetFile); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); request.setAttribute("fileUploadError", Constants.FILEUPLOAD_ERROR_2); return "developer/appinfoadd"; &#125; logoPicPath = request.getContextPath()+"/statics/uploadfiles/"+fileName; //绝对路径 logoLocPath = path+File.separator+fileName; //相对路径 &#125;else&#123; request.setAttribute("fileUploadError", Constants.FILEUPLOAD_ERROR_3); return "developer/appinfoadd"; &#125; &#125; appInfo.setCreatedBy(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appInfo.setCreationDate(new Date()); appInfo.setLogoPicPath(logoPicPath); appInfo.setLogoLocPath(logoLocPath); appInfo.setDevId(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appInfo.setStatus(1); try &#123; if(appInfoService.add(appInfo))&#123; return "redirect:/dev/flatform/app/list"; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return "developer/appinfoadd"; &#125; /** * 增加appversion信息（跳转到新增app版本页面） * @param appInfo * @return */ @RequestMapping(value="/appversionadd",method=RequestMethod.GET) public String addVersion(@RequestParam(value="id")String appId, @RequestParam(value="error",required= false)String fileUploadError, AppVersion appVersion,Model model)&#123; logger.debug("fileUploadError============&gt; " + fileUploadError); if(null != fileUploadError &amp;&amp; fileUploadError.equals("error1"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_1; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error2"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_2; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error3"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_3; &#125; appVersion.setAppId(Integer.parseInt(appId)); List&lt;AppVersion&gt; appVersionList = null; try &#123; appVersionList = appVersionService.getAppVersionList(Integer.parseInt(appId)); appVersion.setAppName((appInfoService.getAppInfo(Integer.parseInt(appId),null)).getSoftwareName()); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; model.addAttribute("appVersionList", appVersionList); model.addAttribute(appVersion); model.addAttribute("fileUploadError",fileUploadError); return "developer/appversionadd"; &#125; /** * 保存新增appversion数据（子表）-上传该版本的apk包 * @param appInfo * @param appVersion * @param session * @param request * @param attach * @return */ @RequestMapping(value="/addversionsave",method=RequestMethod.POST) public String addVersionSave(AppVersion appVersion,HttpSession session,HttpServletRequest request, @RequestParam(value="a_downloadLink",required= false) MultipartFile attach )&#123; String downloadLink = null; String apkLocPath = null; String apkFileName = null; if(!attach.isEmpty())&#123; String path = request.getSession().getServletContext().getRealPath("statics"+File.separator+"uploadfiles"); logger.info("uploadFile path: " + path); String oldFileName = attach.getOriginalFilename();//原文件名 String prefix = FilenameUtils.getExtension(oldFileName);//原文件后缀 if(prefix.equalsIgnoreCase("apk"))&#123;//apk文件命名：apk名称+版本号+.apk String apkName = null; try &#123; apkName = appInfoService.getAppInfo(appVersion.getAppId(),null).getAPKName(); &#125; catch (Exception e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; if(apkName == null || "".equals(apkName))&#123; return "redirect:/dev/flatform/app/appversionadd?id="+appVersion.getAppId() +"&amp;error=error1"; &#125; apkFileName = apkName + "-" +appVersion.getVersionNo() + ".apk"; File targetFile = new File(path,apkFileName); if(!targetFile.exists())&#123; targetFile.mkdirs(); &#125; try &#123; attach.transferTo(targetFile); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return "redirect:/dev/flatform/app/appversionadd?id="+appVersion.getAppId() +"&amp;error=error2"; &#125; downloadLink = request.getContextPath()+"/statics/uploadfiles/"+apkFileName; apkLocPath = path+File.separator+apkFileName; &#125;else&#123; return "redirect:/dev/flatform/app/appversionadd?id="+appVersion.getAppId() +"&amp;error=error3"; &#125; &#125; appVersion.setCreatedBy(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appVersion.setCreationDate(new Date()); appVersion.setDownloadLink(downloadLink); appVersion.setApkLocPath(apkLocPath); appVersion.setApkFileName(apkFileName); try &#123; if(appVersionService.appsysadd(appVersion))&#123; return "redirect:/dev/flatform/app/list"; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return "redirect:/dev/flatform/app/appversionadd?id="+appVersion.getAppId(); &#125; @RequestMapping(value="/&#123;appid&#125;/sale",method=RequestMethod.PUT) @ResponseBody public Object sale(@PathVariable String appid,HttpSession session)&#123; HashMap&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); Integer appIdInteger = 0; try&#123; appIdInteger = Integer.parseInt(appid); &#125;catch(Exception e)&#123; appIdInteger = 0; &#125; resultMap.put("errorCode", "0"); resultMap.put("appId", appid); if(appIdInteger&gt;0)&#123; try &#123; DevUser devUser = (DevUser)session.getAttribute(Constants.DEV_USER_SESSION); AppInfo appInfo = new AppInfo(); appInfo.setId(appIdInteger); appInfo.setModifyBy(devUser.getId()); if(appInfoService.appsysUpdateSaleStatusByAppId(appInfo))&#123; resultMap.put("resultMsg", "success"); &#125;else&#123; resultMap.put("resultMsg", "success"); &#125; &#125; catch (Exception e) &#123; resultMap.put("errorCode", "exception000001"); &#125; &#125;else&#123; //errorCode:0为正常 resultMap.put("errorCode", "param000001"); &#125; /* * resultMsg:success/failed * errorCode:exception000001 * appId:appId * errorCode:param000001 */ return resultMap; &#125; /** * 判断APKName是否唯一 * @param apkName * @return */ @RequestMapping(value="/apkexist.json",method=RequestMethod.GET) @ResponseBody public Object apkNameIsExit(@RequestParam String APKName)&#123; HashMap&lt;String, String&gt; resultMap = new HashMap&lt;String, String&gt;(); if(StringUtils.isNullOrEmpty(APKName))&#123; resultMap.put("APKName", "empty"); &#125;else&#123; AppInfo appInfo = null; try &#123; appInfo = appInfoService.getAppInfo(null, APKName); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if(null != appInfo) resultMap.put("APKName", "exist"); else resultMap.put("APKName", "noexist"); &#125; return JSONArray.toJSONString(resultMap); &#125; /** * 查看app信息，包括app基本信息和版本信息列表（跳转到查看页面） * @param appInfo * @return */ @RequestMapping(value="/appview/&#123;id&#125;",method=RequestMethod.GET) public String view(@PathVariable String id,Model model)&#123; AppInfo appInfo = null; List&lt;AppVersion&gt; appVersionList = null; try &#123; appInfo = appInfoService.getAppInfo(Integer.parseInt(id),null); appVersionList = appVersionService.getAppVersionList(Integer.parseInt(id)); &#125;catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; model.addAttribute("appVersionList", appVersionList); model.addAttribute(appInfo); return "developer/appinfoview"; &#125; /** * 修改app信息，包括：修改app基本信息（appInfo）和修改版本信息（appVersion） * 分为两步实现： * 1 修改app基本信息（appInfo） * 2 修改版本信息（appVersion） */ /** * 修改appInfo信息（跳转到修改appInfo页面） * @param id * @param model * @return */ @RequestMapping(value="/appinfomodify",method=RequestMethod.GET) public String modifyAppInfo(@RequestParam("id") String id, @RequestParam(value="error",required= false)String fileUploadError, Model model)&#123; AppInfo appInfo = null; logger.debug("modifyAppInfo --------- id: " + id); if(null != fileUploadError &amp;&amp; fileUploadError.equals("error1"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_1; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error2"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_2; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error3"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_3; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error4"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_4; &#125; try &#123; appInfo = appInfoService.getAppInfo(Integer.parseInt(id),null); &#125;catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; model.addAttribute(appInfo); model.addAttribute("fileUploadError",fileUploadError); return "developer/appinfomodify"; &#125; /** * 修改最新的appVersion信息（跳转到修改appVersion页面） * @param versionId * @param appId * @param model * @return */ @RequestMapping(value="/appversionmodify",method=RequestMethod.GET) public String modifyAppVersion(@RequestParam("vid") String versionId, @RequestParam("aid") String appId, @RequestParam(value="error",required= false)String fileUploadError, Model model)&#123; AppVersion appVersion = null; List&lt;AppVersion&gt; appVersionList = null; if(null != fileUploadError &amp;&amp; fileUploadError.equals("error1"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_1; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error2"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_2; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error3"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_3; &#125; try &#123; appVersion = appVersionService.getAppVersionById(Integer.parseInt(versionId)); appVersionList = appVersionService.getAppVersionList(Integer.parseInt(appId)); &#125;catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; model.addAttribute(appVersion); model.addAttribute("appVersionList",appVersionList); model.addAttribute("fileUploadError",fileUploadError); return "developer/appversionmodify"; &#125; /** * 保存修改后的appVersion * @param appVersion * @param session * @return */ @RequestMapping(value="/appversionmodifysave",method=RequestMethod.POST) public String modifyAppVersionSave(AppVersion appVersion,HttpSession session,HttpServletRequest request, @RequestParam(value="attach",required= false) MultipartFile attach)&#123; String downloadLink = null; String apkLocPath = null; String apkFileName = null; if(!attach.isEmpty())&#123; String path = request.getSession().getServletContext().getRealPath("statics"+File.separator+"uploadfiles"); logger.info("uploadFile path: " + path); String oldFileName = attach.getOriginalFilename();//原文件名 String prefix = FilenameUtils.getExtension(oldFileName);//原文件后缀 if(prefix.equalsIgnoreCase("apk"))&#123;//apk文件命名：apk名称+版本号+.apk String apkName = null; try &#123; apkName = appInfoService.getAppInfo(appVersion.getAppId(),null).getAPKName(); &#125; catch (Exception e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; if(apkName == null || "".equals(apkName))&#123; return "redirect:/dev/flatform/app/appversionmodify?vid="+appVersion.getId() +"&amp;aid="+appVersion.getAppId() +"&amp;error=error1"; &#125; apkFileName = apkName + "-" +appVersion.getVersionNo() + ".apk"; File targetFile = new File(path,apkFileName); if(!targetFile.exists())&#123; targetFile.mkdirs(); &#125; try &#123; attach.transferTo(targetFile); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return "redirect:/dev/flatform/app/appversionmodify?vid="+appVersion.getId() +"&amp;aid="+appVersion.getAppId() +"&amp;error=error2"; &#125; downloadLink = request.getContextPath()+"/statics/uploadfiles/"+apkFileName; apkLocPath = path+File.separator+apkFileName; &#125;else&#123; return "redirect:/dev/flatform/app/appversionmodify?vid="+appVersion.getId() +"&amp;aid="+appVersion.getAppId() +"&amp;error=error3"; &#125; &#125; appVersion.setModifyBy(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appVersion.setModifyDate(new Date()); appVersion.setDownloadLink(downloadLink); appVersion.setApkLocPath(apkLocPath); appVersion.setApkFileName(apkFileName); try &#123; if(appVersionService.modify(appVersion))&#123; return "redirect:/dev/flatform/app/list"; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return "developer/appversionmodify"; &#125; /** * 修改操作时，删除文件（logo图片/apk文件），并更新数据库（app_info/app_version） * @param fileUrlPath * @param fileLocPath * @param flag * @param id * @return */ @RequestMapping(value = "/delfile",method=RequestMethod.GET) @ResponseBody public Object delFile(@RequestParam(value="flag",required=false) String flag, @RequestParam(value="id",required=false) String id)&#123; HashMap&lt;String, String&gt; resultMap = new HashMap&lt;String, String&gt;(); String fileLocPath = null; if(flag == null || flag.equals("") || id == null || id.equals(""))&#123; resultMap.put("result", "failed"); &#125;else if(flag.equals("logo"))&#123;//删除logo图片（操作app_info） try &#123; fileLocPath = (appInfoService.getAppInfo(Integer.parseInt(id), null)).getLogoLocPath(); File file = new File(fileLocPath); if(file.exists()) if(file.delete())&#123;//删除服务器存储的物理文件 if(appInfoService.deleteAppLogo(Integer.parseInt(id)))&#123;//更新表 resultMap.put("result", "success"); &#125; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;else if(flag.equals("apk"))&#123;//删除apk文件（操作app_version） try &#123; fileLocPath = (appVersionService.getAppVersionById(Integer.parseInt(id))).getApkLocPath(); File file = new File(fileLocPath); if(file.exists()) if(file.delete())&#123;//删除服务器存储的物理文件 if(appVersionService.deleteApkFile(Integer.parseInt(id)))&#123;//更新表 resultMap.put("result", "success"); &#125; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return JSONArray.toJSONString(resultMap); &#125; /** * 保存修改后的appInfo * @param appInfo * @param session * @return */ @RequestMapping(value="/appinfomodifysave",method=RequestMethod.POST) public String modifySave(AppInfo appInfo,HttpSession session,HttpServletRequest request, @RequestParam(value="attach",required= false) MultipartFile attach)&#123; String logoPicPath = null; String logoLocPath = null; String APKName = appInfo.getAPKName(); if(!attach.isEmpty())&#123; String path = request.getSession().getServletContext().getRealPath("statics"+File.separator+"uploadfiles"); logger.info("uploadFile path: " + path); String oldFileName = attach.getOriginalFilename();//原文件名 String prefix = FilenameUtils.getExtension(oldFileName);//原文件后缀 int filesize = 500000; if(attach.getSize() &gt; filesize)&#123;//上传大小不得超过 50k return "redirect:/dev/flatform/app/appinfomodify?id="+appInfo.getId() +"&amp;error=error4"; &#125;else if(prefix.equalsIgnoreCase("jpg") || prefix.equalsIgnoreCase("png") ||prefix.equalsIgnoreCase("jepg") || prefix.equalsIgnoreCase("pneg"))&#123;//上传图片格式 String fileName = APKName + ".jpg";//上传LOGO图片命名:apk名称.apk File targetFile = new File(path,fileName); if(!targetFile.exists())&#123; targetFile.mkdirs(); &#125; try &#123; attach.transferTo(targetFile); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return "redirect:/dev/flatform/app/appinfomodify?id="+appInfo.getId() +"&amp;error=error2"; &#125; logoPicPath = request.getContextPath()+"/statics/uploadfiles/"+fileName; logoLocPath = path+File.separator+fileName; &#125;else&#123; return "redirect:/dev/flatform/app/appinfomodify?id="+appInfo.getId() +"&amp;error=error3"; &#125; &#125; appInfo.setModifyBy(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appInfo.setModifyDate(new Date()); appInfo.setLogoLocPath(logoLocPath); appInfo.setLogoPicPath(logoPicPath); try &#123; if(appInfoService.modify(appInfo))&#123; return "redirect:/dev/flatform/app/list"; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return "developer/appinfomodify"; &#125; @RequestMapping(value="/delapp.json") @ResponseBody public Object delApp(@RequestParam String id)&#123; logger.debug("delApp appId===================== "+id); HashMap&lt;String, String&gt; resultMap = new HashMap&lt;String, String&gt;(); if(StringUtils.isNullOrEmpty(id))&#123; resultMap.put("delResult", "notexist"); &#125;else&#123; try &#123; if(appInfoService.appsysdeleteAppById(Integer.parseInt(id))) resultMap.put("delResult", "true"); else resultMap.put("delResult", "false"); &#125; catch (NumberFormatException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return JSONArray.toJSONString(resultMap); &#125;&#125;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MVC体系结构和处理请求控制器]]></title>
    <url>%2F2018%2F11%2F06%2FMVC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%8E%A7%E5%88%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[环境搭建jar包123456789101112aopalliance-1.0.jaraspectjweaver-1.6.9.jarcommons-logging-1.1.1.jarlog4j-1.2.16.jarlog4j-1.2.17.jarspring-aop-3.2.13.RELEASE.jarspring-beans-3.2.13.RELEASE.jarspring-context-3.2.13.RELEASE.jarspring-core-3.2.13.RELEASE.jarspring-expression-3.2.13.RELEASE.jarspring-web-3.2.13.RELEASE.jarspring-webmvc-3.2.13.RELEASE.jar 在web.xml中配置servlet1234567891011121314151617&lt;!-- 核心控制器的配置 DispatchServlet --&gt;&lt;servlet&gt;&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!-- 初始化参数 --&gt;&lt;init-param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;&lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;&lt;/init-param&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 创建Spring MVC的配置文件springmvc-servlet.xml1234567891011121314151617181920212223&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context"xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;&lt;!-- 配置处理器映射 HandlerMapping --&gt;&lt;!-- &lt;bean name="/index.html" class="cn.smbms.controller.IndexController" /&gt; --&gt;&lt;!-- &lt;bean name="/welcome" class="cn.smbms.controller.IndexController" /&gt; --&gt;&lt;mvc:annotation-driven/&gt;&lt;context:component-scan base-package="cn.smbms.controller"/&gt;&lt;!-- 完成视图的对应 --&gt;&lt;!-- 对转向页面的路径解析。prefix：前缀， suffix：后缀 --&gt;&lt;beanclass="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;&lt;property name="prefix" value="/WEB-INF/jsp/" /&gt;&lt;property name="suffix" value=".jsp" /&gt;&lt;/bean&gt;&lt;/beans&gt; 创建Controller12345678910111213@Controllerpublic class IndexController（）&#123;@RequestMapping(&#123;"/index","/you"&#125;)public ModelAndView index()&#123;System.out.println("hello 宇智波鼬");return new ModelAndView("index");&#125;@RequestMapping("/test.html")public String test(String userCode,Model model)&#123;model.addAttribute("userCode", userCode);return "success";&#125;&#125; 参数传递12345678910111213141516171819202122//params和@RequestParam的参数要一致@RequestMapping(value="/welcome",method=RequestMethod.GET)public String welcome(@RequestParam(value="username",required=false) String username)&#123;logger.info("welcome" +username);return "index";&#125;required=false //属性不必须@RequestMapping("/index2")public String index2(@RequestParam String username,Model model)&#123;model.addAttribute("username", username);//可以直接传对象model.addAttribute(username);User user=new User();user.setUserName(username);model.addAttribute("users", user);return "index";&#125;@RequestMapping("/index3")public String index3(@RequestParam String username,Map&lt;String, Object&gt; model)&#123;model.put("username", username);return "index";&#125;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring配置补充]]></title>
    <url>%2F2018%2F11%2F06%2FSpring%E9%85%8D%E7%BD%AE%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[灵活配置DataSource使用属性文件配置数据源123456789101112&lt;!-- 使用数据配置文件设置数据源 --&gt;&lt;beanclass="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;&lt;property name="location"&gt;&lt;value&gt;classpath:database.properties&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 数据源在配置文件中 --&gt;&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;&lt;property name="driverClassName" value="$&#123;driver&#125;"&gt;&lt;/property&gt; &lt;propertyname="url" value="$&#123;url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;user&#125;"&gt;&lt;/property&gt;&lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; 使用jndi数据源 Context节点下12345678910&lt;!-- 使用jndi数据源 在tomcat content.xml配置 --&gt;&lt;Resource name="jndi/smbms" auth="Container" type="javax.sql.DataSource"maxActive="100" maxIdle="30" driverClassName="com.mysql.jdbc.Driver"username="root" password="123456"url="jdbc:mysql://localhost:3306/smbms?useUnicode=true&amp;characterEncoding=utf-8" /&gt;&lt;!-- &lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;&lt;property name="jndiName"&gt;&lt;value&gt;java:comp/env/jndi/smbms&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt; --&gt; Spring中bean的作用域（scope属性）singleton 默认值：单利模式创建bean的实例，实例只有一个 安全差prototype 每次从容器中获取bean时，都会创建一个新的beanrequest web环境 针对每次请求都会创建一个新的beansession web环境 同一个会话共享一个，不同会话使用不同的实例使用注解指定作用域@Scope（””）@Service() Spring自动装配12345autowire属性：no：不使用自动装配，bean依赖关系必须通过property定义bytype：根据属性类型进行装配，寻找容器中的全部bean，找出属性类型相同的bean，如果有多个抛出异常byName：根据属性名进行装配，找出id与属性的setter方法匹配的beanconstructor：与bytype相似，但是用于构造器参数 拆分Spring配置文件12345ApplicationContext ctx=new ClassPathXmlApplicationContext("applicationContextl.xmlapplicationContextl-dao.xmlapplicationContextl-service.xml");使用import导入主配置文件&lt;import resource=""/&gt;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis与Spring的整合]]></title>
    <url>%2F2018%2F11%2F06%2FMybatis%E4%B8%8ESpring%E7%9A%84%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[配置环境添加jar包1234567891011121314151617181920aopalliance-1.0.jaraspectjweaver-1.6.9.jaraspectjweaver.jarcommons-dbcp-1.4.jarcommons-logging-1.2.jarcommons-pool-1.6.jarlog4j-1.2.16.jarlog4j-1.2.17.jarmybatis-3.2.2-sources.jarmybatis-3.2.2.jarmybatis-spring-1.2.0.jarmybatis-spring-1.3.2.jarmysql-connector-java-5.1.0-bin.jarspring-aop-3.2.13.RELEASE.jarspring-beans-3.2.13.RELEASE.jarspring-context-3.2.13.RELEASE.jarspring-core-3.2.13.RELEASE.jarspring-expression-3.2.13.RELEASE.jarspring-jdbc-3.2.13.RELEASE.jarspring-tx-3.2.13.RELEASE.jar 创建数据访问接口（mapper）结尾，实体类，配置MyBatis配置文件配置数据源关键12commons-dbcp-1.4.jarcommons-pool-1.6.jar 在applicationContextl.xml中配置、12345678&lt;!-- 数据源 --&gt;&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;&lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;&lt;property name="url"value="jdbc:mysql://localhost:3306/smbms?useUnicode=true&amp;amp;characterEncoding=utf-8"&gt;&lt;/property&gt;&lt;property name="username" value="root"&gt;&lt;/property&gt;&lt;property name="password" value="123456"&gt;&lt;/property&gt;&lt;/bean&gt; &amp;符号加&amp; 配置SqlSessionFactoryBean获取sqlSessionFactory实例 123456789101112&lt;!-- 配置SqlSessionFactoryBean --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;!-- 引用Mybatis文件中的数据--&gt;&lt;property name="configLocation" value="classpath:mybatis-configl.xml"&gt;&lt;/property&gt;&lt;property name="mapperLocations"&gt;&lt;list&gt;&lt;value&gt;classpath:cn/dao/UserMapper.xml&lt;/value&gt;&lt;value&gt;classpath:cn/dao/ProviderMapper.xml&lt;/value&gt;&lt;/list&gt;&lt;/property&gt;&lt;/bean&gt; 使用SqlSessionTemplate实现数据库操作 配置SqlSessionTemplate在实现类中的代码12345private SqlSessionTemplate sqlSession; getter 和 setter方法@Overridepublic int add(User user) &#123;return sqlSession.getMapper(UserMapper.class).add(user);&#125; Spring配置文件创建SqlSessionTemplate1234&lt;!-- 配置SqlSessionTemplate --&gt;&lt;!-- &lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate"&gt;&lt;constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; --&gt; 实现类继承SqlSessionDaoSupport简化SqlSessionTemplate的配置与获取1return this.getSession().getMapper(UserMapper.class).add(user); Spring配置文件:：12&lt;!-- &lt;bean id="userMapper" class="cn.dao.UserMapperImpl"&gt;&lt;propertyname="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; 注入映射器实现 MapperFactoryBean注入映射器1234&lt;!-- Dao --&gt;&lt;!-- &lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt;&lt;property name="mapperInterface" value="cn.dao.UserMapper"&gt;&lt;/property&gt; &lt;propertyname="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; 无需手工定义实现类，配置MapperFactoryBean可以自动生成使用MapperScannerConfigurer注入映射器可以扫描指定包中的接口并将他们直接定义为MapperFactoryBean1234&lt;!-- 配置Dao --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;&lt;property name="basePackage" value="cn.dao"&gt;&lt;/property&gt;&lt;/bean&gt; 配置声明式事务添加头文件tx和aop12345678910111213141516&lt;!-- 事务管理器 --&gt;&lt;bean id="txManager"class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事务增强 --&gt;&lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;&lt;tx:attributes&gt;&lt;tx:method name="*" propagation="REQUIRED" /&gt;&lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置切面 --&gt;&lt;aop:config&gt;&lt;aop:pointcut expression="execution(* cn.service..*.*(..))" id="myPoint"/&gt;&lt;aop:advisor advice-ref="txAdvice" pointcut-ref="myPoint"/&gt;&lt;/aop:config&gt; 使用注解实现声明式事务处理123456&lt;!-- 事务管理器 --&gt;&lt;bean id="txManager"class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;context:component-scan base-package="cn.service"&gt;&lt;/context:component-scan&gt; 1234@Transactional 全局class@Transactional (propagation=Propagation.SUPPORTS)public int add()&#123;....&#125;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IOC和AOP的使用扩展]]></title>
    <url>%2F2018%2F11%2F06%2FIOC%E5%92%8CAOP%E7%9A%84%E4%BD%BF%E7%94%A8%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[多种方式实现依赖注入通过构造有参函数12345&lt;bean id="userService" class="cn.service.impl.UserServiceimpl"&gt;&lt;constructor-arg ref="userdao" index="0"/&gt;&lt;constructor-arg index="1" value="宇智波鼬" /&gt;&lt;constructor-arg index="2" value="只要是人都是依靠自己的知识与认知并且被之束缚生活着的，那就叫做现实。但是知识与认知是模糊不清的东西，现实也许只是镜中花水中月，人都是活在自己的执念中的，你不这么认为吗"/&gt;&lt;/bean&gt; index代表参数位置，从0开始简单类型为value，引用类型为ref 通过p命名空间(通过seter方法)1&lt;bean id="users" class="cn.entity.User" p:name="宇智波鼬u" p:email="302645509@qq.com" p:dress="永济市" p:mess="无论你变成什么样,我都会永远爱着你"/&gt; 设置变量值：p：属性值=“”，设置引用变量：p：属性名-ref=“”； 注入集合类型list 允许重复(通过seter方法)12345&lt;bean id="play" class="naruto.entity.Player"&gt;&lt;property name="armet" ref="tou"&gt;&lt;list&gt;&lt;value&gt;&lt;/value&gt;&lt;ref&gt;&lt;/ref&gt;&lt;/list&gt;&lt;property&gt;&lt;/bean&gt; set 连线一组值，但不能重复12345&lt;bean id="play" class="naruto.entity.Player"&gt;&lt;property name="armet" ref="tou"&gt;&lt;set&gt;&lt;value&gt;&lt;/value&gt;&lt;ref&gt;&lt;/ref&gt;&lt;/set&gt;&lt;property&gt;&lt;/bean&gt; map 名称-值对的集合，其中名称和值可以是任何类型12345&lt;bean id="play" class="naruto.entity.Player"&gt;&lt;property name="armet" ref="tou"&gt;&lt;map&gt;&lt;entry&gt;&lt;key&gt;&lt;value&gt;&lt;/value&gt;&lt;/key&gt;&lt;value&gt;&lt;/value&gt;&lt;/entry&gt;&lt;/map&gt;&lt;property&gt;&lt;/bean&gt; 注入null和空123456&lt;property name="armet" ref="tou"&gt;&lt;value&gt;&lt;/value&gt;&lt;property&gt;&lt;property name="armet" ref="tou"&gt;&lt;null/&gt;&lt;property&gt; 使用注解实现bean组建装配1234@Component(“userDao”) == &lt;bean id="userDao" class="cn...l"&gt;@Repository //标识dao类@Service //标识业务类@Controller //标识控制器类 使用@Autowired实现bean的装配12345@Autowired private SpellChecker spellChecker; //可以省略相关的setter（）方法采用按照类型匹配的方式自动装配合适的依赖对象如有一个以上的类型相匹配的bean时，使用@Qualifier指定所需bean的名称@Autowired @Qualifier("student1") private Student student; 加载注解定义的bean在配置文件中添加对context的命名空间的声明1&lt;context:annotation-config/&gt; @Autowired 对方法的参数进行标注1@Autowired public void setDao(@Qualifier("userDao") User dao) setter()和构造方法 使用Java标准注解进行装配123@Resource@Resource private SpellChecker spellChecker;如果没有显示的指定bean名称，会根据字段名或时setter产生的名称 使用注解实现aop声明一个 aspect Aspects 类和其他任何正常的 bean 一样，除了它们将会用 @AspectJ 注释之外，它和其他类一样可能有方法和字段123@Aspect public class AspectModule &#123; &#125;声明一个切入点@Pointcut("execution(* com.xyz.myapp.service.*.*(..))") // expression private void businessService() &#123;&#125; 声明12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Aspectpublic class UserServiceLogger &#123; private static final Logger LOGGER=Logger.getLogger(UserServiceLogger.class); @Pointcut("execution(* cn.service..*.*(..)) ") public void pointcut()&#123;&#125; /** * 前置增强 * @param jp */ @Before("pointcut()") public void before(JoinPoint jp) &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法入参：" + Arrays.toString(jp.getArgs())); &#125; /** * 后置增强 * @param jp * @param returnValue */ @AfterReturning(pointcut = "pointcut()", returning = "returnValue") public void afterReturning(JoinPoint jp, Object returnValue) &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法返回值：" + returnValue); &#125; /** * 最终增强 * @param jp */ @After("pointcut()") public void afterLogger(JoinPoint jp) &#123; LOGGER.info(jp.getSignature().getName() + " 方法结束执行。"); &#125; /** * 异常增强 * @param jp * @param e */ @AfterThrowing(value="pointcut()", throwing = "e") public void afterThrowing(JoinPoint jp, RuntimeException e) &#123; LOGGER.error(jp.getSignature().getName() + " 方法发生异常：" + e); &#125; /** * 环绕增强 * @param jp * @return * @throws Throwable */ @Around("pointcut()") public Object aroundLogger(ProceedingJoinPoint jp) throws Throwable &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法入参：" + Arrays.toString(jp.getArgs())); try &#123; Object result = jp.proceed(); LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法返回值：" + result); return result; &#125; catch (Throwable e) &#123; LOGGER.error(jp.getSignature().getName() + " 方法发生异常：" + e); throw e; &#125; finally &#123; LOGGER.info(jp.getSignature().getName() + " 方法结束执行。"); &#125; &#125; &#125;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring核心概念]]></title>
    <url>%2F2018%2F11%2F06%2FSpring%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[控制反转（ioc）也成为依赖注入，来降低代码之间的耦合度搭建spring环境部署jar包12345commons-logging-1.2.jarspring-beans-3.2.13.RELEASE.jarspring-context-3.2.13.RELEASE.jarspring-core-3.2.13.RELEASE.jarspring-expression-3.2.13.RELEASE.jar 创建resources目录，在里面创建applicationContextl.xml1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:aop="http://www.springframework.org/schema/aop"xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsd"&gt;//根据属性seter()方法&lt;bean id="kai" class="naruto.entity.Equip"&gt;&lt;property name="name" value="万世荣光铠甲"/&gt;&lt;property name="speedPlus" value="4"/&gt;&lt;property name="attackPlus" value="108"/&gt;&lt;property name="defencePlus" value="40"/&gt;&lt;property name="type" value="铠甲"/&gt;&lt;/bean&gt;&lt;/bean&gt; 创建测试类12ClassPathXmlApplicationContext context=new ClassPathXmlApplicationContext("applicationContextl.xml"); //xml路径EquipMess jc=(EquipMess)context.getBean("equip"); //bean的id值 aop1234加入jar包spring-aop-3.2.13.RELEASE.jaraopalliance-1.0.jaraspectjweaver.jar 在aop包下创建aop输出类（前置和后置）1234567private static Logger logger=Logger.getLogger(UserServiceLogger.class);public void before(JoinPoint jp)&#123;logger.info("调用"+jp.getTarget()+"的"+jp.getSignature()+"方法，方法参数"+Arrays.toString(jp.getArgs()));&#125;public void afterReturning(JoinPoint jp,Object result)&#123;logger.info("调用"+jp.getTarget()+"的"+jp.getSignature()+"方法，方法返回值"+result);&#125; spring陪着文件导入相关配置定义切入点，加入增强处理12345678910&lt;bean id="theLogger" class="naruto.aop.Snippet"&gt;&lt;/bean&gt;&lt;aop:config&gt;&lt;aop:pointcut id="pointcut"expression="execution(public void updateEquip(entity.Equip))" /&gt;&lt;aop:aspect ref="theLogger"&gt;&lt;aop:before method="before" pointcut-ref="pointcut"&gt;&lt;/aop:before&gt;&lt;aop:after-returning method="afterReturning"pointcut-ref="pointcut" returning="result" /&gt;&lt;/aop:aspect&gt;&lt;/aop:config&gt;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis动态SQL]]></title>
    <url>%2F2018%2F11%2F06%2FMybatis%E5%8A%A8%E6%80%81SQL%2F</url>
    <content type="text"><![CDATA[if 语句123456&lt;select id="selectUserByUsernameAndSex" resultType="user" parameterType="com.ys.po.User"&gt;select * from user where&lt;if test="username != null"&gt;username=#&#123;username&#125;&lt;/if&gt;&lt;/select&gt; if+where 语句1234567891011&lt;select id="selectUserByUsernameAndSex" resultType="user" parameterType="com.ys.po.User"&gt;select * from user&lt;where&gt;&lt;if test="username != null"&gt;username=#&#123;username&#125;&lt;/if&gt;&lt;if test="username != null"&gt;and sex=#&#123;sex&#125;&lt;/if&gt;&lt;/where&gt;&lt;/select&gt; “where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。 if+set 语句12345678910111213&lt;!-- 根据 id 更新 user 表的数据 --&gt;&lt;update id=&quot;updateUserById&quot; parameterType=&quot;com.ys.po.User&quot;&gt;update user u&lt;set&gt;&lt;if test=&quot;username != null and username != &apos;&apos;&quot;&gt;u.username = #&#123;username&#125;,&lt;/if&gt;&lt;if test=&quot;sex != null and sex != &apos;&apos;&quot;&gt;u.sex = #&#123;sex&#125;&lt;/if&gt;&lt;/set&gt;where id=#&#123;id&#125;&lt;/update&gt; 如果第一个条件 username 为空，那么 sql 语句为：update user u set u.sex=? where id=?如果第一个条件不为空，那么 sql 语句为：update user u set u.username = ? ,u.sex = ? where id=? choose(when,otherwise) 语句12345678910111213141516&lt;select id="selectUserByChoose" resultType="com.ys.po.User" parameterType="com.ys.po.User"&gt;select * from user&lt;where&gt;&lt;choose&gt;&lt;when test="id !='' and id != null"&gt;id=#&#123;id&#125;&lt;/when&gt;&lt;when test="username !='' and username != null"&gt;and username=#&#123;username&#125;&lt;/when&gt;&lt;otherwise&gt;and sex=#&#123;sex&#125;&lt;/otherwise&gt;&lt;/choose&gt;&lt;/where&gt;&lt;/select&gt; 和switch语句差不多 trim 语句12345678910111213141516171819&lt;select id="selectUserByUsernameAndSex" resultType="user" parameterType="com.ys.po.User"&gt;select * from user&lt;!-- &lt;where&gt;&lt;if test="username != null"&gt;username=#&#123;username&#125;&lt;/if&gt;&lt;if test="username != null"&gt;and sex=#&#123;sex&#125;&lt;/if&gt;&lt;/where&gt; --&gt;&lt;trim prefix="where" prefixOverrides="and | or"&gt;&lt;if test="username != null"&gt;and username=#&#123;username&#125;&lt;/if&gt;&lt;if test="sex != null"&gt;and sex=#&#123;sex&#125;&lt;/if&gt;&lt;/trim&gt;&lt;/select&gt; prefix：前缀prefixoverride：去掉第一个and或者是or12345678&lt;trim prefix="set" suffixOverrides=","&gt; //去掉最后一个逗号&lt;if test="username != null and username != ''"&gt;u.username = #&#123;username&#125;,&lt;/if&gt;&lt;if test="sex != null and sex != ''"&gt;u.sex = #&#123;sex&#125;,&lt;/if&gt;&lt;/trim&gt; foreach 语句12345678910111213141516&lt;select id="selectUserByListId" parameterType="com.ys.vo.UserVo" resultType="com.ys.po.User"&gt; select * from user &lt;where&gt; &lt;!-- collection:指定输入对象中的集合属性 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串 select * from user where 1=1 and (id=1 or id=2 or id=3) --&gt; &lt;foreach collection="ids" item="id" open="and (" close=")" separator="or"&gt; id=#&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MybatisSQL映射文件]]></title>
    <url>%2F2018%2F11%2F06%2FMybatisSQL%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[sql映射文件顶级元素配置mapper：映射元素的根节点，只有一个属性namespace，用于区分不同的mapper，绑定dao接口cache：配置给命名空间引用缓存cache-ref：从其他命名空间引用缓存配置resultMap：描述数据库结果集和对象的对应关系sql：可以重用的sql块 insert：插入语句12345&lt;insert id="add" parameterType="Destineinfo"&gt;INSERT INTOdestineinfo(room_name,destine_time,destine_name,dress)VALUES(#&#123;room_name&#125;,#&#123;destine_time&#125;,#&#123;destine_name&#125;,#&#123;dress&#125;)&lt;/insert&gt; delete：删除语句123&lt;delete id="dele"&gt;DELETE FROM destineinfo where id=#&#123;id&#125;&lt;/delete&gt; update：更新语句12345&lt;update id="modify" parameterType="Destineinfo"&gt;UPDATE destineinfo SETroom_name=#&#123;room_name&#125;,destine_name=#&#123;destine_name&#125;where id=#&#123;id&#125;&lt;/update&gt; select：查询语句namespace的命名必须和某个dao接口相同，已Mapper结尾接口中的方法与映射文件中的sql语句id要对应的 눈눈select属性id：命名空间的唯一标识符，要和接口的方法一致눈눈parameterType：传入参数的类型，可以是类，或基本数据类型resultType：查询语句返回结果类型，可以是类，或基本数据类型 使用map入参查询1234&lt;select id="getMap" resultType="Destineinfo" parameterType="Map"&gt;SELECT * FROM destineinfo WHERE destine_name LIKECONCAT('%',#&#123;name&#125;,'%')&lt;/select&gt; map对象.put(“name”,姓名)； 使用resultMap完成查询结果的展现用于数据库字段名不同与实体类的属性名 ，可以进行自动映射 resultMap自动映射(FULL)12&lt;!-- 设置resultMap的自动映射级别为none(禁止自动匹配) --&gt;&lt;!-- &lt;setting name="autoMappingBehavior" value="NONE"/&gt; --&gt; 自动映射前提：字段名和属性名要一致12345&lt;result property="id" column="id" /&gt;&lt;result property="room_name" column="room_name" /&gt;&lt;result property="destine_time" column="destine_time" /&gt;&lt;result property="destine_name" column="destine_name" /&gt;&lt;result property="dressName" column="dressName" /&gt; 使用resultType完成查询结果的展现直接返回类型，包括基本数据类型和复杂数据类型resultType和resultMap只能有一个使用@param实现多参数入参12xml中id为updateName的id和destine_namepublic int updateName(@Param("id")Integer id,@Param("destine_name")String name); 高级映射association12345678&lt;resultMap type="Destineinfo" id="userRoleResult"&gt; &lt;id property="id"column="id" /&gt; &lt;result property="room_name" column="room_name"/&gt; &lt;resultproperty="destine_time" column="destine_time"/&gt; &lt;result property="destine_name"column="destine_name"/&gt; &lt;association property="dress2" javaType="Dress"&gt;&lt;id property="id" column="r_id" /&gt; &lt;result property="dressName" column="dressName"/&gt;&lt;/association&gt; &lt;/resultMap&gt; association映射 &lt;select id="getListByDressid" resultMap="userRoleResult"parameterType="Integer"&gt; SELECT d.*,s.id as r_id,s.dressName FROM destineinfod, dress s WHERE d.dress=#&#123;dress&#125; and d.dress=s.id &lt;/select&gt; 可以内嵌12345&lt;association property="dress2" javaType="Dress" resultMap="roleResult" /&gt;&lt;resultMap type="Dress" id="roleResult"&gt;&lt;id property="id" column="r_id"/&gt;&lt;result property="dressName" column="dressName"/&gt;&lt;/resultMap&gt; 使用对象 1对1association属性property：实体对象的属性，此处为user里定义的Role类对象rolejavaType：完整的Java类名或别名 collection123456789101112&lt;resultMap type="Destineinfo" id="userAddressResult"&gt;&lt;id property="id" column="id"/&gt;&lt;result property="room_name" column="room_name" /&gt;&lt;result property="destine_time" column="destine_time" /&gt;&lt;result property="destine_name" column="destine_name" /&gt;&lt;result property="dress" column="dress" /&gt;&lt;collection property="addressList" ofType="Dress" resultMap="Addresss" /&gt;&lt;/resultMap&gt;&lt;resultMap type="Dress" id="Addresss"&gt;&lt;id property="id" column="r_id"/&gt;&lt;result property="dressName" column="dressName"/&gt;&lt;/resultMap&gt; collection属性property：实体对象的属性ofType：完整的Java类名或别名使用集合 1对多]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初识Mybatis]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%88%9D%E8%AF%86Mybatis%2F</url>
    <content type="text"><![CDATA[部署mybatis部署jar包创建database.properties和mybatis-configl.xml文件12345database.propertiesdriver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/boardroom?useUnicode=true&amp;characterEncoding=utf-8user=rootpassword=123456 mybatis-configl.xml 最重要的核心文件123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;!-- 引入database.properties文件 --&gt;&lt;properties resource="database.properties" /&gt;&lt;!-- 配置mybatis的log实现为LOG4J --&gt;&lt;settings&gt;&lt;setting name="logImpl" value="LOG4J" /&gt;&lt;/settings&gt;&lt;typeAliases&gt;&lt;typeAlias alias="user" type="cn.entity.User"/&gt;&lt;typeAlias alias="product" type="cn.entity.Product"/&gt;&lt;package name="cn.entity"/&gt;&lt;/typeAliases&gt;&lt;!-- 配置mybatis多套运行环境 --&gt;&lt;environments default="development"&gt;&lt;environment id="development"&gt;&lt;!-- 配置事务管理,采用JDBC的事务管理 --&gt;&lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt;&lt;!-- POOLED:mybatis自带的数据源,JNDI:基于tomcat的数据源 --&gt;&lt;dataSource type="POOLED"&gt;&lt;property name="driver" value="$&#123;driver&#125;"/&gt;&lt;property name="url" value="$&#123;url&#125;"/&gt;&lt;property name="username" value="$&#123;user&#125;"/&gt;&lt;property name="password" value="$&#123;password&#125;"/&gt;&lt;/dataSource&gt;&lt;/environment&gt;&lt;/environments&gt;&lt;!-- 将mapper文件加入到配置文件中 --&gt;&lt;mappers&gt;&lt;mapper resource="cn/entity/ProductMapper.xml"/&gt;&lt;mapper resource="cn/entity/DestineinfoMapper.xml"/&gt;&lt;/mappers&gt;&lt;/configuration&gt; util包下创建MyBatisUtil.java文件12345678910111213141516171819private static SqlSessionFactory factory;static&#123;InputStream is;try &#123;is = Resources.getResourceAsStream("mybatis-configl.xml");factory=new SqlSessionFactoryBuilder().build(is);&#125; catch (IOException e) &#123;// TODO Auto-generated catch blocke.printStackTrace();&#125;&#125;public static SqlSession CreateSqlSession()&#123;return factory.openSession(false); //true为自动提交事务&#125;public static void closeSqlSession(SqlSession sqlSession)&#123;if(null!=sqlSession)&#123;sqlSession.close();&#125;&#125; dao层创建接口,以实体类名字+mapper命名entity层创建实体类和实体类名字+mapper.xml1234567891011namespace建议使用接口地址，进行增删改查&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.dao.impl.DestineinfoMapper"&gt;&lt;!-- 查询用户表记录数 --&gt;&lt;select id="selall" resultType="Destineinfo"&gt;SELECT * FROM destineinfo&lt;/select&gt;&lt;/mapper&gt; 创建测试类1234567891011121314151617@Testpublic void testGetUserList()&#123;SqlSession sqlSession=null;List&lt;Destineinfo&gt;userList=new ArrayList&lt;Destineinfo&gt;();try &#123;sqlSession=MyBatisUtil.CreateSqlSession();userList=sqlSession.getMapper(DestineinfoMapper.class).selall();&#125; catch (Exception e) &#123;// TODO: handle exceptione.printStackTrace();&#125;finally &#123;MyBatisUtil.closeSqlSession(sqlSession);&#125;for (Destineinfo destineinfo : userList) &#123;logger.debug("testGetUserList userCodeL"+destineinfo.getId()+"--"+destineinfo.getRoom_name()+"--"+destineinfo.getDestine_name()+"------"+destineinfo.getDestine_time());&#125;&#125; mybatis核心对象SqlSessionFactoryBuilder负责构建SqlSessionFactory，特点：用过就丢，SqlSessionFactory创建后就不不需要存在了 SqlSessionFactory创建SqlSession实例的工厂，SqlSession通过SqlSessionFactory的openSession()来获取openSession()的参数为bollean类型时，true为关闭事务控制，自动提交，不穿参数，默认为true一旦创建始终存在,不建议创建多个 SqlSession用于持久化操作的对象，类似与jdbc的connection，提供了面向数据库sql命令的所有方法使用SqlSession的两种方法通过sqlSession实例直接执行已映射的sql语句通过mapper接口方法操作数据 mybatis-configl.xml的核心元素typeAliases配置类型别名12345&lt;typeAliases&gt;&lt;typeAlias alias="user" type="cn.entity.User"/&gt;&lt;typeAlias alias="product" type="cn.entity.Product"/&gt;&lt;package name="cn.entity"/&gt;&lt;/typeAliases&gt; mappers映射器1234&lt;mappers&gt;&lt;mapper resource="cn/entity/ProductMapper.xml"/&gt;&lt;mapper resource="cn/entity/DestineinfoMapper.xml"/&gt;&lt;/mappers&gt;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[漫漫归家路]]></title>
    <url>%2F2018%2F11%2F05%2F%E6%BC%AB%E6%BC%AB%E5%BD%92%E5%AE%B6%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[漫漫归家路其实我喊了一次又一次，每一次，都清醒的认识到果然没有人回应我，无论怎么呼唤，怎么祈祷，还是有无法实现的东西。 最后还是没能找到家，迷路了，累到了，然后，我决定不在呼唤无法给予我回应的东西。——《夏目友人帐》漫漫回家路]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[S8决赛IG3:0夺冠]]></title>
    <url>%2F2018%2F11%2F04%2FS8%E5%86%B3%E8%B5%9BIG3-0%E5%A4%BA%E5%86%A0%2F</url>
    <content type="text"><![CDATA[一个纨绔的老板， 一个没战队要的上单， 一个附赠的中单， 一个借来的打野， 一个直播抓来的ad， 一个双排排到的辅助， 一支没什么人看好的战队， 一场全球总决赛冠军， 一座山，山后是你们的故事 恭喜IG]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理想乡]]></title>
    <url>%2F2018%2F11%2F02%2F%E7%90%86%E6%83%B3%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[理想乡孤独な巡礼我在这世上活着 手无寸铁 没有任何人站在我的身后 挡住汹涌的风 更没有人能站在我的面前 挡住浩瀚的阳光 我在这世上活着 怀抱一小弦洁净 像黑夜抱着月亮那样慎重 怀抱着一大束荆棘 像土地抱着青草那样深情 怀抱着一大捧冰雪 像群山怀抱着清泉一样珍重 我在这世上活着 一切规章一切守则都是假设 他们说 你得有人 才是真的 我抱紧我自己 我有我自己 抱得更紧更牢靠一些啊 我的尊严 我的本份 我人的样子 我活在这世上 手无寸铁 没有刀锋 没有尖锐的刺 从不无往不利 从不春风得意 我站立的姿势比剑优美 我沉醉的笑容比花绚丽 我写字的认真比诵经虔诚 我痛哭的声音比长歌真实 我活在这世上 手无寸铁 我活在这世上 自强自立 自得其美 我只有 自己]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库应用]]></title>
    <url>%2F2018%2F11%2F01%2FOracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[表空间（用来存放各种应用文件）一般分为三种123$ 永久性表空间：一般保存表，过程，索引等数据$ 临时性表空间：只用于保存系统中短期活动的数据，如排序数据$ 撤销表空间：用来帮助回退为=未提交的事务数据 那么为什么要创建表空间呢？对不同用户分配不同的表空间，方便管理有利于管理磁盘空间，提高i/o性能 一些基本的授权1234567891011创建用户没有授权【创建表】create table student(stu_id number(2),stu_name varchar2(10));create table student(stu_id number(2),stu_name varchar2(10))*第 1 行出现错误:ORA-01031: 权限不足?//使用system用户授权grant connect,resource to martin; //授权用户connect,resource 权限grant select on scott.emp to martin; //允许用户查看emp表中记录grant update on scott.emp to martin; //允许用户修改emp表中记录 同义词（公有和私有 //私有只能被当前模式用户访问）简化sql语句隐藏对象名称和所有者为分布式数据库的远程对象提供了位置透明性提供对象的公共访问 给用户martin授权同义词 grant create synonym to martin; ? 创建私有同义词 SQL&gt; create synonym sy_emp for system.employee; ? 同义词已创建。 ? SQL&gt; select *from sy_emp; ? 创建共有同义词（在物主用户上创建） SQL&gt; create public synonym public_sy_emp for employee; ? 同义词已创建。 ? SQL&gt; ? 删除私有同义词 SQL&gt; drop synonym martin.sy_emp; ? 同义词已删除。 ? SQL&gt; ? 删除共有同义词 SQL&gt; drop public synonym public_sy_emp; ? 同义词已删除。 SQL&gt; 创建序列和就是生成主键要用的，感觉不好用 SQL&gt; create sequence seq1 2 start with 10 3 increment by 1 4 maxvalue 2000 5 nocycle 6 cache 30; ? 序列已创建。 ? SQL&gt; create table toys(toyid number(2), toyname varchar2(10),toyprice number(4,2)); ? 表已创建。 ? SQL&gt; insert into toys(toyid,toyname,toyprice)values(seql.nextval,'杰尼龟',25); insert into toys(toyid,toyname,toyprice)values(seql.nextval,'杰尼龟',25) * 第 1 行出现错误: ORA-02289: 序列不存在 ? ? SQL&gt; insert into toys(toyid,toyname,toyprice)values(seq1.nextval,'杰尼龟',25); ? 已创建 1 行。 ? SQL&gt; insert into toys(toyid,toyname,toyprice)values(seq1.nextval,'憨八龟',35); ? 已创建 1 行。 ? SQL&gt; select * from toys; ? TOYID TOYNAME TOYPRICE ---------- -------------------- ---------- 11 杰尼龟 25 12 憨八龟 35 ? SQL&gt; create table tots(totid number(2), totname varchar2(10),totprice number(4,2)); ? 表已创建。 ? SQL&gt; insert into tots(totid,totname,totprice)values(seq1.nextval,'小火龙',40); ? 已创建 1 行。 ? SQL&gt; insert into tots(totid,totname,totprice)values(seq1.nextval,'毒龙钻',80); ? 已创建 1 行。 ? SQL&gt; select * from tots; ? TOTID TOTNAME TOTPRICE ---------- -------------------- ---------- 14 小火龙 40 15 毒龙钻 80 反向键索引目的：比如索引值是一个自动增长的列多个用户对集中在少数块上的索引行进行修改，容易引起资源的争用，比如对数据块的等待。此时建立反向索 引。语法：CREATE INDEX index_REVERSE_EMPNO ON table (column) REVERSE; 位图索引1、 何时创建：列中有非常多的重复的值时候。例如某列保存了 “性别”信息。Where 条件中包含了很多OR操作符。较少的update操作，因为要相应的跟新所有的bitmap2、 结构：位图索引使用位图作为键值，对于表中的每一数据行位图包含了TRUE(1)、FALSE(0)、或NULL值。3、 优点：位图以一种压缩格式存放，因此占用的磁盘空间比标准索引要小得多4、 语法：CREATE BITMAP INDEX index ON table (column[, column]…); 唯一索引1、 何时创建：当某列任意两行的值都不相同2、 当建立Primary Key(主键)或者Unique constraint(唯一约束)时，唯一索引将被自动建立3、 语法：CREATE UNIQUE INDEX index ON table (column); 熟练并背诵数据库建立索引的原则1，确定针对该表的操作是大量的查询操作还是大量的增删改操作。?2，尝试建立索引来帮助特定的查询。检查自己的sql语句，为那些频繁在where子句中出现的字段建立索引。?3，尝试建立复合索引来进一步提高系统性能。修改复合索引将消耗更长时间，同时，复合索引也占磁盘空间。?4，对于小型的表，建立索引可能会影响性能?5，应该避免对具有较少值的字段进行索引。?6，避免选择大型数据类型的列作为索引。?索引建立的原则?索引查询是数据库中重要的记录查询方法，要不要进入索引以及在那些字段上建立索引都要和实际数据库系统的查询要求结合来考虑，下面给出实际中的一些通用的原则：? 在经常用作过滤器的字段上建立索引；? 在SQL语句中经常进行GROUP BY、ORDER BY的字段上建立索引；? 在不同值较少的字段上不必要建立索引，如性别字段；? 对于经常存取的列避免建立索引；? 用于联接的列（主健/外健）上建立索引；? 在经常存取的多个列上建立复合索引，但要注意复合索引的建立顺序要按照使用的频度来确定；? 缺省情况下建立的是非簇集索引，但在以下情况下最好考虑簇集索引，如：含有有限数目（不是很少）唯一的列；进行大范围的查询；充分的利用索引可以减少表扫描I/0的次数，有效的避免对整表的搜索。当然合理的索引要建立在对各种查询的分析和预测中，也取决于DBA的所设计的数据库结构。 范围分区（超好用，就是麻烦）范围分区（数字类型） create table graderecord ( sno varchar2(10), sname varchar2(20), dormitory varchar2(3), grade int ) partition by range(grade) ( partition bujige values less than(60), --不及格 partition jige values less than(85), --及格 partition youxiu values less than(maxvalue) --优秀 ) ? 范围分区（日期类型） create table sales ( sales_id number, product_id varchar2(5), sales_date date not null, sales_cost number(10), areacode varchar2(10) ) partition by range(sales_date) ( partition p1 values less than(to_date('2013-04-1','yyyy-mm-dd')), partition p2 values less than(to_date('2013-07-1','yyyy-mm-dd')), partition p3 values less than(to_date('2013-10-1','yyyy-mm-dd')), partition p4 values less than(to_date('2014-01-1','yyyy-mm-dd')), partition p5 values less than(maxvalue) ); insert into sales values(1,'22',to_date('2013-04-1','yyyy-mm-dd'),92,'美国'); insert into sales values(2,'22',to_date('2013-05-1','yyyy-mm-dd'),92,'韩国'); insert into sales values(3,'23',to_date('2013-08-1','yyyy-mm-dd'),92,'中国'); insert into sales values(4,'24',to_date('2013-11-1','yyyy-mm-dd'),92,'日本'); insert into sales values(5,'25',to_date('2013-09-1','yyyy-mm-dd'),92,'俄罗斯'); 查询分区情况查询分区情况 SELECT table_name,partition_name,tablespace_name FROM user_tab_partitions WHERE table_name=UPPER('sales_interval1'); 间隔分区表，会自动创建分区=========================================================== | 间隔分区表 ============================================================ */ CREATE TABLE sales_interval1 (sales_id NUMBER NOT NULL, product_id VARCHAR2(5), sales_date DATE, sales_cost NUMBER(10), areacode VARCHAR2(5) ) PARTITION BY RANGE(sales_date) INTERVAL(NUMTOYMINTERVAL(1,'YEAR')) (PARTITION part1 VALUES LESS THAN (to_date('2011/01/01','yyyy/mm/dd'))) 使用分区查找信息查看分区并查询信息 SQL&gt; select table_name,partition_name from user_tab_partitions where table_name=upper('sales2'); ? TABLE_NAME ------------------------------------------------------------ PARTITION_NAME ------------------------------------------------------------ SALES2 P1 ? SALES2 SYS_P24 ? ? SQL&gt; select * from sales2 partition(sys_p24); ? SALES_ID PRODUCT_ID SALES_DATE SALES_COST AREACODE ---------- ---------- -------------- ---------- -------------------- 4 24 01-11月-13 92 日本 5 25 01-9月 -13 92 俄罗斯 ? SQL&gt; select * from sales2 partition(p1); ? SALES_ID PRODUCT_ID SALES_DATE SALES_COST AREACODE ---------- ---------- -------------- ---------- -------------------- 1 22 01-4月 -13 92 美国 2 22 01-5月 -13 92 韩国 3 23 01-8月 -13 92 中国 ? SQL&gt; ? 今天我是听着Ragga Bomb -Skrillex完成的]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[漫漫归家路]]></title>
    <url>%2F2018%2F11%2F01%2F2018-DJ-MAG%2F</url>
    <content type="text"><![CDATA[漫漫归家路其实我喊了一次又一次，每一次，都清醒的认识到果然没有人回应我，无论怎么呼唤，怎么祈祷，还是有无法实现的东西。 最后还是没能找到家，迷路了，累到了，然后，我决定不在呼唤无法给予我回应的东西。——《夏目友人帐》漫漫回家路]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库基础]]></title>
    <url>%2F2018%2F11%2F01%2FOracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Oracle简介1$ 众所周知，Oracle是个数据库，是Oracle公司的核心产品，优越的数据安全性和完整性，以及跨操作系统，跨硬件平台，主要特点：支持多用户，大事务的事务处理，在保持数据安全性和完整性方面性能优越，支持分布式事务处理，具有可移植性 Oracle基本概念$ 数据库：这不是我们平时所说的数据库，它是磁盘上存储数据的集合 $ 全局数据库名：用于区分一个数据库的标识，要唯一 $ 数据库实例：每个启动的数据库都对应一个数据库实例，有这个实例来访问数据库中的数据 $ 表空间：数据库若干个表空间组成，... $ 数据文件：数据文件扩展名.dbf 是来存储数据库数据的文件 $ 控制文件：控制文件扩展名.ctl 一个二进制文件,根据控制文件查找数据文件 $ 日志文件：日志文件扩展名.log,记录数据更改信息 Oracle重要的三个服务（建议全部设为手动，玩游戏的时候会卡的）$ OracleServiceSID：Oracle数据库服务，对应名为SID（系统标识符）我的是orcl $ OracleOraDb11g_home1TNSListener：监听器服务，如果要远程链接数据库服务器，就必须启动它 $ OracleDBConsoleSID：嗯，这个是控制台服务 SID（系统标识符） 连接Oracle数据库$ SQL*PLUS：system/orcl@orclDB //system是当前用户，orcl为密码，orclDB为使用的网络服务名 $ PL/SQL Developer：直接输入登录ok了 Oracle数据类型（列举几个比较难理解的）$ NUMBER(P,S)：p是精度，标识数字的有效位数，不包括小数点后，s标识小数点右边的位数，是四舍五入的哦 $ Date：SYSDATE标识返回当前的日期和时间，SYSTIMESTAMP返回当前的日期和时间和时区（精确到毫秒）可怕 $ LOB数据类型（大对象）：CLOB(字符clob，存储大量文字),BLOB(二进制lob，存储视频，图片这类)，BFILE(二进制文件，存储二进制文件)，NCLOB(存储大的nchar数据) Oracle中的伪列就像是一个表列，但是它并没有存储到表中，可以查询伪列，但是不能增删改 $ ROWID：每行都有一个行地址，ROWID就是返回该行地址 $ ROWNUM：返回一个数值代表行的次序，可以限制返回的行数（ROWNUM=1可以查到数据，ROWNUM=2就查不到，ROWNUM&gt;N也差不到，ROWNUM&lt;11查询10条记录） 查询数据不重复显示(DISTINCT)SELECT DISTINCT stuNmae from student 集合操作符UNION：返回连个查询选定的所有不重复行UNION ALL：符合两个查询锁定的所有行，包括重复的行INTERSECT：只返回两个查询都有的行MINUS：只返回第一个选定而未被第二个选定的行 连接操作符（||）将两个或多个字符串合并为一个字符串 SQL函数常用的转换函数 $ TO_CHAR 转字符串 （TO_CHAR(SYSDATE，‘YYYY 年fmMM月fmDD日 HH24:MI:SS’)） $ TO_DATE 转日期类型 $ TO_NUMBER 转数值类型 其他函数 $ NVL(EXP1,EXP2)：如果EXP1的值为null，返回EXP2,否则返回EXP1 $ NVL2(EXP1,EXP2,EXP3)：如果EXP1为null，返回EXP3,否则返回EXP2 $ DECODE(VALUE,IF1,THEN1,IF2,THEN2,ELSE)：VALUE值为IF1,则进入THEN1.. 分析函数马上11点了.. 我先走了，自行百度 今天我是听着THE NIGHT – Avicii完成的]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[试问老天，不抵抗是罪吗？]]></title>
    <url>%2F2018%2F11%2F01%2F%E8%AF%95%E9%97%AE%E8%80%81%E5%A4%A9%EF%BC%8C%E4%B8%8D%E6%8A%B5%E6%8A%97%E6%98%AF%E7%BD%AA%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[OK Start任由其他人攀爬丝也会断,那么 “试问老天,不抵抗是罪吗?”太宰治 《人间失格》1「释迦牟尼看到在地狱挣扎的大盗，他干尽了恶事，但他唯一做的好事就是放过了一只蜘蛛，佛祖考虑救他一命，就取下一缕蛛丝朝着地狱垂了下去大盗无意间看到了这根蜘蛛丝，他顺着爬了上去，却发现后面罪人们跟着一起，自私的叫他们滚开，结果蛛丝断了，他们又回到血色的地狱」]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现在是星期三22:10分]]></title>
    <url>%2F2018%2F10%2F31%2F%E7%8E%B0%E5%9C%A8%E6%98%AF%E6%98%9F%E6%9C%9F%E4%B8%8922-10%E5%88%86%2F</url>
    <content type="text"><![CDATA[OK Start今天也是幸福的一天，晚上吃了两个烤馍，一根烤面筋，一根烤肠1$ 还有一件事，评论发送邮件功能开启]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的一天]]></title>
    <url>%2F2018%2F10%2F30%2F%E6%96%B0%E7%9A%84%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"></content>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[在一个突如其来的下午，一个可怕的想法在我的脑中出现 ###它诞生了…]]></content>
  </entry>
</search>
