<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[人间失格]]></title>
    <url>%2F2018%2F11%2F07%2F%E4%BA%BA%E9%97%B4%E5%A4%B1%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[日日重复同样的事，遵循着昨日相同的惯例，若能避开猛烈的狂喜，自然也不会有悲痛的来袭 日日重复同样的事，遵循着与昨日相同的惯例，若能避开猛烈的狂喜 ，自然也不会有悲痛的来袭。相互欺骗，却又令人惊奇地不受到任何伤害，甚至于就好像没有察觉到彼此在欺骗似的，这种不加掩饰从而显得清冽、豁达的互不信任的例子，在人类生活中比比皆是。倒是那些彼此欺骗，却清冽而开朗地生存着，抑或是有信心清冽而开朗地生活下去的人，才是令人费解的。 世间。我开始隐隐约约明白了世间的真相，它就是个人与个人之间的争斗，而且是即时即地的斗争。人需要在那种争斗中当场取胜。人是绝不可能服从他人的。即使是当奴隶，也会以奴隶的方式进行卑屈的反击。]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整合]]></title>
    <url>%2F2018%2F11%2F06%2F%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[配置文件整合（CTRL C CTRL V）根据项目实际情况而定WEB.XML12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;display-name&gt;CG14&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContextl.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.util.Log4jConfigListener &lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; applicationContextl.XML1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd"&gt; &lt;context:component-scan base-package="cn.appsys.service"&gt;&lt;/context:component-scan&gt; &lt;context:component-scan base-package="cn.appsys.controller"&gt;&lt;/context:component-scan&gt; &lt;!-- 读取数据库配置文件 --&gt; &lt;context:property-placeholder location="classpath:database.properties"/&gt; &lt;!-- JNDI获取数据源(使用dbcp连接池) --&gt; &lt;bean class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" scope="singleton" id="dataSource"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;user&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"/&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"/&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"/&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"/&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"/&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;"/&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;"/&gt; &lt;!-- sql 心跳 --&gt; &lt;property name= "testWhileIdle" value="true"/&gt; &lt;property name= "testOnBorrow" value="false"/&gt; &lt;property name= "testOnReturn" value="false"/&gt; &lt;property name= "validationQuery" value="select 1"/&gt; &lt;property name= "timeBetweenEvictionRunsMillis" value="60000"/&gt; &lt;property name= "numTestsPerEvictionRun" value="$&#123;maxActive&#125;"/&gt; &lt;/bean&gt; &lt;!-- 数据源在配置文件中 --&gt; &lt;!-- &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- 使用jndi数据源 在tomcat content.xml配置 --&gt; &lt;!-- &lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt; &lt;property name="jndiName"&gt; &lt;value&gt;java:comp/env/jndi/smbms&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- 配置SqlSessionFactoryBean --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;property name="configLocation" value="classpath:mybatis-configl.xml"&gt;&lt;/property&gt; &lt;property name="mapperLocations"&gt; &lt;list&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Dao --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.appsys.dao.*"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务增强 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置切面 --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression="execution(* cn.appsys.service..*.*(..))" id="myPoint" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="myPoint" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; database.properties(mysql)1234567891011driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/appinfodb?useUnicode=true&amp;characterEncoding=utf-8user=rootpassword=rootminIdle=45maxIdle=50initialSize=5maxActive=100maxWait=100removeAbandonedTimeout=180removeAbandoned=true log4j.properties123456789101112131415161718192021222324252627282930313233343536log4j.rootLogger=DEBUG,CONSOLE,file#log4j.rootLogger=ERROR,ROLLING_FILElog4j.logger.cn.smbms.dao=debuglog4j.logger.com.ibatis=debug log4j.logger.com.ibatis.common.jdbc.SimpleDataSource=debug log4j.logger.com.ibatis.common.jdbc.ScriptRunner=debug log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=debug log4j.logger.java.sql.Connection=debug log4j.logger.java.sql.Statement=debug log4j.logger.java.sql.PreparedStatement=debug log4j.logger.java.sql.ResultSet=debug log4j.logger.org.tuckey.web.filters.urlrewrite.UrlRewriteFilter=debug####################################################################################### Console Appender \u65e5\u5fd7\u5728\u63a7\u5236\u8f93\u51fa\u914d\u7f6e######################################################################################log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppenderlog4j.appender.Threshold=errorlog4j.appender.CONSOLE.Target=System.outlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayoutlog4j.appender.CONSOLE.layout.ConversionPattern= [%p] %d %c - %m%n####################################################################################### DailyRolling File \u6bcf\u5929\u4ea7\u751f\u4e00\u4e2a\u65e5\u5fd7\u6587\u4ef6\uff0c\u6587\u4ef6\u540d\u683c\u5f0f:log2009-09-11######################################################################################log4j.appender.file=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.file.DatePattern=yyyy-MM-ddlog4j.appender.file.File=log.loglog4j.appender.file.Append=truelog4j.appender.file.Threshold=errorlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-M-d HH:mm:ss&#125;%x[%5p](%F:%L) %m%nlog4j.logger.com.opensymphony.xwork2=error mybatis-configl.XML123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 引入database.properties文件 --&gt; &lt;!-- 配置mybatis的log实现为LOG4J --&gt; &lt;settings&gt; &lt;!-- &lt;setting name="logImpl" value="LOG4J" /&gt; --&gt; &lt;setting name="lazyLoadingEnabled" value="false"/&gt; &lt;setting name="autoMappingBehavior" value="FULL"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name="cn.appsys.pojo"/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; springmvc-servlet.XML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 配置处理器映射 HandlerMapping --&gt; &lt;!-- &lt;bean name="/index.html" class="cn.smbms.controller.IndexController" /&gt; --&gt; &lt;!-- &lt;bean name="/welcome" class="cn.smbms.controller.IndexController" /&gt; --&gt; &lt;!-- &lt;bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;/bean&gt; --&gt; &lt;context:component-scan base-package="cn.appsys.controller"/&gt; &lt;!-- 自定义转换器 --&gt; &lt;!-- &lt;bean id="myConversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;bean class="cn.smbms.tools.StringToDateConverter"&gt; &lt;constructor-arg type="java.lang.String" value="yyyy-MM-dd" /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- 拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/sys/**"/&gt; &lt;bean class="cn.appsys.interceptor.SysInterceptor"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;mvc:annotation-driven&gt; &lt;!-- 消息转换器 --&gt; &lt;mvc:message-converters&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean class="com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="features"&gt; &lt;list&gt; &lt;value&gt;WriteDateUseDateFormat&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 完成视图的对应 --&gt; &lt;!-- 对转向页面的路径解析。prefix：前缀， suffix：后缀 --&gt; &lt;!-- &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; --&gt; &lt;!-- 配置多视图解析器 ：允许统一的内容数据呈现在不同的view中 --&gt; &lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt; &lt;!-- 支持参数匹配 --&gt; &lt;property name="favorParameter" value="true"/&gt; &lt;property name="mediaTypes"&gt; &lt;map&gt; &lt;entry key="html" value="text/html;charset=UTF-8"&gt;&lt;/entry&gt; &lt;entry key="json" value="application/json;charset=UTF-8"&gt;&lt;/entry&gt; &lt;entry key="xml" value="application/xml;charset=UTF-8"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 网页视图解析器 --&gt; &lt;property name="viewResolvers"&gt; &lt;list&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;mvc:resources location="/statics/" mapping="/statics/**"&gt;&lt;/mvc:resources&gt; &lt;!-- 全局异常的配置 --&gt; &lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt; &lt;property name="exceptionMappings"&gt; &lt;props&gt; &lt;prop key="java.lang.RuntimeException"&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置MulitpartResolver，用于文件上传 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="5000000" /&gt; &lt;property name="defaultEncoding" value="utf-8" /&gt; &lt;/bean&gt;&lt;/beans&gt; Logger(AOP)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package cn.appsys.tools;import java.util.Arrays;import org.apache.log4j.Logger;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;/** * 注解定义切面 * @author F117 * */@Aspectpublic class UserServiceLogger &#123; private static final Logger LOGGER=Logger.getLogger(UserServiceLogger.class); @Pointcut("execution(* cn.service..*.*(..)) ") public void pointcut()&#123;&#125; /** * 前置增强 * @param jp */ @Before("pointcut()") public void before(JoinPoint jp) &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法入参：" + Arrays.toString(jp.getArgs())); &#125; /** * 后置增强 * @param jp * @param returnValue */ @AfterReturning(pointcut = "pointcut()", returning = "returnValue") public void afterReturning(JoinPoint jp, Object returnValue) &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法返回值：" + returnValue); &#125; /** * 最终增强 * @param jp */ @After("pointcut()") public void afterLogger(JoinPoint jp) &#123; LOGGER.info(jp.getSignature().getName() + " 方法结束执行。"); &#125; /** * 异常增强 * @param jp * @param e */ @AfterThrowing(value="pointcut()", throwing = "e") public void afterThrowing(JoinPoint jp, RuntimeException e) &#123; LOGGER.error(jp.getSignature().getName() + " 方法发生异常：" + e); &#125; /** * 环绕增强 * @param jp * @return * @throws Throwable */ @Around("pointcut()") public Object aroundLogger(ProceedingJoinPoint jp) throws Throwable &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法入参：" + Arrays.toString(jp.getArgs())); try &#123; Object result = jp.proceed(); LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法返回值：" + result); return result; &#125; catch (Throwable e) &#123; LOGGER.error(jp.getSignature().getName() + " 方法发生异常：" + e); throw e; &#125; finally &#123; LOGGER.info(jp.getSignature().getName() + " 方法结束执行。"); &#125; &#125; &#125; Controller增删改查123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728package cn.appsys.controller.developer;import java.io.File;import java.util.Date;import java.util.HashMap;import java.util.List;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import org.apache.commons.io.FilenameUtils;import org.apache.log4j.Logger;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;import com.alibaba.fastjson.JSONArray;import com.mysql.jdbc.StringUtils;import cn.appsys.pojo.AppCategory;import cn.appsys.pojo.AppInfo;import cn.appsys.pojo.AppVersion;import cn.appsys.pojo.DataDictionary;import cn.appsys.pojo.DevUser;import cn.appsys.service.developer.AppCategoryService;import cn.appsys.service.developer.AppInfoService;import cn.appsys.service.developer.AppVersionService;import cn.appsys.service.developer.DataDictionaryService;import cn.appsys.tools.Constants;import cn.appsys.tools.PageSupport;@Controller@RequestMapping(value="/dev/flatform/app")public class AppController &#123; private Logger logger = Logger.getLogger(AppController.class); @Resource private AppInfoService appInfoService; @Resource private DataDictionaryService dataDictionaryService; @Resource private AppCategoryService appCategoryService; @Resource private AppVersionService appVersionService; @RequestMapping(value="/list") public String getAppInfoList(Model model,HttpSession session, @RequestParam(value="querySoftwareName",required=false) String querySoftwareName, @RequestParam(value="queryStatus",required=false) String _queryStatus, @RequestParam(value="queryCategoryLevel1",required=false) String _queryCategoryLevel1, @RequestParam(value="queryCategoryLevel2",required=false) String _queryCategoryLevel2, @RequestParam(value="queryCategoryLevel3",required=false) String _queryCategoryLevel3, @RequestParam(value="queryFlatformId",required=false) String _queryFlatformId, @RequestParam(value="pageIndex",required=false) String pageIndex)&#123; logger.info("getAppInfoList -- &gt; querySoftwareName: " + querySoftwareName); logger.info("getAppInfoList -- &gt; queryStatus: " + _queryStatus); logger.info("getAppInfoList -- &gt; queryCategoryLevel1: " + _queryCategoryLevel1); logger.info("getAppInfoList -- &gt; queryCategoryLevel2: " + _queryCategoryLevel2); logger.info("getAppInfoList -- &gt; queryCategoryLevel3: " + _queryCategoryLevel3); logger.info("getAppInfoList -- &gt; queryFlatformId: " + _queryFlatformId); logger.info("getAppInfoList -- &gt; pageIndex: " + pageIndex); Integer devId = ((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId(); List&lt;AppInfo&gt; appInfoList = null; List&lt;DataDictionary&gt; statusList = null; List&lt;DataDictionary&gt; flatFormList = null; List&lt;AppCategory&gt; categoryLevel1List = null;//列出一级分类列表，注：二级和三级分类列表通过异步ajax获取 List&lt;AppCategory&gt; categoryLevel2List = null; List&lt;AppCategory&gt; categoryLevel3List = null; //页面容量 int pageSize = Constants.pageSize; //当前页码 Integer currentPageNo = 1; if(pageIndex != null)&#123; try&#123; currentPageNo = Integer.valueOf(pageIndex); &#125;catch (NumberFormatException e) &#123; // TODO: handle exception e.printStackTrace(); &#125; &#125; Integer queryStatus = null; if(_queryStatus != null &amp;&amp; !_queryStatus.equals(""))&#123; queryStatus = Integer.parseInt(_queryStatus); &#125; Integer queryCategoryLevel1 = null; if(_queryCategoryLevel1 != null &amp;&amp; !_queryCategoryLevel1.equals(""))&#123; queryCategoryLevel1 = Integer.parseInt(_queryCategoryLevel1); &#125; Integer queryCategoryLevel2 = null; if(_queryCategoryLevel2 != null &amp;&amp; !_queryCategoryLevel2.equals(""))&#123; queryCategoryLevel2 = Integer.parseInt(_queryCategoryLevel2); &#125; Integer queryCategoryLevel3 = null; if(_queryCategoryLevel3 != null &amp;&amp; !_queryCategoryLevel3.equals(""))&#123; queryCategoryLevel3 = Integer.parseInt(_queryCategoryLevel3); &#125; Integer queryFlatformId = null; if(_queryFlatformId != null &amp;&amp; !_queryFlatformId.equals(""))&#123; queryFlatformId = Integer.parseInt(_queryFlatformId); &#125; //总数量（表） int totalCount = 0; try &#123; totalCount = appInfoService.getAppInfoCount(querySoftwareName, queryStatus, queryCategoryLevel1, queryCategoryLevel2, queryCategoryLevel3, queryFlatformId, devId); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //总页数 PageSupport pages = new PageSupport(); pages.setCurrentPageNo(currentPageNo); pages.setPageSize(pageSize); pages.setTotalCount(totalCount); int totalPageCount = pages.getTotalPageCount(); //控制首页和尾页 if(currentPageNo &lt; 1)&#123; currentPageNo = 1; &#125;else if(currentPageNo &gt; totalPageCount)&#123; currentPageNo = totalPageCount; &#125; try &#123; appInfoList = appInfoService.getAppInfoList(querySoftwareName, queryStatus, queryCategoryLevel1, queryCategoryLevel2, queryCategoryLevel3, queryFlatformId, devId, currentPageNo, pageSize); statusList = this.getDataDictionaryList("APP_STATUS"); flatFormList = this.getDataDictionaryList("APP_FLATFORM"); categoryLevel1List = appCategoryService.getAppCategoryListByParentId(null); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; model.addAttribute("appInfoList", appInfoList); model.addAttribute("statusList", statusList); model.addAttribute("flatFormList", flatFormList); model.addAttribute("categoryLevel1List", categoryLevel1List); model.addAttribute("pages", pages); model.addAttribute("queryStatus", queryStatus); model.addAttribute("querySoftwareName", querySoftwareName); model.addAttribute("queryCategoryLevel1", queryCategoryLevel1); model.addAttribute("queryCategoryLevel2", queryCategoryLevel2); model.addAttribute("queryCategoryLevel3", queryCategoryLevel3); model.addAttribute("queryFlatformId", queryFlatformId); //二级分类列表和三级分类列表---回显 if(queryCategoryLevel2 != null &amp;&amp; !queryCategoryLevel2.equals(""))&#123; categoryLevel2List = getCategoryList(queryCategoryLevel1.toString()); model.addAttribute("categoryLevel2List", categoryLevel2List); &#125; if(queryCategoryLevel3 != null &amp;&amp; !queryCategoryLevel3.equals(""))&#123; categoryLevel3List = getCategoryList(queryCategoryLevel2.toString()); model.addAttribute("categoryLevel3List", categoryLevel3List); &#125; return "developer/appinfolist"; &#125; public List&lt;DataDictionary&gt; getDataDictionaryList(String typeCode)&#123; List&lt;DataDictionary&gt; dataDictionaryList = null; try &#123; dataDictionaryList = dataDictionaryService.getDataDictionaryList(typeCode); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return dataDictionaryList; &#125; /** * 根据typeCode查询出相应的数据字典列表 * @param pid * @return */ @RequestMapping(value="/datadictionarylist.json",method=RequestMethod.GET) @ResponseBody public List&lt;DataDictionary&gt; getDataDicList (@RequestParam String tcode)&#123; logger.debug("getDataDicList tcode ============ " + tcode); return this.getDataDictionaryList(tcode); &#125; /** * 根据parentId查询出相应的分类级别列表 * @param pid * @return */ @RequestMapping(value="/categorylevellist.json",method=RequestMethod.GET) @ResponseBody public List&lt;AppCategory&gt; getAppCategoryList (@RequestParam String pid)&#123; logger.debug("getAppCategoryList pid ============ " + pid); if(pid.equals("")) pid = null; return getCategoryList(pid); &#125; public List&lt;AppCategory&gt; getCategoryList (String pid)&#123; List&lt;AppCategory&gt; categoryLevelList = null; try &#123; categoryLevelList = appCategoryService.getAppCategoryListByParentId(pid==null?null:Integer.parseInt(pid)); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return categoryLevelList; &#125; //跳转到新增appinfo页面 @RequestMapping(value="/appinfoadd",method=RequestMethod.GET) public String add(@ModelAttribute("appInfo") AppInfo appInfo)&#123; return "developer/appinfoadd"; &#125; //保存appinfo数据 @RequestMapping(value="/appinfoaddsave",method=RequestMethod.POST) public String addSave(AppInfo appInfo,HttpSession session,HttpServletRequest request, @RequestParam(value="a_logoPicPath",required= false) MultipartFile attach)&#123; String logoPicPath = null; String logoLocPath = null; if(!attach.isEmpty())&#123; String path = request.getSession().getServletContext().getRealPath("statics"+java.io.File.separator+"uploadfiles"); logger.info("uploadFile path: " + path); String oldFileName = attach.getOriginalFilename();//原文件名 String prefix = FilenameUtils.getExtension(oldFileName);//原文件后缀 int filesize = 500000; if(attach.getSize() &gt; filesize)&#123;//上传大小不得超过 50k request.setAttribute("fileUploadError", Constants.FILEUPLOAD_ERROR_4); return "developer/appinfoadd"; &#125;else if(prefix.equalsIgnoreCase("jpg") || prefix.equalsIgnoreCase("png") ||prefix.equalsIgnoreCase("jepg") || prefix.equalsIgnoreCase("pneg"))&#123;//上传图片格式 String fileName = appInfo.getAPKName() + ".jpg";//上传LOGO图片命名:apk名称.apk File targetFile = new File(path,fileName); if(!targetFile.exists())&#123; targetFile.mkdirs(); &#125; try &#123; attach.transferTo(targetFile); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); request.setAttribute("fileUploadError", Constants.FILEUPLOAD_ERROR_2); return "developer/appinfoadd"; &#125; logoPicPath = request.getContextPath()+"/statics/uploadfiles/"+fileName; //绝对路径 logoLocPath = path+File.separator+fileName; //相对路径 &#125;else&#123; request.setAttribute("fileUploadError", Constants.FILEUPLOAD_ERROR_3); return "developer/appinfoadd"; &#125; &#125; appInfo.setCreatedBy(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appInfo.setCreationDate(new Date()); appInfo.setLogoPicPath(logoPicPath); appInfo.setLogoLocPath(logoLocPath); appInfo.setDevId(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appInfo.setStatus(1); try &#123; if(appInfoService.add(appInfo))&#123; return "redirect:/dev/flatform/app/list"; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return "developer/appinfoadd"; &#125; /** * 增加appversion信息（跳转到新增app版本页面） * @param appInfo * @return */ @RequestMapping(value="/appversionadd",method=RequestMethod.GET) public String addVersion(@RequestParam(value="id")String appId, @RequestParam(value="error",required= false)String fileUploadError, AppVersion appVersion,Model model)&#123; logger.debug("fileUploadError============&gt; " + fileUploadError); if(null != fileUploadError &amp;&amp; fileUploadError.equals("error1"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_1; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error2"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_2; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error3"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_3; &#125; appVersion.setAppId(Integer.parseInt(appId)); List&lt;AppVersion&gt; appVersionList = null; try &#123; appVersionList = appVersionService.getAppVersionList(Integer.parseInt(appId)); appVersion.setAppName((appInfoService.getAppInfo(Integer.parseInt(appId),null)).getSoftwareName()); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; model.addAttribute("appVersionList", appVersionList); model.addAttribute(appVersion); model.addAttribute("fileUploadError",fileUploadError); return "developer/appversionadd"; &#125; /** * 保存新增appversion数据（子表）-上传该版本的apk包 * @param appInfo * @param appVersion * @param session * @param request * @param attach * @return */ @RequestMapping(value="/addversionsave",method=RequestMethod.POST) public String addVersionSave(AppVersion appVersion,HttpSession session,HttpServletRequest request, @RequestParam(value="a_downloadLink",required= false) MultipartFile attach )&#123; String downloadLink = null; String apkLocPath = null; String apkFileName = null; if(!attach.isEmpty())&#123; String path = request.getSession().getServletContext().getRealPath("statics"+File.separator+"uploadfiles"); logger.info("uploadFile path: " + path); String oldFileName = attach.getOriginalFilename();//原文件名 String prefix = FilenameUtils.getExtension(oldFileName);//原文件后缀 if(prefix.equalsIgnoreCase("apk"))&#123;//apk文件命名：apk名称+版本号+.apk String apkName = null; try &#123; apkName = appInfoService.getAppInfo(appVersion.getAppId(),null).getAPKName(); &#125; catch (Exception e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; if(apkName == null || "".equals(apkName))&#123; return "redirect:/dev/flatform/app/appversionadd?id="+appVersion.getAppId() +"&amp;error=error1"; &#125; apkFileName = apkName + "-" +appVersion.getVersionNo() + ".apk"; File targetFile = new File(path,apkFileName); if(!targetFile.exists())&#123; targetFile.mkdirs(); &#125; try &#123; attach.transferTo(targetFile); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return "redirect:/dev/flatform/app/appversionadd?id="+appVersion.getAppId() +"&amp;error=error2"; &#125; downloadLink = request.getContextPath()+"/statics/uploadfiles/"+apkFileName; apkLocPath = path+File.separator+apkFileName; &#125;else&#123; return "redirect:/dev/flatform/app/appversionadd?id="+appVersion.getAppId() +"&amp;error=error3"; &#125; &#125; appVersion.setCreatedBy(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appVersion.setCreationDate(new Date()); appVersion.setDownloadLink(downloadLink); appVersion.setApkLocPath(apkLocPath); appVersion.setApkFileName(apkFileName); try &#123; if(appVersionService.appsysadd(appVersion))&#123; return "redirect:/dev/flatform/app/list"; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return "redirect:/dev/flatform/app/appversionadd?id="+appVersion.getAppId(); &#125; @RequestMapping(value="/&#123;appid&#125;/sale",method=RequestMethod.PUT) @ResponseBody public Object sale(@PathVariable String appid,HttpSession session)&#123; HashMap&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); Integer appIdInteger = 0; try&#123; appIdInteger = Integer.parseInt(appid); &#125;catch(Exception e)&#123; appIdInteger = 0; &#125; resultMap.put("errorCode", "0"); resultMap.put("appId", appid); if(appIdInteger&gt;0)&#123; try &#123; DevUser devUser = (DevUser)session.getAttribute(Constants.DEV_USER_SESSION); AppInfo appInfo = new AppInfo(); appInfo.setId(appIdInteger); appInfo.setModifyBy(devUser.getId()); if(appInfoService.appsysUpdateSaleStatusByAppId(appInfo))&#123; resultMap.put("resultMsg", "success"); &#125;else&#123; resultMap.put("resultMsg", "success"); &#125; &#125; catch (Exception e) &#123; resultMap.put("errorCode", "exception000001"); &#125; &#125;else&#123; //errorCode:0为正常 resultMap.put("errorCode", "param000001"); &#125; /* * resultMsg:success/failed * errorCode:exception000001 * appId:appId * errorCode:param000001 */ return resultMap; &#125; /** * 判断APKName是否唯一 * @param apkName * @return */ @RequestMapping(value="/apkexist.json",method=RequestMethod.GET) @ResponseBody public Object apkNameIsExit(@RequestParam String APKName)&#123; HashMap&lt;String, String&gt; resultMap = new HashMap&lt;String, String&gt;(); if(StringUtils.isNullOrEmpty(APKName))&#123; resultMap.put("APKName", "empty"); &#125;else&#123; AppInfo appInfo = null; try &#123; appInfo = appInfoService.getAppInfo(null, APKName); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if(null != appInfo) resultMap.put("APKName", "exist"); else resultMap.put("APKName", "noexist"); &#125; return JSONArray.toJSONString(resultMap); &#125; /** * 查看app信息，包括app基本信息和版本信息列表（跳转到查看页面） * @param appInfo * @return */ @RequestMapping(value="/appview/&#123;id&#125;",method=RequestMethod.GET) public String view(@PathVariable String id,Model model)&#123; AppInfo appInfo = null; List&lt;AppVersion&gt; appVersionList = null; try &#123; appInfo = appInfoService.getAppInfo(Integer.parseInt(id),null); appVersionList = appVersionService.getAppVersionList(Integer.parseInt(id)); &#125;catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; model.addAttribute("appVersionList", appVersionList); model.addAttribute(appInfo); return "developer/appinfoview"; &#125; /** * 修改app信息，包括：修改app基本信息（appInfo）和修改版本信息（appVersion） * 分为两步实现： * 1 修改app基本信息（appInfo） * 2 修改版本信息（appVersion） */ /** * 修改appInfo信息（跳转到修改appInfo页面） * @param id * @param model * @return */ @RequestMapping(value="/appinfomodify",method=RequestMethod.GET) public String modifyAppInfo(@RequestParam("id") String id, @RequestParam(value="error",required= false)String fileUploadError, Model model)&#123; AppInfo appInfo = null; logger.debug("modifyAppInfo --------- id: " + id); if(null != fileUploadError &amp;&amp; fileUploadError.equals("error1"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_1; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error2"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_2; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error3"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_3; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error4"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_4; &#125; try &#123; appInfo = appInfoService.getAppInfo(Integer.parseInt(id),null); &#125;catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; model.addAttribute(appInfo); model.addAttribute("fileUploadError",fileUploadError); return "developer/appinfomodify"; &#125; /** * 修改最新的appVersion信息（跳转到修改appVersion页面） * @param versionId * @param appId * @param model * @return */ @RequestMapping(value="/appversionmodify",method=RequestMethod.GET) public String modifyAppVersion(@RequestParam("vid") String versionId, @RequestParam("aid") String appId, @RequestParam(value="error",required= false)String fileUploadError, Model model)&#123; AppVersion appVersion = null; List&lt;AppVersion&gt; appVersionList = null; if(null != fileUploadError &amp;&amp; fileUploadError.equals("error1"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_1; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error2"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_2; &#125;else if(null != fileUploadError &amp;&amp; fileUploadError.equals("error3"))&#123; fileUploadError = Constants.FILEUPLOAD_ERROR_3; &#125; try &#123; appVersion = appVersionService.getAppVersionById(Integer.parseInt(versionId)); appVersionList = appVersionService.getAppVersionList(Integer.parseInt(appId)); &#125;catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; model.addAttribute(appVersion); model.addAttribute("appVersionList",appVersionList); model.addAttribute("fileUploadError",fileUploadError); return "developer/appversionmodify"; &#125; /** * 保存修改后的appVersion * @param appVersion * @param session * @return */ @RequestMapping(value="/appversionmodifysave",method=RequestMethod.POST) public String modifyAppVersionSave(AppVersion appVersion,HttpSession session,HttpServletRequest request, @RequestParam(value="attach",required= false) MultipartFile attach)&#123; String downloadLink = null; String apkLocPath = null; String apkFileName = null; if(!attach.isEmpty())&#123; String path = request.getSession().getServletContext().getRealPath("statics"+File.separator+"uploadfiles"); logger.info("uploadFile path: " + path); String oldFileName = attach.getOriginalFilename();//原文件名 String prefix = FilenameUtils.getExtension(oldFileName);//原文件后缀 if(prefix.equalsIgnoreCase("apk"))&#123;//apk文件命名：apk名称+版本号+.apk String apkName = null; try &#123; apkName = appInfoService.getAppInfo(appVersion.getAppId(),null).getAPKName(); &#125; catch (Exception e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; if(apkName == null || "".equals(apkName))&#123; return "redirect:/dev/flatform/app/appversionmodify?vid="+appVersion.getId() +"&amp;aid="+appVersion.getAppId() +"&amp;error=error1"; &#125; apkFileName = apkName + "-" +appVersion.getVersionNo() + ".apk"; File targetFile = new File(path,apkFileName); if(!targetFile.exists())&#123; targetFile.mkdirs(); &#125; try &#123; attach.transferTo(targetFile); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return "redirect:/dev/flatform/app/appversionmodify?vid="+appVersion.getId() +"&amp;aid="+appVersion.getAppId() +"&amp;error=error2"; &#125; downloadLink = request.getContextPath()+"/statics/uploadfiles/"+apkFileName; apkLocPath = path+File.separator+apkFileName; &#125;else&#123; return "redirect:/dev/flatform/app/appversionmodify?vid="+appVersion.getId() +"&amp;aid="+appVersion.getAppId() +"&amp;error=error3"; &#125; &#125; appVersion.setModifyBy(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appVersion.setModifyDate(new Date()); appVersion.setDownloadLink(downloadLink); appVersion.setApkLocPath(apkLocPath); appVersion.setApkFileName(apkFileName); try &#123; if(appVersionService.modify(appVersion))&#123; return "redirect:/dev/flatform/app/list"; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return "developer/appversionmodify"; &#125; /** * 修改操作时，删除文件（logo图片/apk文件），并更新数据库（app_info/app_version） * @param fileUrlPath * @param fileLocPath * @param flag * @param id * @return */ @RequestMapping(value = "/delfile",method=RequestMethod.GET) @ResponseBody public Object delFile(@RequestParam(value="flag",required=false) String flag, @RequestParam(value="id",required=false) String id)&#123; HashMap&lt;String, String&gt; resultMap = new HashMap&lt;String, String&gt;(); String fileLocPath = null; if(flag == null || flag.equals("") || id == null || id.equals(""))&#123; resultMap.put("result", "failed"); &#125;else if(flag.equals("logo"))&#123;//删除logo图片（操作app_info） try &#123; fileLocPath = (appInfoService.getAppInfo(Integer.parseInt(id), null)).getLogoLocPath(); File file = new File(fileLocPath); if(file.exists()) if(file.delete())&#123;//删除服务器存储的物理文件 if(appInfoService.deleteAppLogo(Integer.parseInt(id)))&#123;//更新表 resultMap.put("result", "success"); &#125; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;else if(flag.equals("apk"))&#123;//删除apk文件（操作app_version） try &#123; fileLocPath = (appVersionService.getAppVersionById(Integer.parseInt(id))).getApkLocPath(); File file = new File(fileLocPath); if(file.exists()) if(file.delete())&#123;//删除服务器存储的物理文件 if(appVersionService.deleteApkFile(Integer.parseInt(id)))&#123;//更新表 resultMap.put("result", "success"); &#125; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return JSONArray.toJSONString(resultMap); &#125; /** * 保存修改后的appInfo * @param appInfo * @param session * @return */ @RequestMapping(value="/appinfomodifysave",method=RequestMethod.POST) public String modifySave(AppInfo appInfo,HttpSession session,HttpServletRequest request, @RequestParam(value="attach",required= false) MultipartFile attach)&#123; String logoPicPath = null; String logoLocPath = null; String APKName = appInfo.getAPKName(); if(!attach.isEmpty())&#123; String path = request.getSession().getServletContext().getRealPath("statics"+File.separator+"uploadfiles"); logger.info("uploadFile path: " + path); String oldFileName = attach.getOriginalFilename();//原文件名 String prefix = FilenameUtils.getExtension(oldFileName);//原文件后缀 int filesize = 500000; if(attach.getSize() &gt; filesize)&#123;//上传大小不得超过 50k return "redirect:/dev/flatform/app/appinfomodify?id="+appInfo.getId() +"&amp;error=error4"; &#125;else if(prefix.equalsIgnoreCase("jpg") || prefix.equalsIgnoreCase("png") ||prefix.equalsIgnoreCase("jepg") || prefix.equalsIgnoreCase("pneg"))&#123;//上传图片格式 String fileName = APKName + ".jpg";//上传LOGO图片命名:apk名称.apk File targetFile = new File(path,fileName); if(!targetFile.exists())&#123; targetFile.mkdirs(); &#125; try &#123; attach.transferTo(targetFile); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return "redirect:/dev/flatform/app/appinfomodify?id="+appInfo.getId() +"&amp;error=error2"; &#125; logoPicPath = request.getContextPath()+"/statics/uploadfiles/"+fileName; logoLocPath = path+File.separator+fileName; &#125;else&#123; return "redirect:/dev/flatform/app/appinfomodify?id="+appInfo.getId() +"&amp;error=error3"; &#125; &#125; appInfo.setModifyBy(((DevUser)session.getAttribute(Constants.DEV_USER_SESSION)).getId()); appInfo.setModifyDate(new Date()); appInfo.setLogoLocPath(logoLocPath); appInfo.setLogoPicPath(logoPicPath); try &#123; if(appInfoService.modify(appInfo))&#123; return "redirect:/dev/flatform/app/list"; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return "developer/appinfomodify"; &#125; @RequestMapping(value="/delapp.json") @ResponseBody public Object delApp(@RequestParam String id)&#123; logger.debug("delApp appId===================== "+id); HashMap&lt;String, String&gt; resultMap = new HashMap&lt;String, String&gt;(); if(StringUtils.isNullOrEmpty(id))&#123; resultMap.put("delResult", "notexist"); &#125;else&#123; try &#123; if(appInfoService.appsysdeleteAppById(Integer.parseInt(id))) resultMap.put("delResult", "true"); else resultMap.put("delResult", "false"); &#125; catch (NumberFormatException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; return JSONArray.toJSONString(resultMap); &#125;&#125;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MVC体系结构和处理请求控制器]]></title>
    <url>%2F2018%2F11%2F06%2FMVC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%8E%A7%E5%88%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[环境搭建jar包123456789101112aopalliance-1.0.jaraspectjweaver-1.6.9.jarcommons-logging-1.1.1.jarlog4j-1.2.16.jarlog4j-1.2.17.jarspring-aop-3.2.13.RELEASE.jarspring-beans-3.2.13.RELEASE.jarspring-context-3.2.13.RELEASE.jarspring-core-3.2.13.RELEASE.jarspring-expression-3.2.13.RELEASE.jarspring-web-3.2.13.RELEASE.jarspring-webmvc-3.2.13.RELEASE.jar 在web.xml中配置servlet1234567891011121314151617&lt;!-- 核心控制器的配置 DispatchServlet --&gt;&lt;servlet&gt;&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!-- 初始化参数 --&gt;&lt;init-param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;&lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;&lt;/init-param&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 创建Spring MVC的配置文件springmvc-servlet.xml1234567891011121314151617181920212223&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context"xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;&lt;!-- 配置处理器映射 HandlerMapping --&gt;&lt;!-- &lt;bean name="/index.html" class="cn.smbms.controller.IndexController" /&gt; --&gt;&lt;!-- &lt;bean name="/welcome" class="cn.smbms.controller.IndexController" /&gt; --&gt;&lt;mvc:annotation-driven/&gt;&lt;context:component-scan base-package="cn.smbms.controller"/&gt;&lt;!-- 完成视图的对应 --&gt;&lt;!-- 对转向页面的路径解析。prefix：前缀， suffix：后缀 --&gt;&lt;beanclass="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;&lt;property name="prefix" value="/WEB-INF/jsp/" /&gt;&lt;property name="suffix" value=".jsp" /&gt;&lt;/bean&gt;&lt;/beans&gt; 创建Controller12345678910111213@Controllerpublic class IndexController（）&#123;@RequestMapping(&#123;"/index","/you"&#125;)public ModelAndView index()&#123;System.out.println("hello 宇智波鼬");return new ModelAndView("index");&#125;@RequestMapping("/test.html")public String test(String userCode,Model model)&#123;model.addAttribute("userCode", userCode);return "success";&#125;&#125; 参数传递12345678910111213141516171819202122//params和@RequestParam的参数要一致@RequestMapping(value="/welcome",method=RequestMethod.GET)public String welcome(@RequestParam(value="username",required=false) String username)&#123;logger.info("welcome" +username);return "index";&#125;required=false //属性不必须@RequestMapping("/index2")public String index2(@RequestParam String username,Model model)&#123;model.addAttribute("username", username);//可以直接传对象model.addAttribute(username);User user=new User();user.setUserName(username);model.addAttribute("users", user);return "index";&#125;@RequestMapping("/index3")public String index3(@RequestParam String username,Map&lt;String, Object&gt; model)&#123;model.put("username", username);return "index";&#125;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring配置补充]]></title>
    <url>%2F2018%2F11%2F06%2FSpring%E9%85%8D%E7%BD%AE%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[灵活配置DataSource使用属性文件配置数据源123456789101112&lt;!-- 使用数据配置文件设置数据源 --&gt;&lt;beanclass="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;&lt;property name="location"&gt;&lt;value&gt;classpath:database.properties&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 数据源在配置文件中 --&gt;&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;&lt;property name="driverClassName" value="$&#123;driver&#125;"&gt;&lt;/property&gt; &lt;propertyname="url" value="$&#123;url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;user&#125;"&gt;&lt;/property&gt;&lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; 使用jndi数据源 Context节点下12345678910&lt;!-- 使用jndi数据源 在tomcat content.xml配置 --&gt;&lt;Resource name="jndi/smbms" auth="Container" type="javax.sql.DataSource"maxActive="100" maxIdle="30" driverClassName="com.mysql.jdbc.Driver"username="root" password="123456"url="jdbc:mysql://localhost:3306/smbms?useUnicode=true&amp;characterEncoding=utf-8" /&gt;&lt;!-- &lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;&lt;property name="jndiName"&gt;&lt;value&gt;java:comp/env/jndi/smbms&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt; --&gt; Spring中bean的作用域（scope属性）singleton 默认值：单利模式创建bean的实例，实例只有一个 安全差prototype 每次从容器中获取bean时，都会创建一个新的beanrequest web环境 针对每次请求都会创建一个新的beansession web环境 同一个会话共享一个，不同会话使用不同的实例使用注解指定作用域@Scope（””）@Service() Spring自动装配12345autowire属性：no：不使用自动装配，bean依赖关系必须通过property定义bytype：根据属性类型进行装配，寻找容器中的全部bean，找出属性类型相同的bean，如果有多个抛出异常byName：根据属性名进行装配，找出id与属性的setter方法匹配的beanconstructor：与bytype相似，但是用于构造器参数 拆分Spring配置文件12345ApplicationContext ctx=new ClassPathXmlApplicationContext("applicationContextl.xmlapplicationContextl-dao.xmlapplicationContextl-service.xml");使用import导入主配置文件&lt;import resource=""/&gt;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis与Spring的整合]]></title>
    <url>%2F2018%2F11%2F06%2FMybatis%E4%B8%8ESpring%E7%9A%84%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[配置环境添加jar包1234567891011121314151617181920aopalliance-1.0.jaraspectjweaver-1.6.9.jaraspectjweaver.jarcommons-dbcp-1.4.jarcommons-logging-1.2.jarcommons-pool-1.6.jarlog4j-1.2.16.jarlog4j-1.2.17.jarmybatis-3.2.2-sources.jarmybatis-3.2.2.jarmybatis-spring-1.2.0.jarmybatis-spring-1.3.2.jarmysql-connector-java-5.1.0-bin.jarspring-aop-3.2.13.RELEASE.jarspring-beans-3.2.13.RELEASE.jarspring-context-3.2.13.RELEASE.jarspring-core-3.2.13.RELEASE.jarspring-expression-3.2.13.RELEASE.jarspring-jdbc-3.2.13.RELEASE.jarspring-tx-3.2.13.RELEASE.jar 创建数据访问接口（mapper）结尾，实体类，配置MyBatis配置文件配置数据源关键12commons-dbcp-1.4.jarcommons-pool-1.6.jar 在applicationContextl.xml中配置、12345678&lt;!-- 数据源 --&gt;&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;&lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;&lt;property name="url"value="jdbc:mysql://localhost:3306/smbms?useUnicode=true&amp;amp;characterEncoding=utf-8"&gt;&lt;/property&gt;&lt;property name="username" value="root"&gt;&lt;/property&gt;&lt;property name="password" value="123456"&gt;&lt;/property&gt;&lt;/bean&gt; &amp;符号加&amp; 配置SqlSessionFactoryBean获取sqlSessionFactory实例 123456789101112&lt;!-- 配置SqlSessionFactoryBean --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;!-- 引用Mybatis文件中的数据--&gt;&lt;property name="configLocation" value="classpath:mybatis-configl.xml"&gt;&lt;/property&gt;&lt;property name="mapperLocations"&gt;&lt;list&gt;&lt;value&gt;classpath:cn/dao/UserMapper.xml&lt;/value&gt;&lt;value&gt;classpath:cn/dao/ProviderMapper.xml&lt;/value&gt;&lt;/list&gt;&lt;/property&gt;&lt;/bean&gt; 使用SqlSessionTemplate实现数据库操作 配置SqlSessionTemplate在实现类中的代码12345private SqlSessionTemplate sqlSession; getter 和 setter方法@Overridepublic int add(User user) &#123;return sqlSession.getMapper(UserMapper.class).add(user);&#125; Spring配置文件创建SqlSessionTemplate1234&lt;!-- 配置SqlSessionTemplate --&gt;&lt;!-- &lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate"&gt;&lt;constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; --&gt; 实现类继承SqlSessionDaoSupport简化SqlSessionTemplate的配置与获取1return this.getSession().getMapper(UserMapper.class).add(user); Spring配置文件:：12&lt;!-- &lt;bean id="userMapper" class="cn.dao.UserMapperImpl"&gt;&lt;propertyname="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; 注入映射器实现 MapperFactoryBean注入映射器1234&lt;!-- Dao --&gt;&lt;!-- &lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt;&lt;property name="mapperInterface" value="cn.dao.UserMapper"&gt;&lt;/property&gt; &lt;propertyname="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; 无需手工定义实现类，配置MapperFactoryBean可以自动生成使用MapperScannerConfigurer注入映射器可以扫描指定包中的接口并将他们直接定义为MapperFactoryBean1234&lt;!-- 配置Dao --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;&lt;property name="basePackage" value="cn.dao"&gt;&lt;/property&gt;&lt;/bean&gt; 配置声明式事务添加头文件tx和aop12345678910111213141516&lt;!-- 事务管理器 --&gt;&lt;bean id="txManager"class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事务增强 --&gt;&lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;&lt;tx:attributes&gt;&lt;tx:method name="*" propagation="REQUIRED" /&gt;&lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置切面 --&gt;&lt;aop:config&gt;&lt;aop:pointcut expression="execution(* cn.service..*.*(..))" id="myPoint"/&gt;&lt;aop:advisor advice-ref="txAdvice" pointcut-ref="myPoint"/&gt;&lt;/aop:config&gt; 使用注解实现声明式事务处理123456&lt;!-- 事务管理器 --&gt;&lt;bean id="txManager"class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;context:component-scan base-package="cn.service"&gt;&lt;/context:component-scan&gt; 1234@Transactional 全局class@Transactional (propagation=Propagation.SUPPORTS)public int add()&#123;....&#125;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IOC和AOP的使用扩展]]></title>
    <url>%2F2018%2F11%2F06%2FIOC%E5%92%8CAOP%E7%9A%84%E4%BD%BF%E7%94%A8%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[多种方式实现依赖注入通过构造有参函数12345&lt;bean id="userService" class="cn.service.impl.UserServiceimpl"&gt;&lt;constructor-arg ref="userdao" index="0"/&gt;&lt;constructor-arg index="1" value="宇智波鼬" /&gt;&lt;constructor-arg index="2" value="只要是人都是依靠自己的知识与认知并且被之束缚生活着的，那就叫做现实。但是知识与认知是模糊不清的东西，现实也许只是镜中花水中月，人都是活在自己的执念中的，你不这么认为吗"/&gt;&lt;/bean&gt; index代表参数位置，从0开始简单类型为value，引用类型为ref 通过p命名空间(通过seter方法)1&lt;bean id="users" class="cn.entity.User" p:name="宇智波鼬u" p:email="302645509@qq.com" p:dress="永济市" p:mess="无论你变成什么样,我都会永远爱着你"/&gt; 设置变量值：p：属性值=“”，设置引用变量：p：属性名-ref=“”； 注入集合类型list 允许重复(通过seter方法)12345&lt;bean id="play" class="naruto.entity.Player"&gt;&lt;property name="armet" ref="tou"&gt;&lt;list&gt;&lt;value&gt;&lt;/value&gt;&lt;ref&gt;&lt;/ref&gt;&lt;/list&gt;&lt;property&gt;&lt;/bean&gt; set 连线一组值，但不能重复12345&lt;bean id="play" class="naruto.entity.Player"&gt;&lt;property name="armet" ref="tou"&gt;&lt;set&gt;&lt;value&gt;&lt;/value&gt;&lt;ref&gt;&lt;/ref&gt;&lt;/set&gt;&lt;property&gt;&lt;/bean&gt; map 名称-值对的集合，其中名称和值可以是任何类型12345&lt;bean id="play" class="naruto.entity.Player"&gt;&lt;property name="armet" ref="tou"&gt;&lt;map&gt;&lt;entry&gt;&lt;key&gt;&lt;value&gt;&lt;/value&gt;&lt;/key&gt;&lt;value&gt;&lt;/value&gt;&lt;/entry&gt;&lt;/map&gt;&lt;property&gt;&lt;/bean&gt; 注入null和空123456&lt;property name="armet" ref="tou"&gt;&lt;value&gt;&lt;/value&gt;&lt;property&gt;&lt;property name="armet" ref="tou"&gt;&lt;null/&gt;&lt;property&gt; 使用注解实现bean组建装配1234@Component(“userDao”) == &lt;bean id="userDao" class="cn...l"&gt;@Repository //标识dao类@Service //标识业务类@Controller //标识控制器类 使用@Autowired实现bean的装配12345@Autowired private SpellChecker spellChecker; //可以省略相关的setter（）方法采用按照类型匹配的方式自动装配合适的依赖对象如有一个以上的类型相匹配的bean时，使用@Qualifier指定所需bean的名称@Autowired @Qualifier("student1") private Student student; 加载注解定义的bean在配置文件中添加对context的命名空间的声明1&lt;context:annotation-config/&gt; @Autowired 对方法的参数进行标注1@Autowired public void setDao(@Qualifier("userDao") User dao) setter()和构造方法 使用Java标准注解进行装配123@Resource@Resource private SpellChecker spellChecker;如果没有显示的指定bean名称，会根据字段名或时setter产生的名称 使用注解实现aop声明一个 aspect Aspects 类和其他任何正常的 bean 一样，除了它们将会用 @AspectJ 注释之外，它和其他类一样可能有方法和字段123@Aspect public class AspectModule &#123; &#125;声明一个切入点@Pointcut("execution(* com.xyz.myapp.service.*.*(..))") // expression private void businessService() &#123;&#125; 声明12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Aspectpublic class UserServiceLogger &#123; private static final Logger LOGGER=Logger.getLogger(UserServiceLogger.class); @Pointcut("execution(* cn.service..*.*(..)) ") public void pointcut()&#123;&#125; /** * 前置增强 * @param jp */ @Before("pointcut()") public void before(JoinPoint jp) &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法入参：" + Arrays.toString(jp.getArgs())); &#125; /** * 后置增强 * @param jp * @param returnValue */ @AfterReturning(pointcut = "pointcut()", returning = "returnValue") public void afterReturning(JoinPoint jp, Object returnValue) &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法返回值：" + returnValue); &#125; /** * 最终增强 * @param jp */ @After("pointcut()") public void afterLogger(JoinPoint jp) &#123; LOGGER.info(jp.getSignature().getName() + " 方法结束执行。"); &#125; /** * 异常增强 * @param jp * @param e */ @AfterThrowing(value="pointcut()", throwing = "e") public void afterThrowing(JoinPoint jp, RuntimeException e) &#123; LOGGER.error(jp.getSignature().getName() + " 方法发生异常：" + e); &#125; /** * 环绕增强 * @param jp * @return * @throws Throwable */ @Around("pointcut()") public Object aroundLogger(ProceedingJoinPoint jp) throws Throwable &#123; LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法入参：" + Arrays.toString(jp.getArgs())); try &#123; Object result = jp.proceed(); LOGGER.info("调用 " + jp.getTarget() + " 的 " + jp.getSignature().getName() + " 方法。方法返回值：" + result); return result; &#125; catch (Throwable e) &#123; LOGGER.error(jp.getSignature().getName() + " 方法发生异常：" + e); throw e; &#125; finally &#123; LOGGER.info(jp.getSignature().getName() + " 方法结束执行。"); &#125; &#125; &#125;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring核心概念]]></title>
    <url>%2F2018%2F11%2F06%2FSpring%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[控制反转（ioc）也成为依赖注入，来降低代码之间的耦合度搭建spring环境部署jar包12345commons-logging-1.2.jarspring-beans-3.2.13.RELEASE.jarspring-context-3.2.13.RELEASE.jarspring-core-3.2.13.RELEASE.jarspring-expression-3.2.13.RELEASE.jar 创建resources目录，在里面创建applicationContextl.xml1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:aop="http://www.springframework.org/schema/aop"xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsd"&gt;//根据属性seter()方法&lt;bean id="kai" class="naruto.entity.Equip"&gt;&lt;property name="name" value="万世荣光铠甲"/&gt;&lt;property name="speedPlus" value="4"/&gt;&lt;property name="attackPlus" value="108"/&gt;&lt;property name="defencePlus" value="40"/&gt;&lt;property name="type" value="铠甲"/&gt;&lt;/bean&gt;&lt;/bean&gt; 创建测试类12ClassPathXmlApplicationContext context=new ClassPathXmlApplicationContext("applicationContextl.xml"); //xml路径EquipMess jc=(EquipMess)context.getBean("equip"); //bean的id值 aop1234加入jar包spring-aop-3.2.13.RELEASE.jaraopalliance-1.0.jaraspectjweaver.jar 在aop包下创建aop输出类（前置和后置）1234567private static Logger logger=Logger.getLogger(UserServiceLogger.class);public void before(JoinPoint jp)&#123;logger.info("调用"+jp.getTarget()+"的"+jp.getSignature()+"方法，方法参数"+Arrays.toString(jp.getArgs()));&#125;public void afterReturning(JoinPoint jp,Object result)&#123;logger.info("调用"+jp.getTarget()+"的"+jp.getSignature()+"方法，方法返回值"+result);&#125; spring陪着文件导入相关配置定义切入点，加入增强处理12345678910&lt;bean id="theLogger" class="naruto.aop.Snippet"&gt;&lt;/bean&gt;&lt;aop:config&gt;&lt;aop:pointcut id="pointcut"expression="execution(public void updateEquip(entity.Equip))" /&gt;&lt;aop:aspect ref="theLogger"&gt;&lt;aop:before method="before" pointcut-ref="pointcut"&gt;&lt;/aop:before&gt;&lt;aop:after-returning method="afterReturning"pointcut-ref="pointcut" returning="result" /&gt;&lt;/aop:aspect&gt;&lt;/aop:config&gt;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis动态SQL]]></title>
    <url>%2F2018%2F11%2F06%2FMybatis%E5%8A%A8%E6%80%81SQL%2F</url>
    <content type="text"><![CDATA[if 语句123456&lt;select id="selectUserByUsernameAndSex" resultType="user" parameterType="com.ys.po.User"&gt;select * from user where&lt;if test="username != null"&gt;username=#&#123;username&#125;&lt;/if&gt;&lt;/select&gt; if+where 语句1234567891011&lt;select id="selectUserByUsernameAndSex" resultType="user" parameterType="com.ys.po.User"&gt;select * from user&lt;where&gt;&lt;if test="username != null"&gt;username=#&#123;username&#125;&lt;/if&gt;&lt;if test="username != null"&gt;and sex=#&#123;sex&#125;&lt;/if&gt;&lt;/where&gt;&lt;/select&gt; “where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。 if+set 语句12345678910111213&lt;!-- 根据 id 更新 user 表的数据 --&gt;&lt;update id=&quot;updateUserById&quot; parameterType=&quot;com.ys.po.User&quot;&gt;update user u&lt;set&gt;&lt;if test=&quot;username != null and username != &apos;&apos;&quot;&gt;u.username = #&#123;username&#125;,&lt;/if&gt;&lt;if test=&quot;sex != null and sex != &apos;&apos;&quot;&gt;u.sex = #&#123;sex&#125;&lt;/if&gt;&lt;/set&gt;where id=#&#123;id&#125;&lt;/update&gt; 如果第一个条件 username 为空，那么 sql 语句为：update user u set u.sex=? where id=?如果第一个条件不为空，那么 sql 语句为：update user u set u.username = ? ,u.sex = ? where id=? choose(when,otherwise) 语句12345678910111213141516&lt;select id="selectUserByChoose" resultType="com.ys.po.User" parameterType="com.ys.po.User"&gt;select * from user&lt;where&gt;&lt;choose&gt;&lt;when test="id !='' and id != null"&gt;id=#&#123;id&#125;&lt;/when&gt;&lt;when test="username !='' and username != null"&gt;and username=#&#123;username&#125;&lt;/when&gt;&lt;otherwise&gt;and sex=#&#123;sex&#125;&lt;/otherwise&gt;&lt;/choose&gt;&lt;/where&gt;&lt;/select&gt; 和switch语句差不多 trim 语句12345678910111213141516171819&lt;select id="selectUserByUsernameAndSex" resultType="user" parameterType="com.ys.po.User"&gt;select * from user&lt;!-- &lt;where&gt;&lt;if test="username != null"&gt;username=#&#123;username&#125;&lt;/if&gt;&lt;if test="username != null"&gt;and sex=#&#123;sex&#125;&lt;/if&gt;&lt;/where&gt; --&gt;&lt;trim prefix="where" prefixOverrides="and | or"&gt;&lt;if test="username != null"&gt;and username=#&#123;username&#125;&lt;/if&gt;&lt;if test="sex != null"&gt;and sex=#&#123;sex&#125;&lt;/if&gt;&lt;/trim&gt;&lt;/select&gt; prefix：前缀prefixoverride：去掉第一个and或者是or12345678&lt;trim prefix="set" suffixOverrides=","&gt; //去掉最后一个逗号&lt;if test="username != null and username != ''"&gt;u.username = #&#123;username&#125;,&lt;/if&gt;&lt;if test="sex != null and sex != ''"&gt;u.sex = #&#123;sex&#125;,&lt;/if&gt;&lt;/trim&gt; foreach 语句12345678910111213141516&lt;select id="selectUserByListId" parameterType="com.ys.vo.UserVo" resultType="com.ys.po.User"&gt; select * from user &lt;where&gt; &lt;!-- collection:指定输入对象中的集合属性 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串 select * from user where 1=1 and (id=1 or id=2 or id=3) --&gt; &lt;foreach collection="ids" item="id" open="and (" close=")" separator="or"&gt; id=#&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MybatisSQL映射文件]]></title>
    <url>%2F2018%2F11%2F06%2FMybatisSQL%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[sql映射文件顶级元素配置mapper：映射元素的根节点，只有一个属性namespace，用于区分不同的mapper，绑定dao接口cache：配置给命名空间引用缓存cache-ref：从其他命名空间引用缓存配置resultMap：描述数据库结果集和对象的对应关系sql：可以重用的sql块 insert：插入语句12345&lt;insert id="add" parameterType="Destineinfo"&gt;INSERT INTOdestineinfo(room_name,destine_time,destine_name,dress)VALUES(#&#123;room_name&#125;,#&#123;destine_time&#125;,#&#123;destine_name&#125;,#&#123;dress&#125;)&lt;/insert&gt; delete：删除语句123&lt;delete id="dele"&gt;DELETE FROM destineinfo where id=#&#123;id&#125;&lt;/delete&gt; update：更新语句12345&lt;update id="modify" parameterType="Destineinfo"&gt;UPDATE destineinfo SETroom_name=#&#123;room_name&#125;,destine_name=#&#123;destine_name&#125;where id=#&#123;id&#125;&lt;/update&gt; select：查询语句namespace的命名必须和某个dao接口相同，已Mapper结尾接口中的方法与映射文件中的sql语句id要对应的 눈눈select属性id：命名空间的唯一标识符，要和接口的方法一致눈눈parameterType：传入参数的类型，可以是类，或基本数据类型resultType：查询语句返回结果类型，可以是类，或基本数据类型 使用map入参查询1234&lt;select id="getMap" resultType="Destineinfo" parameterType="Map"&gt;SELECT * FROM destineinfo WHERE destine_name LIKECONCAT('%',#&#123;name&#125;,'%')&lt;/select&gt; map对象.put(“name”,姓名)； 使用resultMap完成查询结果的展现用于数据库字段名不同与实体类的属性名 ，可以进行自动映射 resultMap自动映射(FULL)12&lt;!-- 设置resultMap的自动映射级别为none(禁止自动匹配) --&gt;&lt;!-- &lt;setting name="autoMappingBehavior" value="NONE"/&gt; --&gt; 自动映射前提：字段名和属性名要一致12345&lt;result property="id" column="id" /&gt;&lt;result property="room_name" column="room_name" /&gt;&lt;result property="destine_time" column="destine_time" /&gt;&lt;result property="destine_name" column="destine_name" /&gt;&lt;result property="dressName" column="dressName" /&gt; 使用resultType完成查询结果的展现直接返回类型，包括基本数据类型和复杂数据类型resultType和resultMap只能有一个使用@param实现多参数入参12xml中id为updateName的id和destine_namepublic int updateName(@Param("id")Integer id,@Param("destine_name")String name); 高级映射association12345678&lt;resultMap type="Destineinfo" id="userRoleResult"&gt; &lt;id property="id"column="id" /&gt; &lt;result property="room_name" column="room_name"/&gt; &lt;resultproperty="destine_time" column="destine_time"/&gt; &lt;result property="destine_name"column="destine_name"/&gt; &lt;association property="dress2" javaType="Dress"&gt;&lt;id property="id" column="r_id" /&gt; &lt;result property="dressName" column="dressName"/&gt;&lt;/association&gt; &lt;/resultMap&gt; association映射 &lt;select id="getListByDressid" resultMap="userRoleResult"parameterType="Integer"&gt; SELECT d.*,s.id as r_id,s.dressName FROM destineinfod, dress s WHERE d.dress=#&#123;dress&#125; and d.dress=s.id &lt;/select&gt; 可以内嵌12345&lt;association property="dress2" javaType="Dress" resultMap="roleResult" /&gt;&lt;resultMap type="Dress" id="roleResult"&gt;&lt;id property="id" column="r_id"/&gt;&lt;result property="dressName" column="dressName"/&gt;&lt;/resultMap&gt; 使用对象 1对1association属性property：实体对象的属性，此处为user里定义的Role类对象rolejavaType：完整的Java类名或别名 collection123456789101112&lt;resultMap type="Destineinfo" id="userAddressResult"&gt;&lt;id property="id" column="id"/&gt;&lt;result property="room_name" column="room_name" /&gt;&lt;result property="destine_time" column="destine_time" /&gt;&lt;result property="destine_name" column="destine_name" /&gt;&lt;result property="dress" column="dress" /&gt;&lt;collection property="addressList" ofType="Dress" resultMap="Addresss" /&gt;&lt;/resultMap&gt;&lt;resultMap type="Dress" id="Addresss"&gt;&lt;id property="id" column="r_id"/&gt;&lt;result property="dressName" column="dressName"/&gt;&lt;/resultMap&gt; collection属性property：实体对象的属性ofType：完整的Java类名或别名使用集合 1对多]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初识Mybatis]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%88%9D%E8%AF%86Mybatis%2F</url>
    <content type="text"><![CDATA[部署mybatis部署jar包创建database.properties和mybatis-configl.xml文件12345database.propertiesdriver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/boardroom?useUnicode=true&amp;characterEncoding=utf-8user=rootpassword=123456 mybatis-configl.xml 最重要的核心文件123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;!-- 引入database.properties文件 --&gt;&lt;properties resource="database.properties" /&gt;&lt;!-- 配置mybatis的log实现为LOG4J --&gt;&lt;settings&gt;&lt;setting name="logImpl" value="LOG4J" /&gt;&lt;/settings&gt;&lt;typeAliases&gt;&lt;typeAlias alias="user" type="cn.entity.User"/&gt;&lt;typeAlias alias="product" type="cn.entity.Product"/&gt;&lt;package name="cn.entity"/&gt;&lt;/typeAliases&gt;&lt;!-- 配置mybatis多套运行环境 --&gt;&lt;environments default="development"&gt;&lt;environment id="development"&gt;&lt;!-- 配置事务管理,采用JDBC的事务管理 --&gt;&lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt;&lt;!-- POOLED:mybatis自带的数据源,JNDI:基于tomcat的数据源 --&gt;&lt;dataSource type="POOLED"&gt;&lt;property name="driver" value="$&#123;driver&#125;"/&gt;&lt;property name="url" value="$&#123;url&#125;"/&gt;&lt;property name="username" value="$&#123;user&#125;"/&gt;&lt;property name="password" value="$&#123;password&#125;"/&gt;&lt;/dataSource&gt;&lt;/environment&gt;&lt;/environments&gt;&lt;!-- 将mapper文件加入到配置文件中 --&gt;&lt;mappers&gt;&lt;mapper resource="cn/entity/ProductMapper.xml"/&gt;&lt;mapper resource="cn/entity/DestineinfoMapper.xml"/&gt;&lt;/mappers&gt;&lt;/configuration&gt; util包下创建MyBatisUtil.java文件12345678910111213141516171819private static SqlSessionFactory factory;static&#123;InputStream is;try &#123;is = Resources.getResourceAsStream("mybatis-configl.xml");factory=new SqlSessionFactoryBuilder().build(is);&#125; catch (IOException e) &#123;// TODO Auto-generated catch blocke.printStackTrace();&#125;&#125;public static SqlSession CreateSqlSession()&#123;return factory.openSession(false); //true为自动提交事务&#125;public static void closeSqlSession(SqlSession sqlSession)&#123;if(null!=sqlSession)&#123;sqlSession.close();&#125;&#125; dao层创建接口,以实体类名字+mapper命名entity层创建实体类和实体类名字+mapper.xml1234567891011namespace建议使用接口地址，进行增删改查&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.dao.impl.DestineinfoMapper"&gt;&lt;!-- 查询用户表记录数 --&gt;&lt;select id="selall" resultType="Destineinfo"&gt;SELECT * FROM destineinfo&lt;/select&gt;&lt;/mapper&gt; 创建测试类1234567891011121314151617@Testpublic void testGetUserList()&#123;SqlSession sqlSession=null;List&lt;Destineinfo&gt;userList=new ArrayList&lt;Destineinfo&gt;();try &#123;sqlSession=MyBatisUtil.CreateSqlSession();userList=sqlSession.getMapper(DestineinfoMapper.class).selall();&#125; catch (Exception e) &#123;// TODO: handle exceptione.printStackTrace();&#125;finally &#123;MyBatisUtil.closeSqlSession(sqlSession);&#125;for (Destineinfo destineinfo : userList) &#123;logger.debug("testGetUserList userCodeL"+destineinfo.getId()+"--"+destineinfo.getRoom_name()+"--"+destineinfo.getDestine_name()+"------"+destineinfo.getDestine_time());&#125;&#125; mybatis核心对象SqlSessionFactoryBuilder负责构建SqlSessionFactory，特点：用过就丢，SqlSessionFactory创建后就不不需要存在了 SqlSessionFactory创建SqlSession实例的工厂，SqlSession通过SqlSessionFactory的openSession()来获取openSession()的参数为bollean类型时，true为关闭事务控制，自动提交，不穿参数，默认为true一旦创建始终存在,不建议创建多个 SqlSession用于持久化操作的对象，类似与jdbc的connection，提供了面向数据库sql命令的所有方法使用SqlSession的两种方法通过sqlSession实例直接执行已映射的sql语句通过mapper接口方法操作数据 mybatis-configl.xml的核心元素typeAliases配置类型别名12345&lt;typeAliases&gt;&lt;typeAlias alias="user" type="cn.entity.User"/&gt;&lt;typeAlias alias="product" type="cn.entity.Product"/&gt;&lt;package name="cn.entity"/&gt;&lt;/typeAliases&gt; mappers映射器1234&lt;mappers&gt;&lt;mapper resource="cn/entity/ProductMapper.xml"/&gt;&lt;mapper resource="cn/entity/DestineinfoMapper.xml"/&gt;&lt;/mappers&gt;]]></content>
      <categories>
        <category>SSM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[漫漫归家路]]></title>
    <url>%2F2018%2F11%2F05%2F%E6%BC%AB%E6%BC%AB%E5%BD%92%E5%AE%B6%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[漫漫归家路其实我喊了一次又一次，每一次，都清醒的认识到果然没有人回应我，无论怎么呼唤，怎么祈祷，还是有无法实现的东西。 最后还是没能找到家，迷路了，累到了，然后，我决定不在呼唤无法给予我回应的东西。——《夏目友人帐》漫漫回家路]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[S8决赛IG3:0夺冠]]></title>
    <url>%2F2018%2F11%2F04%2FS8%E5%86%B3%E8%B5%9BIG3-0%E5%A4%BA%E5%86%A0%2F</url>
    <content type="text"><![CDATA[一个纨绔的老板， 一个没战队要的上单， 一个附赠的中单， 一个借来的打野， 一个直播抓来的ad， 一个双排排到的辅助， 一支没什么人看好的战队， 一场全球总决赛冠军， 一座山，山后是你们的故事 恭喜IG]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理想乡]]></title>
    <url>%2F2018%2F11%2F02%2F%E7%90%86%E6%83%B3%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[理想乡孤独な巡礼我在这世上活着 手无寸铁 没有任何人站在我的身后 挡住汹涌的风 更没有人能站在我的面前 挡住浩瀚的阳光 我在这世上活着 怀抱一小弦洁净 像黑夜抱着月亮那样慎重 怀抱着一大束荆棘 像土地抱着青草那样深情 怀抱着一大捧冰雪 像群山怀抱着清泉一样珍重 我在这世上活着 一切规章一切守则都是假设 他们说 你得有人 才是真的 我抱紧我自己 我有我自己 抱得更紧更牢靠一些啊 我的尊严 我的本份 我人的样子 我活在这世上 手无寸铁 没有刀锋 没有尖锐的刺 从不无往不利 从不春风得意 我站立的姿势比剑优美 我沉醉的笑容比花绚丽 我写字的认真比诵经虔诚 我痛哭的声音比长歌真实 我活在这世上 手无寸铁 我活在这世上 自强自立 自得其美 我只有 自己]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库应用]]></title>
    <url>%2F2018%2F11%2F01%2FOracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[表空间（用来存放各种应用文件）一般分为三种123$ 永久性表空间：一般保存表，过程，索引等数据$ 临时性表空间：只用于保存系统中短期活动的数据，如排序数据$ 撤销表空间：用来帮助回退为=未提交的事务数据 那么为什么要创建表空间呢？对不同用户分配不同的表空间，方便管理有利于管理磁盘空间，提高i/o性能 一些基本的授权1234567891011创建用户没有授权【创建表】create table student(stu_id number(2),stu_name varchar2(10));create table student(stu_id number(2),stu_name varchar2(10))*第 1 行出现错误:ORA-01031: 权限不足?//使用system用户授权grant connect,resource to martin; //授权用户connect,resource 权限grant select on scott.emp to martin; //允许用户查看emp表中记录grant update on scott.emp to martin; //允许用户修改emp表中记录 同义词（公有和私有 //私有只能被当前模式用户访问）简化sql语句隐藏对象名称和所有者为分布式数据库的远程对象提供了位置透明性提供对象的公共访问 给用户martin授权同义词 grant create synonym to martin; ? 创建私有同义词 SQL&gt; create synonym sy_emp for system.employee; ? 同义词已创建。 ? SQL&gt; select *from sy_emp; ? 创建共有同义词（在物主用户上创建） SQL&gt; create public synonym public_sy_emp for employee; ? 同义词已创建。 ? SQL&gt; ? 删除私有同义词 SQL&gt; drop synonym martin.sy_emp; ? 同义词已删除。 ? SQL&gt; ? 删除共有同义词 SQL&gt; drop public synonym public_sy_emp; ? 同义词已删除。 SQL&gt; 创建序列和就是生成主键要用的，感觉不好用 SQL&gt; create sequence seq1 2 start with 10 3 increment by 1 4 maxvalue 2000 5 nocycle 6 cache 30; ? 序列已创建。 ? SQL&gt; create table toys(toyid number(2), toyname varchar2(10),toyprice number(4,2)); ? 表已创建。 ? SQL&gt; insert into toys(toyid,toyname,toyprice)values(seql.nextval,'杰尼龟',25); insert into toys(toyid,toyname,toyprice)values(seql.nextval,'杰尼龟',25) * 第 1 行出现错误: ORA-02289: 序列不存在 ? ? SQL&gt; insert into toys(toyid,toyname,toyprice)values(seq1.nextval,'杰尼龟',25); ? 已创建 1 行。 ? SQL&gt; insert into toys(toyid,toyname,toyprice)values(seq1.nextval,'憨八龟',35); ? 已创建 1 行。 ? SQL&gt; select * from toys; ? TOYID TOYNAME TOYPRICE ---------- -------------------- ---------- 11 杰尼龟 25 12 憨八龟 35 ? SQL&gt; create table tots(totid number(2), totname varchar2(10),totprice number(4,2)); ? 表已创建。 ? SQL&gt; insert into tots(totid,totname,totprice)values(seq1.nextval,'小火龙',40); ? 已创建 1 行。 ? SQL&gt; insert into tots(totid,totname,totprice)values(seq1.nextval,'毒龙钻',80); ? 已创建 1 行。 ? SQL&gt; select * from tots; ? TOTID TOTNAME TOTPRICE ---------- -------------------- ---------- 14 小火龙 40 15 毒龙钻 80 反向键索引目的：比如索引值是一个自动增长的列多个用户对集中在少数块上的索引行进行修改，容易引起资源的争用，比如对数据块的等待。此时建立反向索 引。语法：CREATE INDEX index_REVERSE_EMPNO ON table (column) REVERSE; 位图索引1、 何时创建：列中有非常多的重复的值时候。例如某列保存了 “性别”信息。Where 条件中包含了很多OR操作符。较少的update操作，因为要相应的跟新所有的bitmap2、 结构：位图索引使用位图作为键值，对于表中的每一数据行位图包含了TRUE(1)、FALSE(0)、或NULL值。3、 优点：位图以一种压缩格式存放，因此占用的磁盘空间比标准索引要小得多4、 语法：CREATE BITMAP INDEX index ON table (column[, column]…); 唯一索引1、 何时创建：当某列任意两行的值都不相同2、 当建立Primary Key(主键)或者Unique constraint(唯一约束)时，唯一索引将被自动建立3、 语法：CREATE UNIQUE INDEX index ON table (column); 熟练并背诵数据库建立索引的原则1，确定针对该表的操作是大量的查询操作还是大量的增删改操作。?2，尝试建立索引来帮助特定的查询。检查自己的sql语句，为那些频繁在where子句中出现的字段建立索引。?3，尝试建立复合索引来进一步提高系统性能。修改复合索引将消耗更长时间，同时，复合索引也占磁盘空间。?4，对于小型的表，建立索引可能会影响性能?5，应该避免对具有较少值的字段进行索引。?6，避免选择大型数据类型的列作为索引。?索引建立的原则?索引查询是数据库中重要的记录查询方法，要不要进入索引以及在那些字段上建立索引都要和实际数据库系统的查询要求结合来考虑，下面给出实际中的一些通用的原则：? 在经常用作过滤器的字段上建立索引；? 在SQL语句中经常进行GROUP BY、ORDER BY的字段上建立索引；? 在不同值较少的字段上不必要建立索引，如性别字段；? 对于经常存取的列避免建立索引；? 用于联接的列（主健/外健）上建立索引；? 在经常存取的多个列上建立复合索引，但要注意复合索引的建立顺序要按照使用的频度来确定；? 缺省情况下建立的是非簇集索引，但在以下情况下最好考虑簇集索引，如：含有有限数目（不是很少）唯一的列；进行大范围的查询；充分的利用索引可以减少表扫描I/0的次数，有效的避免对整表的搜索。当然合理的索引要建立在对各种查询的分析和预测中，也取决于DBA的所设计的数据库结构。 范围分区（超好用，就是麻烦）范围分区（数字类型） create table graderecord ( sno varchar2(10), sname varchar2(20), dormitory varchar2(3), grade int ) partition by range(grade) ( partition bujige values less than(60), --不及格 partition jige values less than(85), --及格 partition youxiu values less than(maxvalue) --优秀 ) ? 范围分区（日期类型） create table sales ( sales_id number, product_id varchar2(5), sales_date date not null, sales_cost number(10), areacode varchar2(10) ) partition by range(sales_date) ( partition p1 values less than(to_date('2013-04-1','yyyy-mm-dd')), partition p2 values less than(to_date('2013-07-1','yyyy-mm-dd')), partition p3 values less than(to_date('2013-10-1','yyyy-mm-dd')), partition p4 values less than(to_date('2014-01-1','yyyy-mm-dd')), partition p5 values less than(maxvalue) ); insert into sales values(1,'22',to_date('2013-04-1','yyyy-mm-dd'),92,'美国'); insert into sales values(2,'22',to_date('2013-05-1','yyyy-mm-dd'),92,'韩国'); insert into sales values(3,'23',to_date('2013-08-1','yyyy-mm-dd'),92,'中国'); insert into sales values(4,'24',to_date('2013-11-1','yyyy-mm-dd'),92,'日本'); insert into sales values(5,'25',to_date('2013-09-1','yyyy-mm-dd'),92,'俄罗斯'); 查询分区情况查询分区情况 SELECT table_name,partition_name,tablespace_name FROM user_tab_partitions WHERE table_name=UPPER('sales_interval1'); 间隔分区表，会自动创建分区=========================================================== | 间隔分区表 ============================================================ */ CREATE TABLE sales_interval1 (sales_id NUMBER NOT NULL, product_id VARCHAR2(5), sales_date DATE, sales_cost NUMBER(10), areacode VARCHAR2(5) ) PARTITION BY RANGE(sales_date) INTERVAL(NUMTOYMINTERVAL(1,'YEAR')) (PARTITION part1 VALUES LESS THAN (to_date('2011/01/01','yyyy/mm/dd'))) 使用分区查找信息查看分区并查询信息 SQL&gt; select table_name,partition_name from user_tab_partitions where table_name=upper('sales2'); ? TABLE_NAME ------------------------------------------------------------ PARTITION_NAME ------------------------------------------------------------ SALES2 P1 ? SALES2 SYS_P24 ? ? SQL&gt; select * from sales2 partition(sys_p24); ? SALES_ID PRODUCT_ID SALES_DATE SALES_COST AREACODE ---------- ---------- -------------- ---------- -------------------- 4 24 01-11月-13 92 日本 5 25 01-9月 -13 92 俄罗斯 ? SQL&gt; select * from sales2 partition(p1); ? SALES_ID PRODUCT_ID SALES_DATE SALES_COST AREACODE ---------- ---------- -------------- ---------- -------------------- 1 22 01-4月 -13 92 美国 2 22 01-5月 -13 92 韩国 3 23 01-8月 -13 92 中国 ? SQL&gt; ? 今天我是听着Ragga Bomb -Skrillex完成的]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库基础]]></title>
    <url>%2F2018%2F11%2F01%2FOracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Oracle简介1$ 众所周知，Oracle是个数据库，是Oracle公司的核心产品，优越的数据安全性和完整性，以及跨操作系统，跨硬件平台，主要特点：支持多用户，大事务的事务处理，在保持数据安全性和完整性方面性能优越，支持分布式事务处理，具有可移植性 Oracle基本概念$ 数据库：这不是我们平时所说的数据库，它是磁盘上存储数据的集合 $ 全局数据库名：用于区分一个数据库的标识，要唯一 $ 数据库实例：每个启动的数据库都对应一个数据库实例，有这个实例来访问数据库中的数据 $ 表空间：数据库若干个表空间组成，... $ 数据文件：数据文件扩展名.dbf 是来存储数据库数据的文件 $ 控制文件：控制文件扩展名.ctl 一个二进制文件,根据控制文件查找数据文件 $ 日志文件：日志文件扩展名.log,记录数据更改信息 Oracle重要的三个服务（建议全部设为手动，玩游戏的时候会卡的）$ OracleServiceSID：Oracle数据库服务，对应名为SID（系统标识符）我的是orcl $ OracleOraDb11g_home1TNSListener：监听器服务，如果要远程链接数据库服务器，就必须启动它 $ OracleDBConsoleSID：嗯，这个是控制台服务 SID（系统标识符） 连接Oracle数据库$ SQL*PLUS：system/orcl@orclDB //system是当前用户，orcl为密码，orclDB为使用的网络服务名 $ PL/SQL Developer：直接输入登录ok了 Oracle数据类型（列举几个比较难理解的）$ NUMBER(P,S)：p是精度，标识数字的有效位数，不包括小数点后，s标识小数点右边的位数，是四舍五入的哦 $ Date：SYSDATE标识返回当前的日期和时间，SYSTIMESTAMP返回当前的日期和时间和时区（精确到毫秒）可怕 $ LOB数据类型（大对象）：CLOB(字符clob，存储大量文字),BLOB(二进制lob，存储视频，图片这类)，BFILE(二进制文件，存储二进制文件)，NCLOB(存储大的nchar数据) Oracle中的伪列就像是一个表列，但是它并没有存储到表中，可以查询伪列，但是不能增删改 $ ROWID：每行都有一个行地址，ROWID就是返回该行地址 $ ROWNUM：返回一个数值代表行的次序，可以限制返回的行数（ROWNUM=1可以查到数据，ROWNUM=2就查不到，ROWNUM&gt;N也差不到，ROWNUM&lt;11查询10条记录） 查询数据不重复显示(DISTINCT)SELECT DISTINCT stuNmae from student 集合操作符UNION：返回连个查询选定的所有不重复行UNION ALL：符合两个查询锁定的所有行，包括重复的行INTERSECT：只返回两个查询都有的行MINUS：只返回第一个选定而未被第二个选定的行 连接操作符（||）将两个或多个字符串合并为一个字符串 SQL函数常用的转换函数 $ TO_CHAR 转字符串 （TO_CHAR(SYSDATE，‘YYYY 年fmMM月fmDD日 HH24:MI:SS’)） $ TO_DATE 转日期类型 $ TO_NUMBER 转数值类型 其他函数 $ NVL(EXP1,EXP2)：如果EXP1的值为null，返回EXP2,否则返回EXP1 $ NVL2(EXP1,EXP2,EXP3)：如果EXP1为null，返回EXP3,否则返回EXP2 $ DECODE(VALUE,IF1,THEN1,IF2,THEN2,ELSE)：VALUE值为IF1,则进入THEN1.. 分析函数马上11点了.. 我先走了，自行百度 今天我是听着THE NIGHT – Avicii完成的]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[漫漫归家路]]></title>
    <url>%2F2018%2F11%2F01%2F2018-DJ-MAG%2F</url>
    <content type="text"><![CDATA[漫漫归家路其实我喊了一次又一次，每一次，都清醒的认识到果然没有人回应我，无论怎么呼唤，怎么祈祷，还是有无法实现的东西。 最后还是没能找到家，迷路了，累到了，然后，我决定不在呼唤无法给予我回应的东西。——《夏目友人帐》漫漫回家路]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试问老天，不抵抗是罪吗？]]></title>
    <url>%2F2018%2F11%2F01%2F%E8%AF%95%E9%97%AE%E8%80%81%E5%A4%A9%EF%BC%8C%E4%B8%8D%E6%8A%B5%E6%8A%97%E6%98%AF%E7%BD%AA%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[OK Start任由其他人攀爬丝也会断,那么 “试问老天,不抵抗是罪吗?”太宰治 《人间失格》1「释迦牟尼看到在地狱挣扎的大盗，他干尽了恶事，但他唯一做的好事就是放过了一只蜘蛛，佛祖考虑救他一命，就取下一缕蛛丝朝着地狱垂了下去大盗无意间看到了这根蜘蛛丝，他顺着爬了上去，却发现后面罪人们跟着一起，自私的叫他们滚开，结果蛛丝断了，他们又回到血色的地狱」]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现在是星期三22:10分]]></title>
    <url>%2F2018%2F10%2F31%2F%E7%8E%B0%E5%9C%A8%E6%98%AF%E6%98%9F%E6%9C%9F%E4%B8%8922-10%E5%88%86%2F</url>
    <content type="text"><![CDATA[OK Start今天也是幸福的一天，晚上吃了两个烤馍，一根烤面筋，一根烤肠1$ 还有一件事，评论发送邮件功能开启]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的一天]]></title>
    <url>%2F2018%2F10%2F30%2F%E6%96%B0%E7%9A%84%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"></content>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[在一个突如其来的下午，一个可怕的想法在我的脑中出现 ###它诞生了…]]></content>
  </entry>
</search>
